var NearWalletSelectorInit = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all5) => {
    for (var name in all5)
      __defProp(target, name, { get: all5[name], enumerable: true });
  };
  var __copyProps = (to, from5, except, desc) => {
    if (from5 && typeof from5 === "object" || typeof from5 === "function") {
      for (let key of __getOwnPropNames(from5))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@esbuild-plugins/node-globals-polyfill/process.js
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance2) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
  var init_process = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener = noop;
      once = noop;
      off = noop;
      removeListener = noop;
      removeAllListeners = noop;
      emit = noop;
      performance2 = globalThis.performance || {};
      performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      startTime = /* @__PURE__ */ new Date();
      process = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
      defines = {};
      Object.keys(defines).forEach((key) => {
        const segs = key.split(".");
        let target = process;
        for (let i = 0; i < segs.length; i++) {
          const seg = segs[i];
          if (i === segs.length - 1) {
            target[seg] = defines[key];
          } else {
            target = target[seg] || (target[seg] = {});
          }
        }
      });
    }
  });

  // node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function base64toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function base64fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill5, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill5 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill5, encoding) : createBuffer(that, size).fill(fill5);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError(
      "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
    );
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
      );
    }
    return length | 0;
  }
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(
            buffer,
            val,
            byteOffset
          );
        } else {
          return Uint8Array.prototype.lastIndexOf.call(
            buffer,
            val,
            byteOffset
          );
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(
      utf8ToBytes(string, buf.length - offset),
      buf,
      offset,
      length
    );
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(
      utf16leToBytes(string, buf.length - offset),
      buf,
      offset,
      length
    );
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64fromByteArray(buf);
    } else {
      return base64fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset, ext, max7, min7) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max7 || value < min7)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  function checkIEEE754(buf, value, offset, ext, max7, min7) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset,
        4,
        34028234663852886e22,
        -34028234663852886e22
      );
    }
    ieee754write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset,
        8,
        17976931348623157e292,
        -17976931348623157e292
      );
    }
    ieee754write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16) return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi2, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  function ieee754read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  }
  var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_Buffer = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
      init_process();
      init_buffer();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
      Buffer.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      Buffer.poolSize = 8192;
      Buffer._augment = function(arr) {
        arr.__proto__ = Buffer.prototype;
        return arr;
      };
      Buffer.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      Buffer.kMaxLength = kMaxLength();
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype;
        Buffer.__proto__ = Uint8Array;
        if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
        }
      }
      Buffer.alloc = function(size, fill5, encoding) {
        return alloc(null, size, fill5, encoding);
      };
      Buffer.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer.isBuffer = isBuffer;
      Buffer.compare = function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b) return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer.byteLength = byteLength;
      Buffer.prototype._isBuffer = true;
      Buffer.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer.prototype.toString = function toString() {
        var length = this.length | 0;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer.prototype.equals = function equals(b) {
        if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer.compare(this, b) === 0;
      };
      Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        var newBuf;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        var val = this[offset + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        var i = byteLength3;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754read(this, offset, true, 23, 4);
      };
      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754read(this, offset, false, 23, 4);
      };
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754read(this, offset, true, 52, 8);
      };
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754read(this, offset, false, 52, 8);
      };
      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
  var init_buffer = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
      init_Buffer();
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/constants.js
  var require_constants2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger2();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/assignable.js
  var require_assignable = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/errors.js
  var require_errors2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/response.js
  var require_response = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/index.js
  var require_provider = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/types/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable(), exports2);
      __exportStar(require_errors2(), exports2);
      __exportStar(require_provider(), exports2);
    }
  });

  // node_modules/mustache/mustache.js
  var require_mustache = __commonJS({
    "node_modules/mustache/mustache.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
      })(exports2, (function() {
        "use strict";
        var objectToString2 = Object.prototype.toString;
        var isArray6 = Array.isArray || function isArrayPolyfill(object) {
          return objectToString2.call(object) === "[object Array]";
        };
        function isFunction4(object) {
          return typeof object === "function";
        }
        function typeStr(obj) {
          return isArray6(obj) ? "array" : typeof obj;
        }
        function escapeRegExp(string) {
          return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        }
        function hasProperty(obj, propName) {
          return obj != null && typeof obj === "object" && propName in obj;
        }
        function primitiveHasOwnProperty(primitive, propName) {
          return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
        }
        var regExpTest = RegExp.prototype.test;
        function testRegExp(re, string) {
          return regExpTest.call(re, string);
        }
        var nonSpaceRe = /\S/;
        function isWhitespace(string) {
          return !testRegExp(nonSpaceRe, string);
        }
        var entityMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
          "/": "&#x2F;",
          "`": "&#x60;",
          "=": "&#x3D;"
        };
        function escapeHtml(string) {
          return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
            return entityMap[s];
          });
        }
        var whiteRe = /\s*/;
        var spaceRe = /\s+/;
        var equalsRe = /\s*=/;
        var curlyRe = /\s*\}/;
        var tagRe = /#|\^|\/|>|\{|&|=|!/;
        function parseTemplate(template, tags) {
          if (!template)
            return [];
          var lineHasNonSpace = false;
          var sections = [];
          var tokens = [];
          var spaces = [];
          var hasTag = false;
          var nonSpace = false;
          var indentation = "";
          var tagIndex = 0;
          function stripSpace() {
            if (hasTag && !nonSpace) {
              while (spaces.length)
                delete tokens[spaces.pop()];
            } else {
              spaces = [];
            }
            hasTag = false;
            nonSpace = false;
          }
          var openingTagRe, closingTagRe, closingCurlyRe;
          function compileTags(tagsToCompile) {
            if (typeof tagsToCompile === "string")
              tagsToCompile = tagsToCompile.split(spaceRe, 2);
            if (!isArray6(tagsToCompile) || tagsToCompile.length !== 2)
              throw new Error("Invalid tags: " + tagsToCompile);
            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
            closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
            closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
          }
          compileTags(tags || mustache.tags);
          var scanner = new Scanner(template);
          var start, type, value, chr, token, openSection;
          while (!scanner.eos()) {
            start = scanner.pos;
            value = scanner.scanUntil(openingTagRe);
            if (value) {
              for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
                chr = value.charAt(i);
                if (isWhitespace(chr)) {
                  spaces.push(tokens.length);
                  indentation += chr;
                } else {
                  nonSpace = true;
                  lineHasNonSpace = true;
                  indentation += " ";
                }
                tokens.push(["text", chr, start, start + 1]);
                start += 1;
                if (chr === "\n") {
                  stripSpace();
                  indentation = "";
                  tagIndex = 0;
                  lineHasNonSpace = false;
                }
              }
            }
            if (!scanner.scan(openingTagRe))
              break;
            hasTag = true;
            type = scanner.scan(tagRe) || "name";
            scanner.scan(whiteRe);
            if (type === "=") {
              value = scanner.scanUntil(equalsRe);
              scanner.scan(equalsRe);
              scanner.scanUntil(closingTagRe);
            } else if (type === "{") {
              value = scanner.scanUntil(closingCurlyRe);
              scanner.scan(curlyRe);
              scanner.scanUntil(closingTagRe);
              type = "&";
            } else {
              value = scanner.scanUntil(closingTagRe);
            }
            if (!scanner.scan(closingTagRe))
              throw new Error("Unclosed tag at " + scanner.pos);
            if (type == ">") {
              token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
            } else {
              token = [type, value, start, scanner.pos];
            }
            tagIndex++;
            tokens.push(token);
            if (type === "#" || type === "^") {
              sections.push(token);
            } else if (type === "/") {
              openSection = sections.pop();
              if (!openSection)
                throw new Error('Unopened section "' + value + '" at ' + start);
              if (openSection[1] !== value)
                throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
            } else if (type === "name" || type === "{" || type === "&") {
              nonSpace = true;
            } else if (type === "=") {
              compileTags(value);
            }
          }
          stripSpace();
          openSection = sections.pop();
          if (openSection)
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
          return nestTokens(squashTokens(tokens));
        }
        function squashTokens(tokens) {
          var squashedTokens = [];
          var token, lastToken;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            if (token) {
              if (token[0] === "text" && lastToken && lastToken[0] === "text") {
                lastToken[1] += token[1];
                lastToken[3] = token[3];
              } else {
                squashedTokens.push(token);
                lastToken = token;
              }
            }
          }
          return squashedTokens;
        }
        function nestTokens(tokens) {
          var nestedTokens = [];
          var collector = nestedTokens;
          var sections = [];
          var token, section;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            switch (token[0]) {
              case "#":
              case "^":
                collector.push(token);
                sections.push(token);
                collector = token[4] = [];
                break;
              case "/":
                section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;
              default:
                collector.push(token);
            }
          }
          return nestedTokens;
        }
        function Scanner(string) {
          this.string = string;
          this.tail = string;
          this.pos = 0;
        }
        Scanner.prototype.eos = function eos() {
          return this.tail === "";
        };
        Scanner.prototype.scan = function scan2(re) {
          var match5 = this.tail.match(re);
          if (!match5 || match5.index !== 0)
            return "";
          var string = match5[0];
          this.tail = this.tail.substring(string.length);
          this.pos += string.length;
          return string;
        };
        Scanner.prototype.scanUntil = function scanUntil(re) {
          var index = this.tail.search(re), match5;
          switch (index) {
            case -1:
              match5 = this.tail;
              this.tail = "";
              break;
            case 0:
              match5 = "";
              break;
            default:
              match5 = this.tail.substring(0, index);
              this.tail = this.tail.substring(index);
          }
          this.pos += match5.length;
          return match5;
        };
        function Context(view, parentContext) {
          this.view = view;
          this.cache = { ".": this.view };
          this.parent = parentContext;
        }
        Context.prototype.push = function push2(view) {
          return new Context(view, this);
        };
        Context.prototype.lookup = function lookup3(name) {
          var cache3 = this.cache;
          var value;
          if (cache3.hasOwnProperty(name)) {
            value = cache3[name];
          } else {
            var context2 = this, intermediateValue, names, index, lookupHit = false;
            while (context2) {
              if (name.indexOf(".") > 0) {
                intermediateValue = context2.view;
                names = name.split(".");
                index = 0;
                while (intermediateValue != null && index < names.length) {
                  if (index === names.length - 1)
                    lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                  intermediateValue = intermediateValue[names[index++]];
                }
              } else {
                intermediateValue = context2.view[name];
                lookupHit = hasProperty(context2.view, name);
              }
              if (lookupHit) {
                value = intermediateValue;
                break;
              }
              context2 = context2.parent;
            }
            cache3[name] = value;
          }
          if (isFunction4(value))
            value = value.call(this.view);
          return value;
        };
        function Writer() {
          this.templateCache = {
            _cache: {},
            set: function set9(key, value) {
              this._cache[key] = value;
            },
            get: function get10(key) {
              return this._cache[key];
            },
            clear: function clear5() {
              this._cache = {};
            }
          };
        }
        Writer.prototype.clearCache = function clearCache() {
          if (typeof this.templateCache !== "undefined") {
            this.templateCache.clear();
          }
        };
        Writer.prototype.parse = function parse3(template, tags) {
          var cache3 = this.templateCache;
          var cacheKey = template + ":" + (tags || mustache.tags).join(":");
          var isCacheEnabled = typeof cache3 !== "undefined";
          var tokens = isCacheEnabled ? cache3.get(cacheKey) : void 0;
          if (tokens == void 0) {
            tokens = parseTemplate(template, tags);
            isCacheEnabled && cache3.set(cacheKey, tokens);
          }
          return tokens;
        };
        Writer.prototype.render = function render(template, view, partials, tags) {
          var tokens = this.parse(template, tags);
          var context2 = view instanceof Context ? view : new Context(view, void 0);
          return this.renderTokens(tokens, context2, partials, template, tags);
        };
        Writer.prototype.renderTokens = function renderTokens(tokens, context2, partials, originalTemplate, tags) {
          var buffer = "";
          var token, symbol, value;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            value = void 0;
            token = tokens[i];
            symbol = token[0];
            if (symbol === "#") value = this.renderSection(token, context2, partials, originalTemplate);
            else if (symbol === "^") value = this.renderInverted(token, context2, partials, originalTemplate);
            else if (symbol === ">") value = this.renderPartial(token, context2, partials, tags);
            else if (symbol === "&") value = this.unescapedValue(token, context2);
            else if (symbol === "name") value = this.escapedValue(token, context2);
            else if (symbol === "text") value = this.rawValue(token);
            if (value !== void 0)
              buffer += value;
          }
          return buffer;
        };
        Writer.prototype.renderSection = function renderSection(token, context2, partials, originalTemplate) {
          var self2 = this;
          var buffer = "";
          var value = context2.lookup(token[1]);
          function subRender(template) {
            return self2.render(template, context2, partials);
          }
          if (!value) return;
          if (isArray6(value)) {
            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
              buffer += this.renderTokens(token[4], context2.push(value[j]), partials, originalTemplate);
            }
          } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
            buffer += this.renderTokens(token[4], context2.push(value), partials, originalTemplate);
          } else if (isFunction4(value)) {
            if (typeof originalTemplate !== "string")
              throw new Error("Cannot use higher-order sections without the original template");
            value = value.call(context2.view, originalTemplate.slice(token[3], token[5]), subRender);
            if (value != null)
              buffer += value;
          } else {
            buffer += this.renderTokens(token[4], context2, partials, originalTemplate);
          }
          return buffer;
        };
        Writer.prototype.renderInverted = function renderInverted(token, context2, partials, originalTemplate) {
          var value = context2.lookup(token[1]);
          if (!value || isArray6(value) && value.length === 0)
            return this.renderTokens(token[4], context2, partials, originalTemplate);
        };
        Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
          var filteredIndentation = indentation.replace(/[^ \t]/g, "");
          var partialByNl = partial.split("\n");
          for (var i = 0; i < partialByNl.length; i++) {
            if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
              partialByNl[i] = filteredIndentation + partialByNl[i];
            }
          }
          return partialByNl.join("\n");
        };
        Writer.prototype.renderPartial = function renderPartial(token, context2, partials, tags) {
          if (!partials) return;
          var value = isFunction4(partials) ? partials(token[1]) : partials[token[1]];
          if (value != null) {
            var lineHasNonSpace = token[6];
            var tagIndex = token[5];
            var indentation = token[4];
            var indentedValue = value;
            if (tagIndex == 0 && indentation) {
              indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
            }
            return this.renderTokens(this.parse(indentedValue, tags), context2, partials, indentedValue);
          }
        };
        Writer.prototype.unescapedValue = function unescapedValue(token, context2) {
          var value = context2.lookup(token[1]);
          if (value != null)
            return value;
        };
        Writer.prototype.escapedValue = function escapedValue(token, context2) {
          var value = context2.lookup(token[1]);
          if (value != null)
            return mustache.escape(value);
        };
        Writer.prototype.rawValue = function rawValue(token) {
          return token[1];
        };
        var mustache = {
          name: "mustache.js",
          version: "4.0.0",
          tags: ["{{", "}}"],
          clearCache: void 0,
          escape: void 0,
          parse: void 0,
          render: void 0,
          Scanner: void 0,
          Context: void 0,
          Writer: void 0,
          /**
           * Allows a user to override the default caching strategy, by providing an
           * object with set, get and clear methods. This can also be used to disable
           * the cache by setting it to the literal `undefined`.
           */
          set templateCache(cache3) {
            defaultWriter.templateCache = cache3;
          },
          /**
           * Gets the default or overridden caching object from the default writer.
           */
          get templateCache() {
            return defaultWriter.templateCache;
          }
        };
        var defaultWriter = new Writer();
        mustache.clearCache = function clearCache() {
          return defaultWriter.clearCache();
        };
        mustache.parse = function parse3(template, tags) {
          return defaultWriter.parse(template, tags);
        };
        mustache.render = function render(template, view, partials, tags) {
          if (typeof template !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
          }
          return defaultWriter.render(template, view, partials, tags);
        };
        mustache.escape = escapeHtml;
        mustache.Scanner = Scanner;
        mustache.Context = Context;
        mustache.Writer = Writer;
        return mustache;
      }));
    }
  });

  // node-modules-polyfills:buffer
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    SlowBuffer: () => SlowBuffer,
    isBuffer: () => isBuffer2,
    kMaxLength: () => _kMaxLength
  });
  function init2() {
    inited2 = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup2[i] = code[i];
      revLookup2[code.charCodeAt(i)] = i;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited2) {
      init2();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr2(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase642(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  function encodeChunk2(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase642(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited2) {
      init2();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk2(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup2[tmp >> 2];
      output += lookup2[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup2[tmp >> 10];
      output += lookup2[tmp >> 4 & 63];
      output += lookup2[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write2(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  }
  function kMaxLength2() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer2(that, length) {
    if (kMaxLength2() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe2(this, arg);
    }
    return from2(this, arg, encodingOrOffset, length);
  }
  function from2(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer2(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString2(that, value, encodingOrOffset);
    }
    return fromObject2(that, value);
  }
  function assertSize2(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc2(that, size, fill5, encoding) {
    assertSize2(size);
    if (size <= 0) {
      return createBuffer2(that, size);
    }
    if (fill5 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(that, size).fill(fill5, encoding) : createBuffer2(that, size).fill(fill5);
    }
    return createBuffer2(that, size);
  }
  function allocUnsafe2(that, size) {
    assertSize2(size);
    that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString2(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength2(string, encoding) | 0;
    that = createBuffer2(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike2(that, array) {
    var length = array.length < 0 ? 0 : checked2(array.length) | 0;
    that = createBuffer2(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer2(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike2(that, array);
    }
    return that;
  }
  function fromObject2(that, obj) {
    if (internalIsBuffer2(obj)) {
      var len = checked2(obj.length) | 0;
      that = createBuffer2(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan2(obj.length)) {
          return createBuffer2(that, 0);
        }
        return fromArrayLike2(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) {
        return fromArrayLike2(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked2(length) {
    if (length >= kMaxLength2()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  function internalIsBuffer2(b) {
    return !!(b != null && b._isBuffer);
  }
  function byteLength2(string, encoding) {
    if (internalIsBuffer2(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes2(string).length;
        default:
          if (loweredCase) return utf8ToBytes2(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString2(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice2(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end);
        case "ascii":
          return asciiSlice2(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice2(this, start, end);
        case "base64":
          return base64Slice2(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice2(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap2(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (internalIsBuffer2(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  function hexWrite2(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write2(buf, string, offset, length) {
    return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite2(buf, string, offset, length) {
    return blitBuffer2(asciiToBytes2(string), buf, offset, length);
  }
  function latin1Write2(buf, string, offset, length) {
    return asciiWrite2(buf, string, offset, length);
  }
  function base64Write2(buf, string, offset, length) {
    return blitBuffer2(base64ToBytes2(string), buf, offset, length);
  }
  function ucs2Write2(buf, string, offset, length) {
    return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
  }
  function base64Slice2(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice2(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  function decodeCodePointsArray2(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice2(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex2(buf[i]);
    }
    return out;
  }
  function utf16leSlice2(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  function checkOffset2(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt2(buf, value, offset, ext, max7, min7) {
    if (!internalIsBuffer2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max7 || value < min7) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  function objectWriteUInt162(buf, value, offset, littleEndian) {
    if (value < 0) value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  function objectWriteUInt322(buf, value, offset, littleEndian) {
    if (value < 0) value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  function checkIEEE7542(buf, value, offset, ext, max7, min7) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat2(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE7542(buf, value, offset, 4);
    }
    write2(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble2(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE7542(buf, value, offset, 8);
    }
    write2(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean2(str) {
    str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim2(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex2(n) {
    if (n < 16) return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes2(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes2(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes2(str, units) {
    var c, hi2, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes2(str) {
    return toByteArray(base64clean2(str));
  }
  function blitBuffer2(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan2(val) {
    return val !== val;
  }
  function isBuffer2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
  }
  function isFastBuffer2(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer2(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
  }
  var lookup2, revLookup2, Arr2, inited2, toString2, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
  var init_buffer2 = __esm({
    "node-modules-polyfills:buffer"() {
      init_process();
      init_buffer();
      lookup2 = [];
      revLookup2 = [];
      Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited2 = false;
      toString2 = {}.toString;
      isArray = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
      INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      _kMaxLength = kMaxLength2();
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from2(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      Buffer2.alloc = function(size, fill5, encoding) {
        return alloc2(null, size, fill5, encoding);
      };
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe2(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe2(null, size);
      };
      Buffer2.isBuffer = isBuffer2;
      Buffer2.compare = function compare3(a, b) {
        if (!internalIsBuffer2(a) || !internalIsBuffer2(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b) return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding2(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat2(list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer2(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer2.byteLength = byteLength2;
      Buffer2.prototype._isBuffer = true;
      Buffer2.prototype.swap16 = function swap162() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap2(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap322() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap2(this, i, i + 3);
          swap2(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap642() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap2(this, i, i + 7);
          swap2(this, i + 1, i + 6);
          swap2(this, i + 2, i + 5);
          swap2(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString3() {
        var length = this.length | 0;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice2(this, 0, length);
        return slowToString2.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals2(b) {
        if (!internalIsBuffer2(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max7 = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max7).match(/.{2}/g).join(" ");
          if (this.length > max7) str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer2(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
      };
      Buffer2.prototype.write = function write3(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite2(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write2(this, string, offset, length);
            case "ascii":
              return asciiWrite2(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write2(this, string, offset, length);
            case "base64":
              return base64Write2(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write2(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON2() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH2 = 4096;
      Buffer2.prototype.slice = function slice2(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset2(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          checkOffset2(offset, byteLength3, this.length);
        }
        var val = this[offset + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt82(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset2(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) checkOffset2(offset, byteLength3, this.length);
        var i = byteLength3;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt82(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
        if (!noAssert) checkOffset2(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      Buffer2.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt2(this, value, offset, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt2(this, value, offset, byteLength3, maxBytes, 0);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt162(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt162(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt162(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt162(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt322(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) checkInt2(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
        return writeFloat2(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
        return writeFloat2(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
        return writeDouble2(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
        return writeDouble2(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node-modules-polyfills-commonjs:buffer
  var require_buffer = __commonJS({
    "node-modules-polyfills-commonjs:buffer"(exports2, module2) {
      init_process();
      init_buffer();
      var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k in polyfill) {
          module2.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var buffer = require_buffer();
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill5, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill5 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill5, encoding);
          } else {
            buf.fill(fill5);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/@near-js/keystores/node_modules/base-x/index.js
  var require_base_x = __commonJS({
    "node_modules/@near-js/keystores/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-js/keystores/node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/format.js
  var require_format = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs58());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format();
      var error_messages_json_1 = __importDefault(require_error_messages());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors3 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logging.js
  var require_logging = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors3();
      var logger_1 = require_logger2();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/provider.js
  var require_provider2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/depd/lib/browser/index.js
  var require_browser = __commonJS({
    "node_modules/depd/lib/browser/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = depd;
      function depd(namespace) {
        if (!namespace) {
          throw new TypeError("argument namespace is required");
        }
        function deprecate2(message) {
        }
        deprecate2._file = void 0;
        deprecate2._ignored = true;
        deprecate2._namespace = namespace;
        deprecate2._traced = false;
        deprecate2._warned = /* @__PURE__ */ Object.create(null);
        deprecate2.function = wrapfunction;
        deprecate2.property = wrapproperty;
        return deprecate2;
      }
      function wrapfunction(fn, message) {
        if (typeof fn !== "function") {
          throw new TypeError("argument fn must be a function");
        }
        return fn;
      }
      function wrapproperty(obj, prop, message) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new TypeError("argument obj must be object");
        }
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (!descriptor) {
          throw new TypeError("must call property on owner object");
        }
        if (!descriptor.configurable) {
          throw new TypeError("property must be configurable");
        }
      }
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/validators.js
  var require_validators = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants2(), exports2);
      __exportStar(require_errors3(), exports2);
      __exportStar(require_format(), exports2);
      __exportStar(require_logging(), exports2);
      __exportStar(require_provider2(), exports2);
      __exportStar(require_validators(), exports2);
      __exportStar(require_logger2(), exports2);
      __exportStar(require_utils(), exports2);
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/_sha2.js
  var require_sha2 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils2();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/hashes/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha2();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils2();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/utils.js
  var require_utils3 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/modular.js
  var require_modular = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils3();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/curve.js
  var require_curve = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular();
      var ut = require_utils3();
      var utils_js_1 = require_utils3();
      var curve_js_1 = require_curve();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@noble/curves/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha512();
      var utils_1 = require_utils2();
      var edwards_js_1 = require_edwards();
      var montgomery_js_1 = require_montgomery();
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var hash_to_curve_js_1 = require_hash_to_curve();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/randombytes/browser.js
  var require_browser2 = __commonJS({
    "node_modules/randombytes/browser.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var MAX_BYTES = 65536;
      var MAX_UINT32 = 4294967295;
      function oldBrowser() {
        throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
      }
      var Buffer3 = require_safe_buffer().Buffer;
      var crypto2 = globalThis.crypto || globalThis.msCrypto;
      if (crypto2 && crypto2.getRandomValues) {
        module2.exports = randomBytes;
      } else {
        module2.exports = oldBrowser;
      }
      function randomBytes(size, cb) {
        if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
        var bytes = Buffer3.allocUnsafe(size);
        if (size > 0) {
          if (size > MAX_BYTES) {
            for (var generated = 0; generated < size; generated += MAX_BYTES) {
              crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
            }
          } else {
            crypto2.getRandomValues(bytes);
          }
        }
        if (typeof cb === "function") {
          return process.nextTick(function() {
            cb(null, bytes);
          });
        }
        return bytes;
      }
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib();
      var utils_1 = require_lib2();
      var ed25519_1 = require_ed25519();
      var constants_1 = require_constants();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed25519 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib2();
      var ed25519_1 = require_ed25519();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants();
      var key_pair_base_1 = require_key_pair_base();
      var public_key_1 = require_public_key();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base();
      var key_pair_ed25519_1 = require_key_pair_ed25519();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@near-js/keystores/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed25519();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-js/keystores/lib/keystore.js
  var require_keystore = __commonJS({
    "node_modules/@near-js/keystores/lib/keystore.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyStore = void 0;
      var KeyStore = class {
      };
      exports2.KeyStore = KeyStore;
    }
  });

  // node_modules/@near-js/keystores/lib/in_memory_key_store.js
  var require_in_memory_key_store = __commonJS({
    "node_modules/@near-js/keystores/lib/in_memory_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InMemoryKeyStore = void 0;
      var crypto_1 = require_lib3();
      var keystore_1 = require_keystore();
      var InMemoryKeyStore = class extends keystore_1.KeyStore {
        constructor() {
          super();
          this.keys = {};
        }
        /**
         * Stores a {@link KeyPair} in in-memory storage item
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @param keyPair The key pair to store in local storage
         */
        setKey(networkId, accountId, keyPair) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.keys[`${accountId}:${networkId}`] = keyPair.toString();
          });
        }
        /**
         * Gets a {@link KeyPair} from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @returns {Promise<KeyPair>}
         */
        getKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const value = this.keys[`${accountId}:${networkId}`];
            if (!value) {
              return null;
            }
            return crypto_1.KeyPair.fromString(value);
          });
        }
        /**
         * Removes a {@link KeyPair} from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         */
        removeKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            delete this.keys[`${accountId}:${networkId}`];
          });
        }
        /**
         * Removes all {@link KeyPair} from in-memory storage
         */
        clear() {
          return __awaiter6(this, void 0, void 0, function* () {
            this.keys = {};
          });
        }
        /**
         * Get the network(s) from in-memory storage
         * @returns {Promise<string[]>}
         */
        getNetworks() {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = /* @__PURE__ */ new Set();
            Object.keys(this.keys).forEach((key) => {
              const parts = key.split(":");
              result.add(parts[1]);
            });
            return Array.from(result.values());
          });
        }
        /**
         * Gets the account(s) from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         */
        getAccounts(networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = new Array();
            Object.keys(this.keys).forEach((key) => {
              const parts = key.split(":");
              if (parts[parts.length - 1] === networkId) {
                result.push(parts.slice(0, parts.length - 1).join(":"));
              }
            });
            return result;
          });
        }
        /** @hidden */
        toString() {
          return "InMemoryKeyStore";
        }
      };
      exports2.InMemoryKeyStore = InMemoryKeyStore;
    }
  });

  // node_modules/@near-js/keystores/lib/merge_key_store.js
  var require_merge_key_store = __commonJS({
    "node_modules/@near-js/keystores/lib/merge_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MergeKeyStore = void 0;
      var keystore_1 = require_keystore();
      var MergeKeyStore = class extends keystore_1.KeyStore {
        /**
         * @param keyStores read calls are attempted from start to end of array
         * @param options KeyStore options
         * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
         */
        constructor(keyStores3, options = { writeKeyStoreIndex: 0 }) {
          super();
          this.options = options;
          this.keyStores = keyStores3;
        }
        /**
         * Store a {@link KeyPair} to the first index of a key store array
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @param keyPair The key pair to store in local storage
         */
        setKey(networkId, accountId, keyPair) {
          return __awaiter6(this, void 0, void 0, function* () {
            yield this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
          });
        }
        /**
         * Gets a {@link KeyPair} from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @returns {Promise<KeyPair>}
         */
        getKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            for (const keyStore of this.keyStores) {
              const keyPair = yield keyStore.getKey(networkId, accountId);
              if (keyPair) {
                return keyPair;
              }
            }
            return null;
          });
        }
        /**
         * Removes a {@link KeyPair} from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         */
        removeKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            for (const keyStore of this.keyStores) {
              yield keyStore.removeKey(networkId, accountId);
            }
          });
        }
        /**
         * Removes all items from each key store
         */
        clear() {
          return __awaiter6(this, void 0, void 0, function* () {
            for (const keyStore of this.keyStores) {
              yield keyStore.clear();
            }
          });
        }
        /**
         * Get the network(s) from the array of key stores
         * @returns {Promise<string[]>}
         */
        getNetworks() {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = /* @__PURE__ */ new Set();
            for (const keyStore of this.keyStores) {
              for (const network of yield keyStore.getNetworks()) {
                result.add(network);
              }
            }
            return Array.from(result);
          });
        }
        /**
         * Gets the account(s) from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc)
         */
        getAccounts(networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = /* @__PURE__ */ new Set();
            for (const keyStore of this.keyStores) {
              for (const account of yield keyStore.getAccounts(networkId)) {
                result.add(account);
              }
            }
            return Array.from(result);
          });
        }
        /** @hidden */
        toString() {
          return `MergeKeyStore(${this.keyStores.join(", ")})`;
        }
      };
      exports2.MergeKeyStore = MergeKeyStore;
    }
  });

  // node_modules/@near-js/keystores/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@near-js/keystores/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MergeKeyStore = exports2.KeyStore = exports2.InMemoryKeyStore = void 0;
      var in_memory_key_store_1 = require_in_memory_key_store();
      Object.defineProperty(exports2, "InMemoryKeyStore", { enumerable: true, get: function() {
        return in_memory_key_store_1.InMemoryKeyStore;
      } });
      var keystore_1 = require_keystore();
      Object.defineProperty(exports2, "KeyStore", { enumerable: true, get: function() {
        return keystore_1.KeyStore;
      } });
      var merge_key_store_1 = require_merge_key_store();
      Object.defineProperty(exports2, "MergeKeyStore", { enumerable: true, get: function() {
        return merge_key_store_1.MergeKeyStore;
      } });
    }
  });

  // node_modules/near-api-js/lib/key_stores/keystore.js
  var require_keystore2 = __commonJS({
    "node_modules/near-api-js/lib/key_stores/keystore.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyStore = void 0;
      var keystores_1 = require_lib4();
      Object.defineProperty(exports2, "KeyStore", { enumerable: true, get: function() {
        return keystores_1.KeyStore;
      } });
    }
  });

  // node_modules/near-api-js/lib/key_stores/in_memory_key_store.js
  var require_in_memory_key_store2 = __commonJS({
    "node_modules/near-api-js/lib/key_stores/in_memory_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InMemoryKeyStore = void 0;
      var keystores_1 = require_lib4();
      Object.defineProperty(exports2, "InMemoryKeyStore", { enumerable: true, get: function() {
        return keystores_1.InMemoryKeyStore;
      } });
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/constants.js
  var require_constants3 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/constants.js
  var require_constants4 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger3 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger2();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger4 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger3();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors4 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger4();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/assignable.js
  var require_assignable2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/errors.js
  var require_errors5 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/response.js
  var require_response2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/index.js
  var require_provider3 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client2();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response2();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable2(), exports2);
      __exportStar(require_errors5(), exports2);
      __exportStar(require_provider3(), exports2);
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/base-x/index.js
  var require_base_x2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/bs58/index.js
  var require_bs582 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x2();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/format.js
  var require_format2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs582());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib5();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format2();
      var error_messages_json_1 = __importDefault(require_error_messages2());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema2());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors6 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors4();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors2();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logging.js
  var require_logging2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors6();
      var logger_1 = require_logger4();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/provider.js
  var require_provider4 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/utils.js
  var require_utils4 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/validators.js
  var require_validators2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils4();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants4(), exports2);
      __exportStar(require_errors6(), exports2);
      __exportStar(require_format2(), exports2);
      __exportStar(require_logging2(), exports2);
      __exportStar(require_provider4(), exports2);
      __exportStar(require_validators2(), exports2);
      __exportStar(require_logger4(), exports2);
      __exportStar(require_utils4(), exports2);
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_assert.js
  var require_assert2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/crypto.js
  var require_crypto2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/utils.js
  var require_utils5 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto2();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_sha2.js
  var require_sha22 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert2();
      var utils_js_1 = require_utils5();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_u64.js
  var require_u642 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/sha512.js
  var require_sha5122 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha22();
      var _u64_js_1 = require_u642();
      var utils_js_1 = require_utils5();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/utils.js
  var require_utils6 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/modular.js
  var require_modular2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils6();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/curve.js
  var require_curve2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils6();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular2();
      var ut = require_utils6();
      var utils_js_1 = require_utils6();
      var curve_js_1 = require_curve2();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils6();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils6();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@noble/curves/ed25519.js
  var require_ed255192 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha5122();
      var utils_1 = require_utils5();
      var edwards_js_1 = require_edwards2();
      var montgomery_js_1 = require_montgomery2();
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils6();
      var hash_to_curve_js_1 = require_hash_to_curve2();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib5();
      var utils_1 = require_lib6();
      var ed25519_1 = require_ed255192();
      var constants_1 = require_constants3();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed255192 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib6();
      var ed25519_1 = require_ed255192();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants3();
      var key_pair_base_1 = require_key_pair_base2();
      var public_key_1 = require_public_key2();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair2 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base2();
      var key_pair_ed25519_1 = require_key_pair_ed255192();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/@near-js/keystores-browser/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants3();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair2();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255192();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key2();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-js/keystores-browser/lib/browser_local_storage_key_store.js
  var require_browser_local_storage_key_store = __commonJS({
    "node_modules/@near-js/keystores-browser/lib/browser_local_storage_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BrowserLocalStorageKeyStore = void 0;
      var crypto_1 = require_lib7();
      var keystores_1 = require_lib4();
      var LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
      var BrowserLocalStorageKeyStore = class extends keystores_1.KeyStore {
        /**
         * @param localStorage defaults to window.localStorage
         * @param prefix defaults to `near-api-js:keystore:`
         */
        constructor(localStorage2 = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
          super();
          this.localStorage = localStorage2;
          this.prefix = prefix;
        }
        /**
         * Stores a {@link KeyPair} in local storage.
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @param keyPair The key pair to store in local storage
         */
        setKey(networkId, accountId, keyPair) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
          });
        }
        /**
         * Gets a {@link KeyPair} from local storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         * @returns {Promise<KeyPair>}
         */
        getKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
            if (!value) {
              return null;
            }
            return crypto_1.KeyPair.fromString(value);
          });
        }
        /**
         * Removes a {@link KeyPair} from local storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the key pair
         */
        removeKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
          });
        }
        /**
         * Removes all items that start with `prefix` from local storage
         */
        clear() {
          return __awaiter6(this, void 0, void 0, function* () {
            for (const key of this.storageKeys()) {
              if (key.startsWith(this.prefix)) {
                this.localStorage.removeItem(key);
              }
            }
          });
        }
        /**
         * Get the network(s) from local storage
         * @returns {Promise<string[]>}
         */
        getNetworks() {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = /* @__PURE__ */ new Set();
            for (const key of this.storageKeys()) {
              if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(":");
                result.add(parts[1]);
              }
            }
            return Array.from(result.values());
          });
        }
        /**
         * Gets the account(s) from local storage
         * @param networkId The targeted network. (ex. default, betanet, etc)
         */
        getAccounts(networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = new Array();
            for (const key of this.storageKeys()) {
              if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(":");
                if (parts[1] === networkId) {
                  result.push(parts[0]);
                }
              }
            }
            return result;
          });
        }
        /**
         * @hidden
         * Helper function to retrieve a local storage key
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account tied to the storage key that's sought
         * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
         */
        storageKeyForSecretKey(networkId, accountId) {
          return `${this.prefix}${accountId}:${networkId}`;
        }
        /** @hidden */
        *storageKeys() {
          for (let i = 0; i < this.localStorage.length; i++) {
            yield this.localStorage.key(i);
          }
        }
      };
      exports2.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
    }
  });

  // node_modules/@near-js/keystores-browser/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/@near-js/keystores-browser/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BrowserLocalStorageKeyStore = void 0;
      var browser_local_storage_key_store_1 = require_browser_local_storage_key_store();
      Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
        return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
      } });
    }
  });

  // node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js
  var require_browser_local_storage_key_store2 = __commonJS({
    "node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BrowserLocalStorageKeyStore = void 0;
      var keystores_browser_1 = require_lib8();
      Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
        return keystores_browser_1.BrowserLocalStorageKeyStore;
      } });
    }
  });

  // node_modules/near-api-js/lib/key_stores/merge_key_store.js
  var require_merge_key_store2 = __commonJS({
    "node_modules/near-api-js/lib/key_stores/merge_key_store.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MergeKeyStore = void 0;
      var keystores_1 = require_lib4();
      Object.defineProperty(exports2, "MergeKeyStore", { enumerable: true, get: function() {
        return keystores_1.MergeKeyStore;
      } });
    }
  });

  // node_modules/near-api-js/lib/key_stores/browser-index.js
  var require_browser_index = __commonJS({
    "node_modules/near-api-js/lib/key_stores/browser-index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MergeKeyStore = exports2.BrowserLocalStorageKeyStore = exports2.InMemoryKeyStore = exports2.KeyStore = void 0;
      var keystore_1 = require_keystore2();
      Object.defineProperty(exports2, "KeyStore", { enumerable: true, get: function() {
        return keystore_1.KeyStore;
      } });
      var in_memory_key_store_1 = require_in_memory_key_store2();
      Object.defineProperty(exports2, "InMemoryKeyStore", { enumerable: true, get: function() {
        return in_memory_key_store_1.InMemoryKeyStore;
      } });
      var browser_local_storage_key_store_1 = require_browser_local_storage_key_store2();
      Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
        return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
      } });
      var merge_key_store_1 = require_merge_key_store2();
      Object.defineProperty(exports2, "MergeKeyStore", { enumerable: true, get: function() {
        return merge_key_store_1.MergeKeyStore;
      } });
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/constants.js
  var require_constants5 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger5 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger3();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger6 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger5();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors7 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger6();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/assignable.js
  var require_assignable3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/errors.js
  var require_errors8 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/provider/response.js
  var require_response3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/provider/index.js
  var require_provider5 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client3();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response3();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/types/lib/index.js
  var require_lib9 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable3(), exports2);
      __exportStar(require_errors8(), exports2);
      __exportStar(require_provider5(), exports2);
    }
  });

  // node_modules/near-api-js/node_modules/base-x/index.js
  var require_base_x3 = __commonJS({
    "node_modules/near-api-js/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/near-api-js/node_modules/bs58/index.js
  var require_bs583 = __commonJS({
    "node_modules/near-api-js/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x3();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/format.js
  var require_format3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs583());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib9();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format3();
      var error_messages_json_1 = __importDefault(require_error_messages3());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema3());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors9 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors7();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors3();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/logging.js
  var require_logging3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors9();
      var logger_1 = require_logger6();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/provider.js
  var require_provider6 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/utils.js
  var require_utils7 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/validators.js
  var require_validators3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils7();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/utils/lib/index.js
  var require_lib10 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants5(), exports2);
      __exportStar(require_errors9(), exports2);
      __exportStar(require_format3(), exports2);
      __exportStar(require_logging3(), exports2);
      __exportStar(require_provider6(), exports2);
      __exportStar(require_validators3(), exports2);
      __exportStar(require_logger6(), exports2);
      __exportStar(require_utils7(), exports2);
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/exponential-backoff.js
  var require_exponential_backoff = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/exponential-backoff.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.exponentialBackoff = void 0;
      function exponentialBackoff2(startWaitTime, retryNumber, waitBackoff, getResult) {
        return __awaiter6(this, void 0, void 0, function* () {
          let waitTime = startWaitTime;
          for (let i = 0; i < retryNumber; i++) {
            const result = yield getResult();
            if (result) {
              return result;
            }
            yield sleep(waitTime);
            waitTime *= waitBackoff;
          }
          return null;
        });
      }
      exports2.exponentialBackoff = exponentialBackoff2;
      function sleep(millis) {
        return new Promise((resolve5) => setTimeout(resolve5, millis));
      }
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/actions.js
  var require_actions = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/actions.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Action = exports2.SignedDelegate = exports2.DeleteAccount = exports2.DeleteKey = exports2.AddKey = exports2.Stake = exports2.Transfer = exports2.FunctionCall = exports2.DeployContract = exports2.CreateAccount = exports2.IAction = exports2.AccessKey = exports2.AccessKeyPermission = exports2.FullAccessPermission = exports2.FunctionCallPermission = void 0;
      var types_1 = require_lib9();
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
            this.enum = key;
          });
        }
      };
      var FunctionCallPermission = class extends types_1.Assignable {
      };
      exports2.FunctionCallPermission = FunctionCallPermission;
      var FullAccessPermission = class extends types_1.Assignable {
      };
      exports2.FullAccessPermission = FullAccessPermission;
      var AccessKeyPermission = class extends Enum {
      };
      exports2.AccessKeyPermission = AccessKeyPermission;
      var AccessKey = class extends types_1.Assignable {
      };
      exports2.AccessKey = AccessKey;
      var IAction = class extends types_1.Assignable {
      };
      exports2.IAction = IAction;
      var CreateAccount = class extends IAction {
      };
      exports2.CreateAccount = CreateAccount;
      var DeployContract = class extends IAction {
      };
      exports2.DeployContract = DeployContract;
      var FunctionCall = class extends IAction {
      };
      exports2.FunctionCall = FunctionCall;
      var Transfer = class extends IAction {
      };
      exports2.Transfer = Transfer;
      var Stake = class extends IAction {
      };
      exports2.Stake = Stake;
      var AddKey = class extends IAction {
      };
      exports2.AddKey = AddKey;
      var DeleteKey = class extends IAction {
      };
      exports2.DeleteKey = DeleteKey;
      var DeleteAccount = class extends IAction {
      };
      exports2.DeleteAccount = DeleteAccount;
      var SignedDelegate = class extends IAction {
      };
      exports2.SignedDelegate = SignedDelegate;
      var Action = class extends Enum {
      };
      exports2.Action = Action;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/action_creators.js
  var require_action_creators = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/action_creators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.actionCreators = exports2.stringifyJsonOrBytes = void 0;
      var actions_1 = require_actions();
      function fullAccessKey() {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            fullAccess: new actions_1.FullAccessPermission({})
          })
        });
      }
      function functionCallAccessKey(receiverId, methodNames, allowance) {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            functionCall: new actions_1.FunctionCallPermission({
              receiverId,
              allowance,
              methodNames
            })
          })
        });
      }
      function createAccount() {
        return new actions_1.Action({ createAccount: new actions_1.CreateAccount({}) });
      }
      function deployContract(code) {
        return new actions_1.Action({ deployContract: new actions_1.DeployContract({ code }) });
      }
      function stringifyJsonOrBytes(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        return isUint8Array ? args : Buffer.from(JSON.stringify(args));
      }
      exports2.stringifyJsonOrBytes = stringifyJsonOrBytes;
      function functionCall(methodName, args, gas = BigInt(0), deposit = BigInt(0), stringify2 = stringifyJsonOrBytes, jsContract = false) {
        if (jsContract) {
          return new actions_1.Action({
            functionCall: new actions_1.FunctionCall({ methodName, args, gas, deposit })
          });
        }
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({
            methodName,
            args: stringify2(args),
            gas,
            deposit
          })
        });
      }
      function transfer(deposit = BigInt(0)) {
        return new actions_1.Action({ transfer: new actions_1.Transfer({ deposit }) });
      }
      function stake(stake2 = BigInt(0), publicKey) {
        return new actions_1.Action({ stake: new actions_1.Stake({ stake: stake2, publicKey }) });
      }
      function addKey(publicKey, accessKey) {
        return new actions_1.Action({ addKey: new actions_1.AddKey({ publicKey, accessKey }) });
      }
      function deleteKey(publicKey) {
        return new actions_1.Action({ deleteKey: new actions_1.DeleteKey({ publicKey }) });
      }
      function deleteAccount(beneficiaryId) {
        return new actions_1.Action({ deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }) });
      }
      function signedDelegate({ delegateAction, signature }) {
        return new actions_1.Action({
          signedDelegate: new actions_1.SignedDelegate({ delegateAction, signature })
        });
      }
      exports2.actionCreators = {
        addKey,
        createAccount,
        deleteAccount,
        deleteKey,
        deployContract,
        fullAccessKey,
        functionCall,
        functionCallAccessKey,
        signedDelegate,
        stake,
        transfer
      };
    }
  });

  // node_modules/borsh/lib/cjs/types.js
  var require_types = __commonJS({
    "node_modules/borsh/lib/cjs/types.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      exports2.__esModule = true;
      exports2.integers = void 0;
      exports2.integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];
    }
  });

  // node_modules/borsh/lib/cjs/buffer.js
  var require_buffer2 = __commonJS({
    "node_modules/borsh/lib/cjs/buffer.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      exports2.__esModule = true;
      exports2.DecodeBuffer = exports2.EncodeBuffer = void 0;
      var EncodeBuffer = (
        /** @class */
        (function() {
          function EncodeBuffer2() {
            this.offset = 0;
            this.buffer_size = 256;
            this.buffer = new ArrayBuffer(this.buffer_size);
            this.view = new DataView(this.buffer);
          }
          EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
            if (this.buffer_size - this.offset < needed_space) {
              this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
              var new_buffer = new ArrayBuffer(this.buffer_size);
              new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
              this.buffer = new_buffer;
              this.view = new DataView(new_buffer);
            }
          };
          EncodeBuffer2.prototype.get_used_buffer = function() {
            return new Uint8Array(this.buffer).slice(0, this.offset);
          };
          EncodeBuffer2.prototype.store_value = function(value, type) {
            var bSize = type.substring(1);
            var size = parseInt(bSize) / 8;
            this.resize_if_necessary(size);
            var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
            this.view[toCall](this.offset, value, true);
            this.offset += size;
          };
          EncodeBuffer2.prototype.store_bytes = function(from5) {
            this.resize_if_necessary(from5.length);
            new Uint8Array(this.buffer).set(new Uint8Array(from5), this.offset);
            this.offset += from5.length;
          };
          return EncodeBuffer2;
        })()
      );
      exports2.EncodeBuffer = EncodeBuffer;
      var DecodeBuffer = (
        /** @class */
        (function() {
          function DecodeBuffer2(buf) {
            this.offset = 0;
            this.buffer_size = buf.length;
            this.buffer = new ArrayBuffer(buf.length);
            new Uint8Array(this.buffer).set(buf);
            this.view = new DataView(this.buffer);
          }
          DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
            if (this.offset + size > this.buffer.byteLength) {
              throw new Error("Error in schema, the buffer is smaller than expected");
            }
          };
          DecodeBuffer2.prototype.consume_value = function(type) {
            var bSize = type.substring(1);
            var size = parseInt(bSize) / 8;
            this.assert_enough_buffer(size);
            var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
            var ret = this.view[toCall](this.offset, true);
            this.offset += size;
            return ret;
          };
          DecodeBuffer2.prototype.consume_bytes = function(size) {
            this.assert_enough_buffer(size);
            var ret = this.buffer.slice(this.offset, this.offset + size);
            this.offset += size;
            return ret;
          };
          return DecodeBuffer2;
        })()
      );
      exports2.DecodeBuffer = DecodeBuffer;
    }
  });

  // node_modules/borsh/lib/cjs/utils.js
  var require_utils8 = __commonJS({
    "node_modules/borsh/lib/cjs/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      exports2.__esModule = true;
      exports2.validate_schema = exports2.ErrorSchema = exports2.expect_enum = exports2.expect_same_size = exports2.expect_bigint = exports2.expect_type = exports2.isArrayLike = void 0;
      var types_js_1 = require_types();
      function isArrayLike(value) {
        return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
      }
      exports2.isArrayLike = isArrayLike;
      function expect_type(value, type, fieldPath) {
        if (typeof value !== type) {
          throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports2.expect_type = expect_type;
      function expect_bigint(value, fieldPath) {
        var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
        var strObject = typeof value === "object" && value !== null && "toString" in value;
        if (!basicType && !strObject) {
          throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports2.expect_bigint = expect_bigint;
      function expect_same_size(length, expected, fieldPath) {
        if (length !== expected) {
          throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
        }
      }
      exports2.expect_same_size = expect_same_size;
      function expect_enum(value, fieldPath) {
        if (typeof value !== "object" || value === null) {
          throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports2.expect_enum = expect_enum;
      var VALID_STRING_TYPES = types_js_1.integers.concat(["bool", "string"]);
      var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
      var ErrorSchema = (
        /** @class */
        (function(_super) {
          __extends2(ErrorSchema2, _super);
          function ErrorSchema2(schema, expected) {
            var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
            return _super.call(this, message) || this;
          }
          return ErrorSchema2;
        })(Error)
      );
      exports2.ErrorSchema = ErrorSchema;
      function validate_schema(schema) {
        if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
          return;
        }
        if (schema && typeof schema === "object") {
          var keys14 = Object.keys(schema);
          if (keys14.length === 1 && VALID_OBJECT_KEYS.includes(keys14[0])) {
            var key = keys14[0];
            if (key === "option")
              return validate_schema(schema[key]);
            if (key === "enum")
              return validate_enum_schema(schema[key]);
            if (key === "array")
              return validate_array_schema(schema[key]);
            if (key === "set")
              return validate_schema(schema[key]);
            if (key === "map")
              return validate_map_schema(schema[key]);
            if (key === "struct")
              return validate_struct_schema(schema[key]);
          }
        }
        throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
      }
      exports2.validate_schema = validate_schema;
      function validate_enum_schema(schema) {
        if (!Array.isArray(schema))
          throw new ErrorSchema(schema, "Array");
        for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
          var sch = schema_1[_i];
          if (typeof sch !== "object" || !("struct" in sch)) {
            throw new Error('Missing "struct" key in enum schema');
          }
          if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
            throw new Error('The "struct" in each enum must have a single key');
          }
          validate_schema({ struct: sch.struct });
        }
      }
      function validate_array_schema(schema) {
        if (typeof schema !== "object")
          throw new ErrorSchema(schema, "{ type, len? }");
        if (schema.len && typeof schema.len !== "number") {
          throw new Error("Invalid schema: ".concat(schema));
        }
        if ("type" in schema)
          return validate_schema(schema.type);
        throw new ErrorSchema(schema, "{ type, len? }");
      }
      function validate_map_schema(schema) {
        if (typeof schema === "object" && "key" in schema && "value" in schema) {
          validate_schema(schema.key);
          validate_schema(schema.value);
        } else {
          throw new ErrorSchema(schema, "{ key, value }");
        }
      }
      function validate_struct_schema(schema) {
        if (typeof schema !== "object")
          throw new ErrorSchema(schema, "object");
        for (var key in schema) {
          validate_schema(schema[key]);
        }
      }
    }
  });

  // node_modules/borsh/lib/cjs/serialize.js
  var require_serialize = __commonJS({
    "node_modules/borsh/lib/cjs/serialize.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      exports2.__esModule = true;
      exports2.BorshSerializer = void 0;
      var types_js_1 = require_types();
      var buffer_js_1 = require_buffer2();
      var utils5 = __importStar(require_utils8());
      var BorshSerializer = (
        /** @class */
        (function() {
          function BorshSerializer2(checkTypes) {
            this.encoded = new buffer_js_1.EncodeBuffer();
            this.fieldPath = ["value"];
            this.checkTypes = checkTypes;
          }
          BorshSerializer2.prototype.encode = function(value, schema) {
            this.encode_value(value, schema);
            return this.encoded.get_used_buffer();
          };
          BorshSerializer2.prototype.encode_value = function(value, schema) {
            if (typeof schema === "string") {
              if (types_js_1.integers.includes(schema))
                return this.encode_integer(value, schema);
              if (schema === "string")
                return this.encode_string(value);
              if (schema === "bool")
                return this.encode_boolean(value);
            }
            if (typeof schema === "object") {
              if ("option" in schema)
                return this.encode_option(value, schema);
              if ("enum" in schema)
                return this.encode_enum(value, schema);
              if ("array" in schema)
                return this.encode_array(value, schema);
              if ("set" in schema)
                return this.encode_set(value, schema);
              if ("map" in schema)
                return this.encode_map(value, schema);
              if ("struct" in schema)
                return this.encode_struct(value, schema);
            }
          };
          BorshSerializer2.prototype.encode_integer = function(value, schema) {
            var size = parseInt(schema.substring(1));
            if (size <= 32 || schema == "f64") {
              this.checkTypes && utils5.expect_type(value, "number", this.fieldPath);
              this.encoded.store_value(value, schema);
            } else {
              this.checkTypes && utils5.expect_bigint(value, this.fieldPath);
              this.encode_bigint(BigInt(value), size);
            }
          };
          BorshSerializer2.prototype.encode_bigint = function(value, size) {
            var buffer_len = size / 8;
            var buffer = new Uint8Array(buffer_len);
            for (var i = 0; i < buffer_len; i++) {
              buffer[i] = Number(value & BigInt(255));
              value = value >> BigInt(8);
            }
            this.encoded.store_bytes(new Uint8Array(buffer));
          };
          BorshSerializer2.prototype.encode_string = function(value) {
            this.checkTypes && utils5.expect_type(value, "string", this.fieldPath);
            var _value = value;
            this.encoded.store_value(_value.length, "u32");
            for (var i = 0; i < _value.length; i++) {
              this.encoded.store_value(_value.charCodeAt(i), "u8");
            }
          };
          BorshSerializer2.prototype.encode_boolean = function(value) {
            this.checkTypes && utils5.expect_type(value, "boolean", this.fieldPath);
            this.encoded.store_value(value ? 1 : 0, "u8");
          };
          BorshSerializer2.prototype.encode_option = function(value, schema) {
            if (value === null || value === void 0) {
              this.encoded.store_value(0, "u8");
            } else {
              this.encoded.store_value(1, "u8");
              this.encode_value(value, schema.option);
            }
          };
          BorshSerializer2.prototype.encode_enum = function(value, schema) {
            this.checkTypes && utils5.expect_enum(value, this.fieldPath);
            var valueKey = Object.keys(value)[0];
            for (var i = 0; i < schema["enum"].length; i++) {
              var valueSchema = schema["enum"][i];
              if (valueKey === Object.keys(valueSchema.struct)[0]) {
                this.encoded.store_value(i, "u8");
                return this.encode_struct(value, valueSchema);
              }
            }
            throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
          };
          BorshSerializer2.prototype.encode_array = function(value, schema) {
            if (utils5.isArrayLike(value))
              return this.encode_arraylike(value, schema);
            if (value instanceof ArrayBuffer)
              return this.encode_buffer(value, schema);
            throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
          };
          BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
            if (schema.array.len) {
              utils5.expect_same_size(value.length, schema.array.len, this.fieldPath);
            } else {
              this.encoded.store_value(value.length, "u32");
            }
            for (var i = 0; i < value.length; i++) {
              this.encode_value(value[i], schema.array.type);
            }
          };
          BorshSerializer2.prototype.encode_buffer = function(value, schema) {
            if (schema.array.len) {
              utils5.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
            } else {
              this.encoded.store_value(value.byteLength, "u32");
            }
            this.encoded.store_bytes(new Uint8Array(value));
          };
          BorshSerializer2.prototype.encode_set = function(value, schema) {
            this.checkTypes && utils5.expect_type(value, "object", this.fieldPath);
            var isSet = value instanceof Set;
            var values2 = isSet ? Array.from(value.values()) : Object.values(value);
            this.encoded.store_value(values2.length, "u32");
            for (var _i = 0, values_1 = values2; _i < values_1.length; _i++) {
              var value_1 = values_1[_i];
              this.encode_value(value_1, schema.set);
            }
          };
          BorshSerializer2.prototype.encode_map = function(value, schema) {
            this.checkTypes && utils5.expect_type(value, "object", this.fieldPath);
            var isMap = value instanceof Map;
            var keys14 = isMap ? Array.from(value.keys()) : Object.keys(value);
            this.encoded.store_value(keys14.length, "u32");
            for (var _i = 0, keys_1 = keys14; _i < keys_1.length; _i++) {
              var key = keys_1[_i];
              this.encode_value(key, schema.map.key);
              this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
            }
          };
          BorshSerializer2.prototype.encode_struct = function(value, schema) {
            this.checkTypes && utils5.expect_type(value, "object", this.fieldPath);
            for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
              var key = _a[_i];
              this.fieldPath.push(key);
              this.encode_value(value[key], schema.struct[key]);
              this.fieldPath.pop();
            }
          };
          return BorshSerializer2;
        })()
      );
      exports2.BorshSerializer = BorshSerializer;
    }
  });

  // node_modules/borsh/lib/cjs/deserialize.js
  var require_deserialize = __commonJS({
    "node_modules/borsh/lib/cjs/deserialize.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      exports2.__esModule = true;
      exports2.BorshDeserializer = void 0;
      var types_js_1 = require_types();
      var buffer_js_1 = require_buffer2();
      var BorshDeserializer = (
        /** @class */
        (function() {
          function BorshDeserializer2(bufferArray) {
            this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
          }
          BorshDeserializer2.prototype.decode = function(schema) {
            return this.decode_value(schema);
          };
          BorshDeserializer2.prototype.decode_value = function(schema) {
            if (typeof schema === "string") {
              if (types_js_1.integers.includes(schema))
                return this.decode_integer(schema);
              if (schema === "string")
                return this.decode_string();
              if (schema === "bool")
                return this.decode_boolean();
            }
            if (typeof schema === "object") {
              if ("option" in schema)
                return this.decode_option(schema);
              if ("enum" in schema)
                return this.decode_enum(schema);
              if ("array" in schema)
                return this.decode_array(schema);
              if ("set" in schema)
                return this.decode_set(schema);
              if ("map" in schema)
                return this.decode_map(schema);
              if ("struct" in schema)
                return this.decode_struct(schema);
            }
            throw new Error("Unsupported type: ".concat(schema));
          };
          BorshDeserializer2.prototype.decode_integer = function(schema) {
            var size = parseInt(schema.substring(1));
            if (size <= 32 || schema == "f64") {
              return this.buffer.consume_value(schema);
            }
            return this.decode_bigint(size, schema.startsWith("i"));
          };
          BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
            if (signed === void 0) {
              signed = false;
            }
            var buffer_len = size / 8;
            var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
            var bits = buffer.reduceRight(function(r, x) {
              return r + x.toString(16).padStart(2, "0");
            }, "");
            if (signed && buffer[buffer_len - 1]) {
              return BigInt.asIntN(size, BigInt("0x".concat(bits)));
            }
            return BigInt("0x".concat(bits));
          };
          BorshDeserializer2.prototype.decode_string = function() {
            var len = this.decode_integer("u32");
            var buffer = new Uint8Array(this.buffer.consume_bytes(len));
            return String.fromCharCode.apply(null, buffer);
          };
          BorshDeserializer2.prototype.decode_boolean = function() {
            return this.buffer.consume_value("u8") > 0;
          };
          BorshDeserializer2.prototype.decode_option = function(schema) {
            var option = this.buffer.consume_value("u8");
            if (option === 1) {
              return this.decode_value(schema.option);
            }
            if (option !== 0) {
              throw new Error("Invalid option ".concat(option));
            }
            return null;
          };
          BorshDeserializer2.prototype.decode_enum = function(schema) {
            var _a;
            var valueIndex = this.buffer.consume_value("u8");
            if (valueIndex > schema["enum"].length) {
              throw new Error("Enum option ".concat(valueIndex, " is not available"));
            }
            var struct = schema["enum"][valueIndex].struct;
            var key = Object.keys(struct)[0];
            return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
          };
          BorshDeserializer2.prototype.decode_array = function(schema) {
            var result = [];
            var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
            for (var i = 0; i < len; ++i) {
              result.push(this.decode_value(schema.array.type));
            }
            return result;
          };
          BorshDeserializer2.prototype.decode_set = function(schema) {
            var len = this.decode_integer("u32");
            var result = /* @__PURE__ */ new Set();
            for (var i = 0; i < len; ++i) {
              result.add(this.decode_value(schema.set));
            }
            return result;
          };
          BorshDeserializer2.prototype.decode_map = function(schema) {
            var len = this.decode_integer("u32");
            var result = /* @__PURE__ */ new Map();
            for (var i = 0; i < len; ++i) {
              var key = this.decode_value(schema.map.key);
              var value = this.decode_value(schema.map.value);
              result.set(key, value);
            }
            return result;
          };
          BorshDeserializer2.prototype.decode_struct = function(schema) {
            var result = {};
            for (var key in schema.struct) {
              result[key] = this.decode_value(schema.struct[key]);
            }
            return result;
          };
          return BorshDeserializer2;
        })()
      );
      exports2.BorshDeserializer = BorshDeserializer;
    }
  });

  // node_modules/borsh/lib/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/borsh/lib/cjs/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      exports2.__esModule = true;
      exports2.deserialize = exports2.serialize = void 0;
      var serialize_js_1 = require_serialize();
      var deserialize_js_1 = require_deserialize();
      var utils5 = __importStar(require_utils8());
      function serialize3(schema, value, validate) {
        if (validate === void 0) {
          validate = true;
        }
        if (validate)
          utils5.validate_schema(schema);
        var serializer = new serialize_js_1.BorshSerializer(validate);
        return serializer.encode(value, schema);
      }
      exports2.serialize = serialize3;
      function deserialize2(schema, buffer, validate) {
        if (validate === void 0) {
          validate = true;
        }
        if (validate)
          utils5.validate_schema(schema);
        var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
        return deserializer.decode(schema);
      }
      exports2.deserialize = deserialize2;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/prefix.js
  var require_prefix = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/prefix.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DelegateActionPrefix = void 0;
      var types_1 = require_lib9();
      var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
      var NEP = {
        MetaTransactions: 366
      };
      var NEPPrefix = class extends types_1.Assignable {
      };
      var ActionableMessagePrefix = class extends NEPPrefix {
        /** Given the NEP number, set the prefix using 2^30 as the offset **/
        constructor(prefix) {
          super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
        }
      };
      var DelegateActionPrefix = class extends ActionableMessagePrefix {
        constructor() {
          super(NEP.MetaTransactions);
        }
      };
      exports2.DelegateActionPrefix = DelegateActionPrefix;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/schema.js
  var require_schema = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/schema.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SCHEMA = exports2.SignedTransaction = exports2.Transaction = exports2.decodeSignedTransaction = exports2.decodeTransaction = exports2.encodeTransaction = exports2.encodeSignedDelegate = exports2.encodeDelegateAction = void 0;
      var types_1 = require_lib9();
      var borsh_1 = require_cjs();
      var prefix_1 = require_prefix();
      function encodeDelegateAction(delegateAction) {
        return new Uint8Array([
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateActionPrefix, new prefix_1.DelegateActionPrefix()),
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateAction, delegateAction)
        ]);
      }
      exports2.encodeDelegateAction = encodeDelegateAction;
      function encodeSignedDelegate(signedDelegate) {
        return (0, borsh_1.serialize)(exports2.SCHEMA.SignedDelegate, signedDelegate);
      }
      exports2.encodeSignedDelegate = encodeSignedDelegate;
      function encodeTransaction(transaction) {
        const schema = transaction instanceof SignedTransaction ? exports2.SCHEMA.SignedTransaction : exports2.SCHEMA.Transaction;
        return (0, borsh_1.serialize)(schema, transaction);
      }
      exports2.encodeTransaction = encodeTransaction;
      function decodeTransaction(bytes) {
        return new Transaction((0, borsh_1.deserialize)(exports2.SCHEMA.Transaction, bytes));
      }
      exports2.decodeTransaction = decodeTransaction;
      function decodeSignedTransaction(bytes) {
        return new SignedTransaction((0, borsh_1.deserialize)(exports2.SCHEMA.SignedTransaction, bytes));
      }
      exports2.decodeSignedTransaction = decodeSignedTransaction;
      var Transaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeTransaction(bytes);
        }
      };
      exports2.Transaction = Transaction;
      var SignedTransaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeSignedTransaction(bytes);
        }
      };
      exports2.SignedTransaction = SignedTransaction;
      exports2.SCHEMA = new class BorshSchema {
        constructor() {
          this.Signature = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 64 } }
            }
          };
          this.PublicKey = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 32 } }
            }
          };
          this.FunctionCallPermission = {
            struct: {
              allowance: { option: "u128" },
              receiverId: "string",
              methodNames: { array: { type: "string" } }
            }
          };
          this.FullAccessPermission = {
            struct: {}
          };
          this.AccessKeyPermission = {
            enum: [
              { struct: { functionCall: this.FunctionCallPermission } },
              { struct: { fullAccess: this.FullAccessPermission } }
            ]
          };
          this.AccessKey = {
            struct: {
              nonce: "u64",
              permission: this.AccessKeyPermission
            }
          };
          this.CreateAccount = {
            struct: {}
          };
          this.DeployContract = {
            struct: {
              code: { array: { type: "u8" } }
            }
          };
          this.FunctionCall = {
            struct: {
              methodName: "string",
              args: { array: { type: "u8" } },
              gas: "u64",
              deposit: "u128"
            }
          };
          this.Transfer = {
            struct: {
              deposit: "u128"
            }
          };
          this.Stake = {
            struct: {
              stake: "u128",
              publicKey: this.PublicKey
            }
          };
          this.AddKey = {
            struct: {
              publicKey: this.PublicKey,
              accessKey: this.AccessKey
            }
          };
          this.DeleteKey = {
            struct: {
              publicKey: this.PublicKey
            }
          };
          this.DeleteAccount = {
            struct: {
              beneficiaryId: "string"
            }
          };
          this.DelegateActionPrefix = {
            struct: {
              prefix: "u32"
            }
          };
          this.ClassicActions = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } }
            ]
          };
          this.DelegateAction = {
            struct: {
              senderId: "string",
              receiverId: "string",
              actions: { array: { type: this.ClassicActions } },
              nonce: "u64",
              maxBlockHeight: "u64",
              publicKey: this.PublicKey
            }
          };
          this.SignedDelegate = {
            struct: {
              delegateAction: this.DelegateAction,
              signature: this.Signature
            }
          };
          this.Action = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } },
              { struct: { signedDelegate: this.SignedDelegate } }
            ]
          };
          this.Transaction = {
            struct: {
              signerId: "string",
              publicKey: this.PublicKey,
              nonce: "u64",
              receiverId: "string",
              blockHash: { array: { type: "u8", len: 32 } },
              actions: { array: { type: this.Action } }
            }
          };
          this.SignedTransaction = {
            struct: {
              transaction: this.Transaction,
              signature: this.Signature
            }
          };
        }
      }();
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/create_transaction.js
  var require_create_transaction = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/create_transaction.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createTransaction = void 0;
      var schema_1 = require_schema();
      function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
        return new schema_1.Transaction({
          signerId,
          publicKey,
          nonce: txNonce,
          receiverId,
          actions,
          blockHash
        });
      }
      exports2.createTransaction = createTransaction;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/delegate.js
  var require_delegate = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/delegate.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildDelegateAction = exports2.DelegateAction = void 0;
      var types_1 = require_lib9();
      var action_creators_1 = require_action_creators();
      var { addKey, createAccount, deleteAccount, deleteKey, deployContract, functionCall, stake, transfer } = action_creators_1.actionCreators;
      var DelegateAction = class extends types_1.Assignable {
      };
      exports2.DelegateAction = DelegateAction;
      function buildDelegateAction({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
        return new DelegateAction({
          senderId,
          receiverId,
          actions: actions.map((a) => {
            if (!a.type && !a.params) {
              return a;
            }
            switch (a.type) {
              case "AddKey": {
                const { publicKey: publicKey2, accessKey } = a.params;
                return addKey(publicKey2, accessKey);
              }
              case "CreateAccount": {
                return createAccount(a.params.createAccount);
              }
              case "DeleteAccount": {
                return deleteAccount(a.params.deleteAccount);
              }
              case "DeleteKey": {
                return deleteKey(a.params.publicKey);
              }
              case "DeployContract": {
                return deployContract(a.params.code);
              }
              case "FunctionCall": {
                const { methodName, args, gas, deposit } = a.params;
                return functionCall(methodName, args, gas, deposit);
              }
              case "Stake": {
                return stake(a.params.stake, a.params.publicKey);
              }
              case "Transfer": {
                const { deposit } = a.params;
                return transfer(deposit);
              }
            }
            throw new Error("Unrecognized action");
          }),
          nonce,
          maxBlockHeight,
          publicKey
        });
      }
      exports2.buildDelegateAction = buildDelegateAction;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/hashes/_assert.js
  var require_assert3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/hashes/crypto.js
  var require_crypto3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/hashes/utils.js
  var require_utils9 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto3();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!isBytes(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/hashes/_sha2.js
  var require_sha23 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert3();
      var utils_js_1 = require_utils9();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/hashes/sha256.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha224 = exports2.sha256 = void 0;
      var _sha2_js_1 = require_sha23();
      var utils_js_1 = require_utils9();
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/signature.js
  var require_signature = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/signature.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signature = void 0;
      var types_1 = require_lib9();
      var Signature = class extends types_1.Assignable {
      };
      exports2.Signature = Signature;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/sign.js
  var require_sign = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/sign.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signDelegateAction = exports2.signTransaction = void 0;
      var sha256_1 = require_sha256();
      var actions_1 = require_actions();
      var create_transaction_1 = require_create_transaction();
      var schema_1 = require_schema();
      var signature_1 = require_signature();
      function signTransactionObject(transaction, signer, accountId, networkId) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeTransaction)(transaction);
          const hash = new Uint8Array((0, sha256_1.sha256)(message));
          const signature = yield signer.signMessage(message, accountId, networkId);
          const signedTx = new schema_1.SignedTransaction({
            transaction,
            signature: new signature_1.Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })
          });
          return [hash, signedTx];
        });
      }
      function signTransaction(...args) {
        return __awaiter6(this, void 0, void 0, function* () {
          if (args[0].constructor === schema_1.Transaction) {
            const [transaction, signer, accountId, networkId] = args;
            return signTransactionObject(transaction, signer, accountId, networkId);
          } else {
            const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
            const publicKey = yield signer.getPublicKey(accountId, networkId);
            const transaction = (0, create_transaction_1.createTransaction)(accountId, publicKey, receiverId, nonce, actions, blockHash);
            return signTransactionObject(transaction, signer, accountId, networkId);
          }
        });
      }
      exports2.signTransaction = signTransaction;
      function signDelegateAction({ delegateAction, signer }) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeDelegateAction)(delegateAction);
          const signature = yield signer.sign(message);
          const signedDelegateAction = new actions_1.SignedDelegate({
            delegateAction,
            signature: new signature_1.Signature({
              keyType: delegateAction.publicKey.keyType,
              data: signature
            })
          });
          return {
            hash: new Uint8Array((0, sha256_1.sha256)(message)),
            signedDelegateAction
          };
        });
      }
      exports2.signDelegateAction = signDelegateAction;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/transactions/lib/index.js
  var require_lib11 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/transactions/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_action_creators(), exports2);
      __exportStar(require_actions(), exports2);
      __exportStar(require_create_transaction(), exports2);
      __exportStar(require_delegate(), exports2);
      __exportStar(require_schema(), exports2);
      __exportStar(require_sign(), exports2);
      __exportStar(require_signature(), exports2);
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/provider.js
  var require_provider7 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Provider = void 0;
      var Provider2 = class {
      };
      exports2.Provider = Provider2;
    }
  });

  // node_modules/http-errors/node_modules/depd/lib/browser/index.js
  var require_browser3 = __commonJS({
    "node_modules/http-errors/node_modules/depd/lib/browser/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = depd;
      function depd(namespace) {
        if (!namespace) {
          throw new TypeError("argument namespace is required");
        }
        function deprecate2(message) {
        }
        deprecate2._file = void 0;
        deprecate2._ignored = true;
        deprecate2._namespace = namespace;
        deprecate2._traced = false;
        deprecate2._warned = /* @__PURE__ */ Object.create(null);
        deprecate2.function = wrapfunction;
        deprecate2.property = wrapproperty;
        return deprecate2;
      }
      function wrapfunction(fn, message) {
        if (typeof fn !== "function") {
          throw new TypeError("argument fn must be a function");
        }
        return fn;
      }
      function wrapproperty(obj, prop, message) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new TypeError("argument obj must be object");
        }
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (!descriptor) {
          throw new TypeError("must call property on owner object");
        }
        if (!descriptor.configurable) {
          throw new TypeError("property must be configurable");
        }
      }
    }
  });

  // node_modules/setprototypeof/index.js
  var require_setprototypeof = __commonJS({
    "node_modules/setprototypeof/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
      function setProtoOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
      }
      function mixinProperties(obj, proto) {
        for (var prop in proto) {
          if (!obj.hasOwnProperty(prop)) {
            obj[prop] = proto[prop];
          }
        }
        return obj;
      }
    }
  });

  // node_modules/statuses/codes.json
  var require_codes = __commonJS({
    "node_modules/statuses/codes.json"(exports2, module2) {
      module2.exports = {
        "100": "Continue",
        "101": "Switching Protocols",
        "102": "Processing",
        "103": "Early Hints",
        "200": "OK",
        "201": "Created",
        "202": "Accepted",
        "203": "Non-Authoritative Information",
        "204": "No Content",
        "205": "Reset Content",
        "206": "Partial Content",
        "207": "Multi-Status",
        "208": "Already Reported",
        "226": "IM Used",
        "300": "Multiple Choices",
        "301": "Moved Permanently",
        "302": "Found",
        "303": "See Other",
        "304": "Not Modified",
        "305": "Use Proxy",
        "306": "(Unused)",
        "307": "Temporary Redirect",
        "308": "Permanent Redirect",
        "400": "Bad Request",
        "401": "Unauthorized",
        "402": "Payment Required",
        "403": "Forbidden",
        "404": "Not Found",
        "405": "Method Not Allowed",
        "406": "Not Acceptable",
        "407": "Proxy Authentication Required",
        "408": "Request Timeout",
        "409": "Conflict",
        "410": "Gone",
        "411": "Length Required",
        "412": "Precondition Failed",
        "413": "Payload Too Large",
        "414": "URI Too Long",
        "415": "Unsupported Media Type",
        "416": "Range Not Satisfiable",
        "417": "Expectation Failed",
        "418": "I'm a teapot",
        "421": "Misdirected Request",
        "422": "Unprocessable Entity",
        "423": "Locked",
        "424": "Failed Dependency",
        "425": "Unordered Collection",
        "426": "Upgrade Required",
        "428": "Precondition Required",
        "429": "Too Many Requests",
        "431": "Request Header Fields Too Large",
        "451": "Unavailable For Legal Reasons",
        "500": "Internal Server Error",
        "501": "Not Implemented",
        "502": "Bad Gateway",
        "503": "Service Unavailable",
        "504": "Gateway Timeout",
        "505": "HTTP Version Not Supported",
        "506": "Variant Also Negotiates",
        "507": "Insufficient Storage",
        "508": "Loop Detected",
        "509": "Bandwidth Limit Exceeded",
        "510": "Not Extended",
        "511": "Network Authentication Required"
      };
    }
  });

  // node_modules/statuses/index.js
  var require_statuses = __commonJS({
    "node_modules/statuses/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var codes = require_codes();
      module2.exports = status;
      status.STATUS_CODES = codes;
      status.codes = populateStatusesMap(status, codes);
      status.redirect = {
        300: true,
        301: true,
        302: true,
        303: true,
        305: true,
        307: true,
        308: true
      };
      status.empty = {
        204: true,
        205: true,
        304: true
      };
      status.retry = {
        502: true,
        503: true,
        504: true
      };
      function populateStatusesMap(statuses, codes2) {
        var arr = [];
        Object.keys(codes2).forEach(function forEachCode(code) {
          var message = codes2[code];
          var status2 = Number(code);
          statuses[status2] = message;
          statuses[message] = status2;
          statuses[message.toLowerCase()] = status2;
          arr.push(status2);
        });
        return arr;
      }
      function status(code) {
        if (typeof code === "number") {
          if (!status[code]) throw new Error("invalid status code: " + code);
          return code;
        }
        if (typeof code !== "string") {
          throw new TypeError("code must be a number or string");
        }
        var n = parseInt(code, 10);
        if (!isNaN(n)) {
          if (!status[n]) throw new Error("invalid status code: " + n);
          return n;
        }
        n = status[code.toLowerCase()];
        if (!n) throw new Error('invalid status message: "' + code + '"');
        return n;
      }
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module2) {
      init_process();
      init_buffer();
      if (typeof Object.create === "function") {
        module2.exports = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        module2.exports = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }
  });

  // node_modules/toidentifier/index.js
  var require_toidentifier = __commonJS({
    "node_modules/toidentifier/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = toIdentifier;
      function toIdentifier(str) {
        return str.split(" ").map(function(token) {
          return token.slice(0, 1).toUpperCase() + token.slice(1);
        }).join("").replace(/[^ _0-9a-z]/gi, "");
      }
    }
  });

  // node_modules/http-errors/index.js
  var require_http_errors = __commonJS({
    "node_modules/http-errors/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var deprecate2 = require_browser3()("http-errors");
      var setPrototypeOf5 = require_setprototypeof();
      var statuses = require_statuses();
      var inherits2 = require_inherits_browser();
      var toIdentifier = require_toidentifier();
      module2.exports = createError;
      module2.exports.HttpError = createHttpErrorConstructor();
      populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
      function codeClass(status) {
        return Number(String(status).charAt(0) + "00");
      }
      function createError() {
        var err;
        var msg;
        var status = 500;
        var props = {};
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg instanceof Error) {
            err = arg;
            status = err.status || err.statusCode || status;
            continue;
          }
          switch (typeof arg) {
            case "string":
              msg = arg;
              break;
            case "number":
              status = arg;
              if (i !== 0) {
                deprecate2("non-first-argument status code; replace with createError(" + arg + ", ...)");
              }
              break;
            case "object":
              props = arg;
              break;
          }
        }
        if (typeof status === "number" && (status < 400 || status >= 600)) {
          deprecate2("non-error status code; use only 4xx or 5xx status codes");
        }
        if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
          status = 500;
        }
        var HttpError = createError[status] || createError[codeClass(status)];
        if (!err) {
          err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
          Error.captureStackTrace(err, createError);
        }
        if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
          err.expose = status < 500;
          err.status = err.statusCode = status;
        }
        for (var key in props) {
          if (key !== "status" && key !== "statusCode") {
            err[key] = props[key];
          }
        }
        return err;
      }
      function createHttpErrorConstructor() {
        function HttpError() {
          throw new TypeError("cannot construct abstract class");
        }
        inherits2(HttpError, Error);
        return HttpError;
      }
      function createClientErrorConstructor(HttpError, name, code) {
        var className = name.match(/Error$/) ? name : name + "Error";
        function ClientError(message) {
          var msg = message != null ? message : statuses[code];
          var err = new Error(msg);
          Error.captureStackTrace(err, ClientError);
          setPrototypeOf5(err, ClientError.prototype);
          Object.defineProperty(err, "message", {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
          });
          Object.defineProperty(err, "name", {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
          });
          return err;
        }
        inherits2(ClientError, HttpError);
        nameFunc(ClientError, className);
        ClientError.prototype.status = code;
        ClientError.prototype.statusCode = code;
        ClientError.prototype.expose = true;
        return ClientError;
      }
      function createServerErrorConstructor(HttpError, name, code) {
        var className = name.match(/Error$/) ? name : name + "Error";
        function ServerError(message) {
          var msg = message != null ? message : statuses[code];
          var err = new Error(msg);
          Error.captureStackTrace(err, ServerError);
          setPrototypeOf5(err, ServerError.prototype);
          Object.defineProperty(err, "message", {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
          });
          Object.defineProperty(err, "name", {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
          });
          return err;
        }
        inherits2(ServerError, HttpError);
        nameFunc(ServerError, className);
        ServerError.prototype.status = code;
        ServerError.prototype.statusCode = code;
        ServerError.prototype.expose = false;
        return ServerError;
      }
      function nameFunc(func, name) {
        var desc = Object.getOwnPropertyDescriptor(func, "name");
        if (desc && desc.configurable) {
          desc.value = name;
          Object.defineProperty(func, "name", desc);
        }
      }
      function populateConstructorExports(exports3, codes, HttpError) {
        codes.forEach(function forEachCode(code) {
          var CodeError;
          var name = toIdentifier(statuses[code]);
          switch (codeClass(code)) {
            case 400:
              CodeError = createClientErrorConstructor(HttpError, name, code);
              break;
            case 500:
              CodeError = createServerErrorConstructor(HttpError, name, code);
              break;
          }
          if (CodeError) {
            exports3[code] = CodeError;
            exports3[name] = CodeError;
          }
        });
        exports3["I'mateapot"] = deprecate2.function(
          exports3.ImATeapot,
          `"I'mateapot"; use "ImATeapot" instead`
        );
      }
    }
  });

  // node_modules/node-fetch/browser.js
  var require_browser4 = __commonJS({
    "node_modules/node-fetch/browser.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global2 !== "undefined") {
          return global2;
        }
        throw new Error("unable to locate global object");
      };
      var global2 = getGlobal();
      module2.exports = exports2 = global2.fetch;
      if (global2.fetch) {
        exports2.default = global2.fetch.bind(global2);
      }
      exports2.Headers = global2.Headers;
      exports2.Request = global2.Request;
      exports2.Response = global2.Response;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js
  function blobConstructor() {
    if (typeof _blobConstructor !== "undefined") {
      return _blobConstructor;
    }
    try {
      new globalThis.Blob([new ArrayBuffer(1)]);
      _blobConstructor = true;
    } catch (e) {
      _blobConstructor = false;
    }
    return _blobConstructor;
  }
  function checkTypeSupport(type) {
    if (!xhr) {
      xhr = new globalThis.XMLHttpRequest();
      xhr.open("GET", globalThis.location.host ? "/" : "https://example.com");
    }
    try {
      xhr.responseType = type;
      return xhr.responseType === type;
    } catch (e) {
      return false;
    }
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray;
  var init_capability = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js"() {
      init_process();
      init_buffer();
      hasFetch = isFunction(globalThis.fetch) && isFunction(globalThis.ReadableStream);
      haveArrayBuffer = typeof globalThis.ArrayBuffer !== "undefined";
      haveSlice = haveArrayBuffer && isFunction(globalThis.ArrayBuffer.prototype.slice);
      arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer");
      msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream");
      mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
      overrideMimeType = isFunction(xhr.overrideMimeType);
      vbArray = isFunction(globalThis.VBArray);
      xhr = null;
    }
  });

  // node-modules-polyfills:process
  function defaultSetTimout2() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout2() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout2(fun) {
    if (cachedSetTimeout2 === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
      cachedSetTimeout2 = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout2(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout2.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout2.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout2(marker) {
    if (cachedClearTimeout2 === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
      cachedClearTimeout2 = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout2(marker);
    } catch (e) {
      try {
        return cachedClearTimeout2.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout2.call(this, marker);
      }
    }
  }
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout2(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout2(timeout);
  }
  function nextTick2(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout2(drainQueue2);
    }
  }
  function Item2(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop2() {
  }
  function binding2(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd2() {
    return "/";
  }
  function chdir2(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask2() {
    return 0;
  }
  function hrtime2(previousTimestamp) {
    var clocktime = performanceNow2.call(performance3) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime2() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime2;
    return dif / 1e3;
  }
  var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env2, argv2, version2, versions2, release2, config2, on2, addListener2, once2, off2, removeListener2, removeAllListeners2, emit2, performance3, performanceNow2, startTime2, browser$1, process_default;
  var init_process2 = __esm({
    "node-modules-polyfills:process"() {
      init_process();
      init_buffer();
      cachedSetTimeout2 = defaultSetTimout2;
      cachedClearTimeout2 = defaultClearTimeout2;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout2 = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout2 = clearTimeout;
      }
      queue2 = [];
      draining2 = false;
      queueIndex2 = -1;
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title2 = "browser";
      platform2 = "browser";
      browser2 = true;
      env2 = {};
      argv2 = [];
      version2 = "";
      versions2 = {};
      release2 = {};
      config2 = {};
      on2 = noop2;
      addListener2 = noop2;
      once2 = noop2;
      off2 = noop2;
      removeListener2 = noop2;
      removeAllListeners2 = noop2;
      emit2 = noop2;
      performance3 = globalThis.performance || {};
      performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      startTime2 = /* @__PURE__ */ new Date();
      browser$1 = {
        nextTick: nextTick2,
        title: title2,
        browser: browser2,
        env: env2,
        argv: argv2,
        version: version2,
        versions: versions2,
        on: on2,
        addListener: addListener2,
        once: once2,
        off: off2,
        removeListener: removeListener2,
        removeAllListeners: removeAllListeners2,
        emit: emit2,
        binding: binding2,
        cwd: cwd2,
        chdir: chdir2,
        umask: umask2,
        hrtime: hrtime2,
        platform: platform2,
        release: release2,
        config: config2,
        uptime: uptime2
      };
      process_default = browser$1;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
  var inherits, inherits_default;
  var init_inherits = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
      init_process();
      init_buffer();
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      inherits_default = inherits;
    }
  });

  // node-modules-polyfills:util
  var util_exports = {};
  __export(util_exports, {
    _extend: () => _extend,
    debuglog: () => debuglog,
    default: () => util_default,
    deprecate: () => deprecate,
    format: () => format,
    inherits: () => inherits_default,
    inspect: () => inspect2,
    isArray: () => isArray2,
    isBoolean: () => isBoolean,
    isBuffer: () => isBuffer3,
    isDate: () => isDate,
    isError: () => isError,
    isFunction: () => isFunction2,
    isNull: () => isNull,
    isNullOrUndefined: () => isNullOrUndefined,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isSymbol: () => isSymbol,
    isUndefined: () => isUndefined,
    log: () => log
  });
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect2(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%") return "%";
      if (i >= len) return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect2(x);
      }
    }
    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined(globalThis.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process_default.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process_default.throwDeprecation) {
          throw new Error(msg);
        } else if (process_default.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function debuglog(set9) {
    if (isUndefined(debugEnviron))
      debugEnviron = process_default.env.NODE_DEBUG || "";
    set9 = set9.toUpperCase();
    if (!debugs[set9]) {
      if (new RegExp("\\b" + set9 + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set9] = function() {
          var msg = format.apply(null, arguments);
          console.error("%s %d: %s", set9, pid, msg);
        };
      } else {
        debugs[set9] = function() {
        };
      }
    }
    return debugs[set9];
  }
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys14 = Object.keys(value);
    var visibleKeys = arrayToHash(keys14);
    if (ctx.showHidden) {
      keys14 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys14.indexOf("message") >= 0 || keys14.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys14.length === 0) {
      if (isFunction2(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base3 = "", array = false, braces = ["{", "}"];
    if (isArray2(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction2(value)) {
      var n = value.name ? ": " + value.name : "";
      base3 = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
      base3 = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base3 = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base3 = " " + formatError(value);
    }
    if (keys14.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base3 + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys14);
    } else {
      output = keys14.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base3, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys14) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys14.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base3, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf("\n") >= 0) numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base3 === "" ? "" : base3 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base3 + " " + output.join(", ") + " " + braces[1];
  }
  function isArray2(ar2) {
    return Array.isArray(ar2);
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
  }
  function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  function isBuffer3(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  function timestamp() {
    var d = /* @__PURE__ */ new Date();
    var time = [
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  function log() {
    console.log("%s - %s", timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    if (!add || !isObject(add)) return origin;
    var keys14 = Object.keys(add);
    var i = keys14.length;
    while (i--) {
      origin[keys14[i]] = add[keys14[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var formatRegExp, debugs, debugEnviron, months, util_default;
  var init_util = __esm({
    "node-modules-polyfills:util"() {
      init_process();
      init_buffer();
      init_process2();
      init_inherits();
      formatRegExp = /%[sdj%]/g;
      debugs = {};
      inspect2.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect2.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      util_default = {
        inherits: inherits_default,
        _extend,
        log,
        isBuffer: isBuffer3,
        isPrimitive,
        isFunction: isFunction2,
        isError,
        isDate,
        isObject,
        isRegExp,
        isUndefined,
        isSymbol,
        isString,
        isNumber,
        isNullOrUndefined,
        isNull,
        isBoolean,
        isArray: isArray2,
        inspect: inspect2,
        deprecate,
        format,
        debuglog
      };
    }
  });

  // node-modules-polyfills:events
  function EventHandlers() {
  }
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].apply(self2, args);
    }
  }
  function _addListener(target, type, listener5, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener5 !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit(
          "newListener",
          type,
          listener5.listener ? listener5.listener : listener5
        );
        events = target._events;
      }
      existing = events[type];
    }
    if (!existing) {
      existing = events[type] = listener5;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener5, existing] : [existing, listener5];
      } else {
        if (prepend) {
          existing.unshift(listener5);
        } else {
          existing.push(listener5);
        }
      }
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e) {
    typeof console.warn === "function" ? console.warn(e) : console.log(e);
  }
  function _onceWrap(target, type, listener5) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener5.apply(target, arguments);
      }
    }
    g.listener = listener5;
    return g;
  }
  function listenerCount(type) {
    var events = this._events;
    if (events) {
      var evlistener = events[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }
  function arrayClone(arr, i) {
    var copy4 = new Array(i);
    while (i--)
      copy4[i] = arr[i];
    return copy4;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  var domain, events_default;
  var init_events = __esm({
    "node-modules-polyfills:events"() {
      "use strict";
      init_process();
      init_buffer();
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      events_default = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain)) {
            this.domain = domain.active;
          }
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit3(type) {
        var er, handler, len, args, i, events, domain2;
        var needDomainExit = false;
        var doError = type === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          // fast cases
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          // slower
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        if (needDomainExit)
          domain2.exit();
        return true;
      };
      EventEmitter.prototype.addListener = function addListener3(type, listener5) {
        return _addListener(this, type, listener5, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener5) {
        return _addListener(this, type, listener5, true);
      };
      EventEmitter.prototype.once = function once3(type, listener5) {
        if (typeof listener5 !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type, _onceWrap(this, type, listener5));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener5) {
        if (typeof listener5 !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener5));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener3(type, listener5) {
        var list, events, position, i, originalListener;
        if (typeof listener5 !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener5 || list.listener && list.listener === listener5) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener5);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener5 || list[i].listener && list[i].listener === listener5) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type, originalListener || listener5);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners3(type) {
        var listeners2, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys14 = Object.keys(events);
          for (var i = 0, key; i < keys14.length; ++i) {
            key = keys14[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners2 = events[type];
        if (typeof listeners2 === "function") {
          this.removeListener(type, listeners2);
        } else if (listeners2) {
          do {
            this.removeListener(type, listeners2[listeners2.length - 1]);
          } while (listeners2[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  var buffer_list_default;
  var init_buffer_list = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
      init_process();
      init_buffer();
      init_buffer2();
      buffer_list_default = BufferList;
      BufferList.prototype.push = function(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        if (this.length === 1) return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
    }
  });

  // node-modules-polyfills:string_decoder
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer2(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  var isBufferEncoding;
  var init_string_decoder = __esm({
    "node-modules-polyfills:string_decoder"() {
      init_process();
      init_buffer();
      init_buffer2();
      isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
      return emitter.prependListener(event, fn);
    } else {
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options, stream) {
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new buffer_list_default();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === "function") this._read = options.read;
    events_default.call(this);
  }
  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit("error", er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error("stream.push() after EOF");
        stream.emit("error", e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront) state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);
            else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }
        }
        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      if (state.flowing && state.length) return state.buffer.head.data.length;
      else return state.length;
    }
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick2(emitReadable_, stream);
      else emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick2(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else len = state.length;
    }
    state.readingMore = false;
  }
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners("data").length) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick2(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  function fromList(n, state) {
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder) ret = state.buffer.join("");
      else if (state.buffer.length === 1) ret = state.buffer.head.data;
      else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick2(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }
  function indexOf3(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  var debug, MAX_HWM;
  var init_readable = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
      "use strict";
      init_process();
      init_buffer();
      init_events();
      init_util();
      init_buffer_list();
      init_string_decoder();
      init_duplex();
      init_process2();
      Readable.ReadableState = ReadableState;
      debug = debuglog("stream");
      inherits_default(Readable, events_default);
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      MAX_HWM = 8388608;
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0) state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted) nextTick2(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount2(dest, "error") === 0) dest.emit("error", er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf3(state.pipes, dest);
        if (i === -1) return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = events_default.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false) this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick2(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this, state);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = /* @__PURE__ */ (function(method2) {
              return function() {
                return stream[method2].apply(stream, arguments);
              };
            })(i);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug("wrapped _read", n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
  function nop() {
  }
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  function WritableState(options, stream) {
    Object.defineProperty(this, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  function Writable(options) {
    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
    }
    EventEmitter.call(this);
  }
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    nextTick2(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      nextTick2(cb, er);
      valid = false;
    }
    return valid;
  }
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer2.isBuffer(chunk)) encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
      var last5 = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last5) {
        last5.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick2(cb, er);
    else cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit("error", er);
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        nextTick2(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) {
          break;
        }
      }
      if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit("finish");
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) nextTick2(cb);
      else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }
  var init_writable = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
      init_process();
      init_buffer();
      init_util();
      init_buffer2();
      init_events();
      init_duplex();
      init_process2();
      Writable.WritableState = WritableState;
      inherits_default(Writable, EventEmitter);
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk)) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ended) writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished) endWritable(this, state, cb);
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    nextTick2(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  var keys, method2, v;
  var init_duplex = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
      init_process();
      init_buffer();
      init_util();
      init_process2();
      init_readable();
      init_writable();
      inherits_default(Duplex, Readable);
      keys = Object.keys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method2 = keys[v];
        if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
      }
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
  function TransformState(stream) {
    this.afterTransform = function(er, data7) {
      return afterTransform(stream, er, data7);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  function afterTransform(stream, er, data7) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) return stream.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data7 !== null && data7 !== void 0) stream.push(data7);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function") this._flush(function(er) {
        done(stream, er);
      });
      else done(stream);
    });
  }
  function done(stream, er) {
    if (er) return stream.emit("error", er);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length) throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  var init_transform = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
      init_process();
      init_buffer();
      init_duplex();
      init_util();
      inherits_default(Transform, Duplex);
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  var init_passthrough = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
      init_process();
      init_buffer();
      init_transform();
      init_util();
      inherits_default(PassThrough, Transform);
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node-modules-polyfills:stream
  function Stream() {
    events_default.call(this);
  }
  var init_stream = __esm({
    "node-modules-polyfills:stream"() {
      init_process();
      init_buffer();
      init_events();
      init_util();
      init_duplex();
      init_readable();
      init_writable();
      init_transform();
      init_passthrough();
      inherits_default(Stream, events_default);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (events_default.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js
  function IncomingMessage(xhr2, response, mode) {
    var self2 = this;
    Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process.nextTick(function() {
        self2.emit("close");
      });
    });
    var read2;
    if (mode === "fetch") {
      self2._fetchResponse = response;
      self2.url = response.url;
      self2.statusCode = response.status;
      self2.statusMessage = response.statusText;
      for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done; ) {
        self2.headers[header[0].toLowerCase()] = header[1];
        self2.rawHeaders.push(header[0], header[1]);
      }
      var reader = response.body.getReader();
      read2 = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(new Buffer(result.value));
          read2();
        });
      };
      read2();
    } else {
      self2._xhr = xhr2;
      self2._pos = 0;
      self2.url = xhr2.responseURL;
      self2.statusCode = xhr2.status;
      self2.statusMessage = xhr2.statusText;
      var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header2) {
        var matches = header2.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === "set-cookie") {
            if (self2.headers[key] === void 0) {
              self2.headers[key] = [];
            }
            self2.headers[key].push(matches[2]);
          } else if (self2.headers[key] !== void 0) {
            self2.headers[key] += ", " + matches[2];
          } else {
            self2.headers[key] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  }
  var rStates;
  var init_response = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js"() {
      init_process();
      init_buffer();
      init_capability();
      init_util();
      init_stream();
      rStates = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
      };
      inherits_default(IncomingMessage, Readable);
      IncomingMessage.prototype._read = function() {
      };
      IncomingMessage.prototype._onXHRProgress = function() {
        var self2 = this;
        var xhr2 = self2._xhr;
        var response = null;
        switch (self2._mode) {
          case "text:vbarray":
            if (xhr2.readyState !== rStates.DONE)
              break;
            try {
              response = new globalThis.VBArray(xhr2.responseBody).toArray();
            } catch (e) {
            }
            if (response !== null) {
              self2.push(new Buffer(response));
              break;
            }
          // Falls through in IE8
          case "text":
            try {
              response = xhr2.responseText;
            } catch (e) {
              self2._mode = "text:vbarray";
              break;
            }
            if (response.length > self2._pos) {
              var newData = response.substr(self2._pos);
              if (self2._charset === "x-user-defined") {
                var buffer = new Buffer(newData.length);
                for (var i = 0; i < newData.length; i++)
                  buffer[i] = newData.charCodeAt(i) & 255;
                self2.push(buffer);
              } else {
                self2.push(newData, self2._charset);
              }
              self2._pos = response.length;
            }
            break;
          case "arraybuffer":
            if (xhr2.readyState !== rStates.DONE || !xhr2.response)
              break;
            response = xhr2.response;
            self2.push(new Buffer(new Uint8Array(response)));
            break;
          case "moz-chunked-arraybuffer":
            response = xhr2.response;
            if (xhr2.readyState !== rStates.LOADING || !response)
              break;
            self2.push(new Buffer(new Uint8Array(response)));
            break;
          case "ms-stream":
            response = xhr2.response;
            if (xhr2.readyState !== rStates.LOADING)
              break;
            var reader = new globalThis.MSStreamReader();
            reader.onprogress = function() {
              if (reader.result.byteLength > self2._pos) {
                self2.push(new Buffer(new Uint8Array(reader.result.slice(self2._pos))));
                self2._pos = reader.result.byteLength;
              }
            };
            reader.onload = function() {
              self2.push(null);
            };
            reader.readAsArrayBuffer(response);
            break;
        }
        if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
          self2.push(null);
        }
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js
  function to_arraybuffer_default(buf) {
    if (buf instanceof Uint8Array) {
      if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      } else if (typeof buf.buffer.slice === "function") {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      }
    }
    if (isBuffer2(buf)) {
      var arrayCopy = new Uint8Array(buf.length);
      var len = buf.length;
      for (var i = 0; i < len; i++) {
        arrayCopy[i] = buf[i];
      }
      return arrayCopy.buffer;
    } else {
      throw new Error("Argument must be a Buffer");
    }
  }
  var init_to_arraybuffer = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js"() {
      init_process();
      init_buffer();
      init_buffer2();
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js
  function decideMode(preferBinary, useFetch) {
    if (hasFetch && useFetch) {
      return "fetch";
    } else if (mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (msstream) {
      return "ms-stream";
    } else if (arraybuffer && preferBinary) {
      return "arraybuffer";
    } else if (vbArray && preferBinary) {
      return "text:vbarray";
    } else {
      return "text";
    }
  }
  function ClientRequest(opts) {
    var self2 = this;
    Writable.call(self2);
    self2._opts = opts;
    self2._body = [];
    self2._headers = {};
    if (opts.auth)
      self2.setHeader("Authorization", "Basic " + new Buffer(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
      self2.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch") {
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts.mode === "allow-wrong-content-type") {
      preferBinary = !overrideMimeType;
    } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2.on("finish", function() {
      self2._onFinish();
    });
  }
  function statusValid(xhr2) {
    try {
      var status = xhr2.status;
      return status !== null && status !== 0;
    } catch (e) {
      return false;
    }
  }
  var request_default, unsafeHeaders;
  var init_request = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js"() {
      init_process();
      init_buffer();
      init_capability();
      init_util();
      init_response();
      init_stream();
      init_to_arraybuffer();
      request_default = ClientRequest;
      inherits_default(ClientRequest, Writable);
      unsafeHeaders = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "cookie",
        "cookie2",
        "date",
        "dnt",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "user-agent",
        "via"
      ];
      ClientRequest.prototype.setHeader = function(name, value) {
        var self2 = this;
        var lowerName = name.toLowerCase();
        if (unsafeHeaders.indexOf(lowerName) !== -1)
          return;
        self2._headers[lowerName] = {
          name,
          value
        };
      };
      ClientRequest.prototype.getHeader = function(name) {
        var self2 = this;
        return self2._headers[name.toLowerCase()].value;
      };
      ClientRequest.prototype.removeHeader = function(name) {
        var self2 = this;
        delete self2._headers[name.toLowerCase()];
      };
      ClientRequest.prototype._onFinish = function() {
        var self2 = this;
        if (self2._destroyed)
          return;
        var opts = self2._opts;
        var headersObj = self2._headers;
        var body;
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          if (blobConstructor()) {
            body = new globalThis.Blob(self2._body.map(function(buffer) {
              return to_arraybuffer_default(buffer);
            }), {
              type: (headersObj["content-type"] || {}).value || ""
            });
          } else {
            body = Buffer.concat(self2._body).toString();
          }
        }
        if (self2._mode === "fetch") {
          var headers = Object.keys(headersObj).map(function(name) {
            return [headersObj[name].name, headersObj[name].value];
          });
          globalThis.fetch(self2._opts.url, {
            method: self2._opts.method,
            headers,
            body,
            mode: "cors",
            credentials: opts.withCredentials ? "include" : "same-origin"
          }).then(function(response) {
            self2._fetchResponse = response;
            self2._connect();
          }, function(reason) {
            self2.emit("error", reason);
          });
        } else {
          var xhr2 = self2._xhr = new globalThis.XMLHttpRequest();
          try {
            xhr2.open(self2._opts.method, self2._opts.url, true);
          } catch (err) {
            process.nextTick(function() {
              self2.emit("error", err);
            });
            return;
          }
          if ("responseType" in xhr2)
            xhr2.responseType = self2._mode.split(":")[0];
          if ("withCredentials" in xhr2)
            xhr2.withCredentials = !!opts.withCredentials;
          if (self2._mode === "text" && "overrideMimeType" in xhr2)
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          Object.keys(headersObj).forEach(function(name) {
            xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value);
          });
          self2._response = null;
          xhr2.onreadystatechange = function() {
            switch (xhr2.readyState) {
              case rStates.LOADING:
              case rStates.DONE:
                self2._onXHRProgress();
                break;
            }
          };
          if (self2._mode === "moz-chunked-arraybuffer") {
            xhr2.onprogress = function() {
              self2._onXHRProgress();
            };
          }
          xhr2.onerror = function() {
            if (self2._destroyed)
              return;
            self2.emit("error", new Error("XHR error"));
          };
          try {
            xhr2.send(body);
          } catch (err) {
            process.nextTick(function() {
              self2.emit("error", err);
            });
            return;
          }
        }
      };
      ClientRequest.prototype._onXHRProgress = function() {
        var self2 = this;
        if (!statusValid(self2._xhr) || self2._destroyed)
          return;
        if (!self2._response)
          self2._connect();
        self2._response._onXHRProgress();
      };
      ClientRequest.prototype._connect = function() {
        var self2 = this;
        if (self2._destroyed)
          return;
        self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode);
        self2.emit("response", self2._response);
      };
      ClientRequest.prototype._write = function(chunk, encoding, cb) {
        var self2 = this;
        self2._body.push(chunk);
        cb();
      };
      ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
        var self2 = this;
        self2._destroyed = true;
        if (self2._response)
          self2._response._destroyed = true;
        if (self2._xhr)
          self2._xhr.abort();
      };
      ClientRequest.prototype.end = function(data7, encoding, cb) {
        var self2 = this;
        if (typeof data7 === "function") {
          cb = data7;
          data7 = void 0;
        }
        Writable.prototype.end.call(self2, data7, encoding, cb);
      };
      ClientRequest.prototype.flushHeaders = function() {
      };
      ClientRequest.prototype.setTimeout = function() {
      };
      ClientRequest.prototype.setNoDelay = function() {
      };
      ClientRequest.prototype.setSocketKeepAlive = function() {
      };
    }
  });

  // node-modules-polyfills:punycode
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }
  function mapDomain(string, fn) {
    var parts = string.split("@");
    var result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      string = parts[1];
    }
    string = string.replace(regexSeparators, ".");
    var labels = string.split(".");
    var encoded = map(labels, fn).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    var output = [], counter5 = 0, length = string.length, value, extra;
    while (counter5 < length) {
      value = string.charCodeAt(counter5++);
      if (value >= 55296 && value <= 56319 && counter5 < length) {
        extra = string.charCodeAt(counter5++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter5--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  function digitToBasic(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  function encode(input) {
    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
    input = ucs2decode(input);
    inputLength = input.length;
    n = initialN;
    delta = 0;
    bias = initialBias;
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    handledCPCount = basicLength = output.length;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue == n) {
          for (q = delta, k = base; ; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(
              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
            );
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  }
  function toASCII(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  }
  var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode;
  var init_punycode = __esm({
    "node-modules-polyfills:punycode"() {
      init_process();
      init_buffer();
      maxInt = 2147483647;
      base = 36;
      tMin = 1;
      tMax = 26;
      skew = 38;
      damp = 700;
      initialBias = 72;
      initialN = 128;
      delimiter = "-";
      regexNonASCII = /[^\x20-\x7E]/;
      regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      baseMinusTMin = base - tMin;
      floor = Math.floor;
      stringFromCharCode = String.fromCharCode;
    }
  });

  // node-modules-polyfills:querystring
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function stringifyPrimitive(v) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  }
  function stringify(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return map2(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray3(obj[k])) {
          return map2(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name) return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  }
  function map2(xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }
  function parse(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty2(obj, k)) {
        obj[k] = v;
      } else if (isArray3(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  }
  var isArray3, objectKeys;
  var init_querystring = __esm({
    "node-modules-polyfills:querystring"() {
      init_process();
      init_buffer();
      isArray3 = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
      objectKeys = Object.keys || function(obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
        }
        return res;
      };
    }
  });

  // node-modules-polyfills:url
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url) return url;
    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  function parse2(self2, url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        self2.path = rest;
        self2.href = rest;
        self2.pathname = simplePath[1];
        if (simplePath[2]) {
          self2.search = simplePath[2];
          if (parseQueryString) {
            self2.query = parse(self2.search.substr(1));
          } else {
            self2.query = self2.search.substr(1);
          }
        } else if (parseQueryString) {
          self2.search = "";
          self2.query = {};
        }
        return self2;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      self2.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        self2.slashes = true;
      }
    }
    var i, hec, l, p;
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        self2.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      self2.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      parseHost(self2);
      self2.hostname = self2.hostname || "";
      var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = self2.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              self2.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (self2.hostname.length > hostnameMaxLen) {
        self2.hostname = "";
      } else {
        self2.hostname = self2.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        self2.hostname = toASCII(self2.hostname);
      }
      p = self2.port ? ":" + self2.port : "";
      var h = self2.hostname || "";
      self2.host = h + p;
      self2.href += self2.host;
      if (ipv6Hostname) {
        self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      self2.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      self2.search = rest.substr(qm);
      self2.query = rest.substr(qm + 1);
      if (parseQueryString) {
        self2.query = parse(self2.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      self2.search = "";
      self2.query = {};
    }
    if (rest) self2.pathname = rest;
    if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
      self2.pathname = "/";
    }
    if (self2.pathname || self2.search) {
      p = self2.pathname || "";
      var s = self2.search || "";
      self2.path = p + s;
    }
    self2.href = format2(self2);
    return self2;
  }
  function format2(self2) {
    var auth = self2.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
    if (self2.host) {
      host = auth + self2.host;
    } else if (self2.hostname) {
      host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
      if (self2.port) {
        host += ":" + self2.port;
      }
    }
    if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
      query = stringify(self2.query);
    }
    var search = self2.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") protocol += ":";
    if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
    if (search && search.charAt(0) !== "?") search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match5) {
      return encodeURIComponent(match5);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  }
  function parseHost(self2) {
    var host = self2.host;
    var port5 = portPattern.exec(host);
    if (port5) {
      port5 = port5[0];
      if (port5 !== ":") {
        self2.port = port5.substr(1);
      }
      host = host.substr(0, host.length - port5.length);
    }
    if (host) self2.hostname = host;
  }
  var protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
  var init_url = __esm({
    "node-modules-polyfills:url"() {
      init_process();
      init_buffer();
      init_punycode();
      init_util();
      init_querystring();
      protocolPattern = /^([a-z0-9.+-]+:)/i;
      portPattern = /:[0-9]*$/;
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
      unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
      autoEscape = ["'"].concat(unwise);
      nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
      hostEndingChars = ["/", "?", "#"];
      hostnameMaxLen = 255;
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      unsafeProtocol = {
        "javascript": true,
        "javascript:": true
      };
      hostlessProtocol = {
        "javascript": true,
        "javascript:": true
      };
      slashedProtocol = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
        return parse2(this, url, parseQueryString, slashesDenoteHost);
      };
      Url.prototype.format = function() {
        return format2(this);
      };
      Url.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };
      Url.prototype.resolveObject = function(relative) {
        if (isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result[rkey] = relative[rkey];
          }
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        var relPath;
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol[relative.protocol]) {
            var keys14 = Object.keys(relative);
            for (var v = 0; v < keys14.length; v++) {
              var k = keys14[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift())) ;
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
        relPath = relative.pathname && relative.pathname.split("/") || [];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "") relPath[0] = relative.host;
              else relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        var authInHost;
        if (isRelAbs) {
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath) srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!isNullOrUndefined(relative.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last5 = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last5 === "." || last5 === "..") || last5 === "";
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last5 = srcPath[i];
          if (last5 === ".") {
            srcPath.splice(i, 1);
          } else if (last5 === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        return parseHost(this);
      };
    }
  });

  // node-modules-polyfills:http
  var http_exports = {};
  __export(http_exports, {
    Agent: () => Agent,
    METHODS: () => METHODS,
    STATUS_CODES: () => STATUS_CODES,
    default: () => http_default,
    get: () => get,
    request: () => request
  });
  function request(opts, cb) {
    if (typeof opts === "string")
      opts = urlParse(opts);
    var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port5 = opts.port;
    var path7 = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port5 ? ":" + port5 : "") + path7;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new request_default(opts);
    if (cb)
      req.on("response", cb);
    return req;
  }
  function get(opts, cb) {
    var req = request(opts, cb);
    req.end();
    return req;
  }
  function Agent() {
  }
  var METHODS, STATUS_CODES, http_default;
  var init_http = __esm({
    "node-modules-polyfills:http"() {
      init_process();
      init_buffer();
      init_request();
      init_url();
      Agent.defaultMaxSockets = 4;
      METHODS = [
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LOCK",
        "M-SEARCH",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MOVE",
        "NOTIFY",
        "OPTIONS",
        "PATCH",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PURGE",
        "PUT",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNLOCK",
        "UNSUBSCRIBE"
      ];
      STATUS_CODES = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        // RFC 2518, obsoleted by RFC 4918
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        // RFC 4918
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Time-out",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Large",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        // RFC 2324
        422: "Unprocessable Entity",
        // RFC 4918
        423: "Locked",
        // RFC 4918
        424: "Failed Dependency",
        // RFC 4918
        425: "Unordered Collection",
        // RFC 4918
        426: "Upgrade Required",
        // RFC 2817
        428: "Precondition Required",
        // RFC 6585
        429: "Too Many Requests",
        // RFC 6585
        431: "Request Header Fields Too Large",
        // RFC 6585
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Time-out",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        // RFC 2295
        507: "Insufficient Storage",
        // RFC 4918
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        // RFC 2774
        511: "Network Authentication Required"
        // RFC 6585
      };
      http_default = {
        request,
        get,
        Agent,
        METHODS,
        STATUS_CODES
      };
    }
  });

  // node-modules-polyfills-commonjs:http
  var require_http = __commonJS({
    "node-modules-polyfills-commonjs:http"(exports2, module2) {
      init_process();
      init_buffer();
      var polyfill = (init_http(), __toCommonJS(http_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k in polyfill) {
          module2.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:https
  var https_exports = {};
  __export(https_exports, {
    Agent: () => Agent2,
    METHODS: () => METHODS2,
    STATUS_CODES: () => STATUS_CODES2,
    default: () => https_default,
    get: () => get2,
    request: () => request2
  });
  function request2(opts, cb) {
    if (typeof opts === "string")
      opts = urlParse(opts);
    var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port5 = opts.port;
    var path7 = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port5 ? ":" + port5 : "") + path7;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new request_default(opts);
    if (cb)
      req.on("response", cb);
    return req;
  }
  function get2(opts, cb) {
    var req = request2(opts, cb);
    req.end();
    return req;
  }
  function Agent2() {
  }
  var METHODS2, STATUS_CODES2, https_default;
  var init_https = __esm({
    "node-modules-polyfills:https"() {
      init_process();
      init_buffer();
      init_request();
      init_url();
      Agent2.defaultMaxSockets = 4;
      METHODS2 = [
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LOCK",
        "M-SEARCH",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MOVE",
        "NOTIFY",
        "OPTIONS",
        "PATCH",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PURGE",
        "PUT",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNLOCK",
        "UNSUBSCRIBE"
      ];
      STATUS_CODES2 = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        // RFC 2518, obsoleted by RFC 4918
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        // RFC 4918
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Time-out",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Large",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        // RFC 2324
        422: "Unprocessable Entity",
        // RFC 4918
        423: "Locked",
        // RFC 4918
        424: "Failed Dependency",
        // RFC 4918
        425: "Unordered Collection",
        // RFC 4918
        426: "Upgrade Required",
        // RFC 2817
        428: "Precondition Required",
        // RFC 6585
        429: "Too Many Requests",
        // RFC 6585
        431: "Request Header Fields Too Large",
        // RFC 6585
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Time-out",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        // RFC 2295
        507: "Insufficient Storage",
        // RFC 4918
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        // RFC 2774
        511: "Network Authentication Required"
        // RFC 6585
      };
      https_default = {
        request: request2,
        get: get2,
        Agent: Agent2,
        METHODS: METHODS2,
        STATUS_CODES: STATUS_CODES2
      };
    }
  });

  // node-modules-polyfills-commonjs:https
  var require_https = __commonJS({
    "node-modules-polyfills-commonjs:https"(exports2, module2) {
      init_process();
      init_buffer();
      var polyfill = (init_https(), __toCommonJS(https_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k in polyfill) {
          module2.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/fetch.js
  var require_fetch = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/fetch.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var node_fetch_1 = __importDefault(require_browser4());
      var http_1 = __importDefault(require_http());
      var https_1 = __importDefault(require_https());
      var httpAgent = new http_1.default.Agent({ keepAlive: true });
      var httpsAgent = new https_1.default.Agent({ keepAlive: true });
      function agent(_parsedURL) {
        if (_parsedURL.protocol === "http:") {
          return httpAgent;
        } else {
          return httpsAgent;
        }
      }
      function default_1(resource, init3) {
        return (0, node_fetch_1.default)(resource, Object.assign({ agent: agent(new URL(resource.toString())) }, init3));
      }
      exports2.default = default_1;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/fetch_json.js
  var require_fetch_json = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/fetch_json.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fetchJson = void 0;
      var types_1 = require_lib9();
      var utils_1 = require_lib10();
      var http_errors_1 = __importDefault(require_http_errors());
      var exponential_backoff_1 = require_exponential_backoff();
      var START_WAIT_TIME_MS = 1e3;
      var BACKOFF_MULTIPLIER = 1.5;
      var RETRY_NUMBER = 10;
      function fetchJson(connectionInfoOrUrl, json) {
        return __awaiter6(this, void 0, void 0, function* () {
          let connectionInfo = { url: null };
          if (typeof connectionInfoOrUrl === "string") {
            connectionInfo.url = connectionInfoOrUrl;
          } else {
            connectionInfo = connectionInfoOrUrl;
          }
          const response = yield (0, exponential_backoff_1.exponentialBackoff)(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, () => __awaiter6(this, void 0, void 0, function* () {
            var _a;
            try {
              const response2 = yield ((_a = globalThis.fetch) !== null && _a !== void 0 ? _a : (yield Promise.resolve().then(() => __importStar(require_fetch()))).default)(connectionInfo.url, {
                method: json ? "POST" : "GET",
                body: json ? json : void 0,
                headers: Object.assign(Object.assign({}, connectionInfo.headers), { "Content-Type": "application/json" })
              });
              if (!response2.ok) {
                if (response2.status === 503) {
                  utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);
                  return null;
                } else if (response2.status === 408) {
                  utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} as the previous connection was unused for some time`);
                  return null;
                }
                throw (0, http_errors_1.default)(response2.status, yield response2.text());
              }
              return response2;
            } catch (error2) {
              if (error2.toString().includes("FetchError") || error2.toString().includes("Failed to fetch")) {
                utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error2}`);
                return null;
              }
              throw error2;
            }
          }));
          if (!response) {
            throw new types_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, "RetriesExceeded");
          }
          return yield response.json();
        });
      }
      exports2.fetchJson = fetchJson;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/json-rpc-provider.js
  var require_json_rpc_provider = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/json-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonRpcProvider = void 0;
      var utils_1 = require_lib10();
      var types_1 = require_lib9();
      var transactions_1 = require_lib11();
      var exponential_backoff_1 = require_exponential_backoff();
      var provider_1 = require_provider7();
      var fetch_json_1 = require_fetch_json();
      var REQUEST_RETRY_NUMBER = 12;
      var REQUEST_RETRY_WAIT = 500;
      var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
      var _nextId = 123;
      var JsonRpcProvider3 = class extends provider_1.Provider {
        /**
         * @param connectionInfo Connection info
         */
        constructor(connectionInfo, options) {
          super();
          this.connection = connectionInfo || { url: "" };
          const defaultOptions = {
            retries: REQUEST_RETRY_NUMBER,
            wait: REQUEST_RETRY_WAIT,
            backoff: REQUEST_RETRY_WAIT_BACKOFF
          };
          this.options = Object.assign({}, defaultOptions, options);
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        status() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("status", []);
          });
        }
        /**
         * Sends a signed transaction to the RPC
         *
         * @param signedTransaction The signed transaction being sent
         * @param waitUntil
         */
        sendTransactionUntil(signedTransaction, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            const bytes = (0, transactions_1.encodeTransaction)(signedTransaction);
            return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes).toString("base64"), wait_until: waitUntil });
          });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        sendTransaction(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
          });
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        sendTransactionAsync(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendTransactionUntil(signedTransaction, "NONE");
          });
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         */
        txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof txHash === "string") {
              return this.txStatusString(txHash, accountId, waitUntil);
            } else {
              return this.txStatusUint8Array(txHash, accountId, waitUntil);
            }
          });
        }
        txStatusUint8Array(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("tx", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
          });
        }
        txStatusString(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
          });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         * @returns {Promise<FinalExecutionOutcome>}
         */
        txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof txHash === "string") {
              return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
            } else {
              return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
            }
          });
        }
        /**
         * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
         * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
         *
         * @typeParam T the shape of the returned query response
         */
        query(...args) {
          return __awaiter6(this, void 0, void 0, function* () {
            let result;
            if (args.length === 1) {
              const _a = args[0], { block_id, blockId } = _a, otherParams = __rest(_a, ["block_id", "blockId"]);
              result = yield this.sendJsonRpc("query", Object.assign(Object.assign({}, otherParams), { block_id: block_id || blockId }));
            } else {
              const [path7, data7] = args;
              result = yield this.sendJsonRpc("query", [path7, data7]);
            }
            if (result && result.error) {
              throw new types_1.TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, (0, utils_1.getErrorTypeFromErrorMessage)(result.error, result.error.name));
            }
            return result;
          });
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        block(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("block", { block_id: blockId, finality });
          });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        blockChanges(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
          });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        chunk(chunkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("chunk", [chunkId]);
          });
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        validators(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("validators", [blockId]);
          });
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        experimental_protocolConfig(blockReference) {
          return __awaiter6(this, void 0, void 0, function* () {
            const _a = blockReference, { blockId } = _a, otherParams = __rest(_a, ["blockId"]);
            return yield this.sendJsonRpc("EXPERIMENTAL_protocol_config", Object.assign(Object.assign({}, otherParams), { block_id: blockId }));
          });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        lightClientProof(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request3);
          });
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        nextLightClientBlock(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("next_light_client_block", request3);
          });
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        accessKeyChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "all_access_key_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "single_access_key_changes",
              keys: accessKeyArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        accountChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "account_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "data_changes",
              account_ids: accountIdArray,
              key_prefix_base64: keyPrefix,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractCodeChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "contract_code_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        gasPrice(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("gas_price", [blockId]);
          });
        }
        /**
         * Directly call the RPC specifying the method and params
         *
         * @param method RPC method
         * @param params Parameters to the method
         */
        sendJsonRpc(method2, params) {
          return __awaiter6(this, void 0, void 0, function* () {
            const response = yield (0, exponential_backoff_1.exponentialBackoff)(this.options.wait, this.options.retries, this.options.backoff, () => __awaiter6(this, void 0, void 0, function* () {
              var _a;
              try {
                const request3 = {
                  method: method2,
                  params,
                  id: _nextId++,
                  jsonrpc: "2.0"
                };
                const response2 = yield (0, fetch_json_1.fetchJson)(this.connection, JSON.stringify(request3));
                if (response2.error) {
                  if (typeof response2.error.data === "object") {
                    if (typeof response2.error.data.error_message === "string" && typeof response2.error.data.error_type === "string") {
                      throw new types_1.TypedError(response2.error.data.error_message, response2.error.data.error_type);
                    }
                    throw (0, utils_1.parseRpcError)(response2.error.data);
                  } else {
                    const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
                    if (response2.error.data === "Timeout" || errorMessage.includes("Timeout error") || errorMessage.includes("query has timed out")) {
                      throw new types_1.TypedError(errorMessage, "TimeoutError");
                    }
                    const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.error.data, "");
                    if (errorType) {
                      throw new types_1.TypedError((0, utils_1.formatError)(errorType, params), errorType);
                    }
                    throw new types_1.TypedError(errorMessage, response2.error.name);
                  }
                } else if (typeof ((_a = response2.result) === null || _a === void 0 ? void 0 : _a.error) === "string") {
                  const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.result.error, "");
                  if (errorType) {
                    throw new utils_1.ServerError((0, utils_1.formatError)(errorType, params), errorType);
                  }
                }
                return response2;
              } catch (error2) {
                if (error2.type === "TimeoutError") {
                  utils_1.Logger.warn(`Retrying request to ${method2} as it has timed out`, params);
                  return null;
                }
                throw error2;
              }
            }));
            const { result } = response;
            if (typeof result === "undefined") {
              throw new types_1.TypedError(`Exceeded ${this.options.retries} attempts for request to ${method2}.`, "RetriesExceeded");
            }
            return result;
          });
        }
      };
      exports2.JsonRpcProvider = JsonRpcProvider3;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/failover-rpc-provider.js
  var require_failover_rpc_provider = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/failover-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FailoverRpcProvider = void 0;
      var utils_1 = require_lib10();
      var types_1 = require_lib9();
      var provider_1 = require_provider7();
      var FailoverRpcProvider2 = class extends provider_1.Provider {
        /**
         * @param providers list of providers
         */
        constructor(providers4) {
          super();
          if (providers4.length === 0) {
            throw new Error("At least one provider must be specified");
          }
          this.providers = providers4;
          this.currentProviderIndex = 0;
        }
        switchToNextProvider() {
          if (this.providers.length === 1)
            return;
          if (this.providers.length - 1 <= this.currentProviderIndex) {
            this.currentProviderIndex = 0;
          } else {
            this.currentProviderIndex += 1;
          }
          utils_1.Logger.debug(`Switched to provider at the index ${this.currentProviderIndex}`);
        }
        get currentProvider() {
          const provider = this.providers[this.currentProviderIndex];
          if (!provider)
            throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
          return provider;
        }
        withBackoff(getResult) {
          return __awaiter6(this, void 0, void 0, function* () {
            for (let i = 0; i < this.providers.length; i++) {
              try {
                const result = yield getResult(this.currentProvider);
                if (result)
                  return result;
              } catch (_a) {
                this.switchToNextProvider();
              }
            }
            throw new types_1.TypedError(`Exceeded ${this.providers.length} providers to execute request`, "RetriesExceeded");
          });
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        status() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.status());
          });
        }
        sendTransactionUntil(signedTransaction, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
          });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        sendTransaction(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
          });
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        sendTransactionAsync(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
          });
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         */
        txStatus(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil));
          });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @returns {Promise<FinalExecutionOutcome>}
         */
        txStatusReceipts(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil));
          });
        }
        query(paramsOrPath, data7) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (data7) {
              return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath, data7));
            }
            return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath));
          });
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        block(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
          });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        blockChanges(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
          });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        chunk(chunkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
          });
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        validators(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
          });
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        experimental_protocolConfig(blockReference) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
          });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        lightClientProof(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request3));
          });
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        nextLightClientBlock(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request3));
          });
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        accessKeyChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        accountChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractCodeChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        gasPrice(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
          });
        }
      };
      exports2.FailoverRpcProvider = FailoverRpcProvider2;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/providers/lib/index.js
  var require_lib12 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/providers/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fetchJson = exports2.Provider = exports2.FailoverRpcProvider = exports2.JsonRpcProvider = exports2.exponentialBackoff = void 0;
      var exponential_backoff_1 = require_exponential_backoff();
      Object.defineProperty(exports2, "exponentialBackoff", { enumerable: true, get: function() {
        return exponential_backoff_1.exponentialBackoff;
      } });
      var json_rpc_provider_1 = require_json_rpc_provider();
      Object.defineProperty(exports2, "JsonRpcProvider", { enumerable: true, get: function() {
        return json_rpc_provider_1.JsonRpcProvider;
      } });
      var failover_rpc_provider_1 = require_failover_rpc_provider();
      Object.defineProperty(exports2, "FailoverRpcProvider", { enumerable: true, get: function() {
        return failover_rpc_provider_1.FailoverRpcProvider;
      } });
      var provider_1 = require_provider7();
      Object.defineProperty(exports2, "Provider", { enumerable: true, get: function() {
        return provider_1.Provider;
      } });
      var fetch_json_1 = require_fetch_json();
      Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
        return fetch_json_1.fetchJson;
      } });
    }
  });

  // node_modules/near-api-js/lib/providers/provider.js
  var require_provider8 = __commonJS({
    "node_modules/near-api-js/lib/providers/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = exports2.Provider = exports2.getTransactionLastResult = void 0;
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "getTransactionLastResult", { enumerable: true, get: function() {
        return utils_1.getTransactionLastResult;
      } });
      var providers_1 = require_lib12();
      Object.defineProperty(exports2, "Provider", { enumerable: true, get: function() {
        return providers_1.Provider;
      } });
      var types_1 = require_lib9();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return types_1.IdType;
      } });
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return types_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return types_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/near-api-js/lib/providers/json-rpc-provider.js
  var require_json_rpc_provider2 = __commonJS({
    "node_modules/near-api-js/lib/providers/json-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonRpcProvider = exports2.TypedError = exports2.ErrorContext = void 0;
      var types_1 = require_lib9();
      Object.defineProperty(exports2, "ErrorContext", { enumerable: true, get: function() {
        return types_1.ErrorContext;
      } });
      Object.defineProperty(exports2, "TypedError", { enumerable: true, get: function() {
        return types_1.TypedError;
      } });
      var providers_1 = require_lib12();
      Object.defineProperty(exports2, "JsonRpcProvider", { enumerable: true, get: function() {
        return providers_1.JsonRpcProvider;
      } });
    }
  });

  // node_modules/near-api-js/lib/providers/failover-rpc-provider.js
  var require_failover_rpc_provider2 = __commonJS({
    "node_modules/near-api-js/lib/providers/failover-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FailoverRpcProvider = void 0;
      var providers_1 = require_lib12();
      Object.defineProperty(exports2, "FailoverRpcProvider", { enumerable: true, get: function() {
        return providers_1.FailoverRpcProvider;
      } });
    }
  });

  // node_modules/near-api-js/lib/providers/index.js
  var require_providers = __commonJS({
    "node_modules/near-api-js/lib/providers/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.getTransactionLastResult = exports2.FinalExecutionStatusBasic = exports2.FailoverRpcProvider = exports2.JsonRpcProvider = exports2.Provider = void 0;
      var provider_1 = require_provider8();
      Object.defineProperty(exports2, "Provider", { enumerable: true, get: function() {
        return provider_1.Provider;
      } });
      Object.defineProperty(exports2, "getTransactionLastResult", { enumerable: true, get: function() {
        return provider_1.getTransactionLastResult;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return provider_1.FinalExecutionStatusBasic;
      } });
      var json_rpc_provider_1 = require_json_rpc_provider2();
      Object.defineProperty(exports2, "JsonRpcProvider", { enumerable: true, get: function() {
        return json_rpc_provider_1.JsonRpcProvider;
      } });
      Object.defineProperty(exports2, "TypedError", { enumerable: true, get: function() {
        return json_rpc_provider_1.TypedError;
      } });
      Object.defineProperty(exports2, "ErrorContext", { enumerable: true, get: function() {
        return json_rpc_provider_1.ErrorContext;
      } });
      var failover_rpc_provider_1 = require_failover_rpc_provider2();
      Object.defineProperty(exports2, "FailoverRpcProvider", { enumerable: true, get: function() {
        return failover_rpc_provider_1.FailoverRpcProvider;
      } });
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/constants.js
  var require_constants6 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
  var require_assert4 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
  var require_crypto4 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
  var require_utils10 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto4();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
  var require_sha24 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert4();
      var utils_js_1 = require_utils10();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js
  var require_u643 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js
  var require_sha5123 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha24();
      var _u64_js_1 = require_u643();
      var utils_js_1 = require_utils10();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/utils.js
  var require_utils11 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/modular.js
  var require_modular3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils11();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/curve.js
  var require_curve3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular3();
      var utils_js_1 = require_utils11();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular3();
      var ut = require_utils11();
      var utils_js_1 = require_utils11();
      var curve_js_1 = require_curve3();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular3();
      var utils_js_1 = require_utils11();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve3 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular3();
      var utils_js_1 = require_utils11();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/near-api-js/node_modules/@noble/curves/ed25519.js
  var require_ed255193 = __commonJS({
    "node_modules/near-api-js/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha5123();
      var utils_1 = require_utils10();
      var edwards_js_1 = require_edwards3();
      var montgomery_js_1 = require_montgomery3();
      var modular_js_1 = require_modular3();
      var utils_js_1 = require_utils11();
      var hash_to_curve_js_1 = require_hash_to_curve3();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib9();
      var utils_1 = require_lib10();
      var ed25519_1 = require_ed255193();
      var constants_1 = require_constants6();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed255193 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib10();
      var ed25519_1 = require_ed255193();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants6();
      var key_pair_base_1 = require_key_pair_base3();
      var public_key_1 = require_public_key3();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair3 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base3();
      var key_pair_ed25519_1 = require_key_pair_ed255193();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/near-api-js/node_modules/@near-js/crypto/lib/index.js
  var require_lib13 = __commonJS({
    "node_modules/near-api-js/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants6();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair3();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255193();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key3();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/key_pair.js
  var require_key_pair4 = __commonJS({
    "node_modules/near-api-js/lib/utils/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyType = exports2.KeyPairEd25519 = exports2.KeyPair = void 0;
      var crypto_1 = require_lib13();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return crypto_1.KeyPair;
      } });
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return crypto_1.KeyPairEd25519;
      } });
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return crypto_1.KeyType;
      } });
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return crypto_1.PublicKey;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/serialize.js
  var require_serialize2 = __commonJS({
    "node_modules/near-api-js/lib/utils/serialize.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.base_decode = exports2.base_encode = exports2.deserialize = exports2.serialize = void 0;
      var borsh_1 = require_cjs();
      Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
        return borsh_1.serialize;
      } });
      Object.defineProperty(exports2, "deserialize", { enumerable: true, get: function() {
        return borsh_1.deserialize;
      } });
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "base_encode", { enumerable: true, get: function() {
        return utils_1.baseEncode;
      } });
      Object.defineProperty(exports2, "base_decode", { enumerable: true, get: function() {
        return utils_1.baseDecode;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/web.js
  var require_web = __commonJS({
    "node_modules/near-api-js/lib/utils/web.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fetchJson = void 0;
      var providers_1 = require_lib12();
      Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
        return providers_1.fetchJson;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/enums.js
  var require_enums = __commonJS({
    "node_modules/near-api-js/lib/utils/enums.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Enum = exports2.Assignable = void 0;
      var types_1 = require_lib9();
      Object.defineProperty(exports2, "Assignable", { enumerable: true, get: function() {
        return types_1.Assignable;
      } });
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
            this.enum = key;
          });
        }
      };
      exports2.Enum = Enum;
    }
  });

  // node_modules/near-api-js/lib/utils/format.js
  var require_format4 = __commonJS({
    "node_modules/near-api-js/lib/utils/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION_EXP = exports2.NEAR_NOMINATION = void 0;
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "NEAR_NOMINATION", { enumerable: true, get: function() {
        return utils_1.NEAR_NOMINATION;
      } });
      Object.defineProperty(exports2, "NEAR_NOMINATION_EXP", { enumerable: true, get: function() {
        return utils_1.NEAR_NOMINATION_EXP;
      } });
      Object.defineProperty(exports2, "formatNearAmount", { enumerable: true, get: function() {
        return utils_1.formatNearAmount;
      } });
      Object.defineProperty(exports2, "parseNearAmount", { enumerable: true, get: function() {
        return utils_1.parseNearAmount;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/rpc_errors.js
  var require_rpc_errors4 = __commonJS({
    "node_modules/near-api-js/lib/utils/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ServerError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = void 0;
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return utils_1.parseRpcError;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return utils_1.parseResultError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return utils_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return utils_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return utils_1.ServerError;
      } });
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/constants.js
  var require_constants7 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/constants.js
  var require_constants8 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger7 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger4();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger8 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger7();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors10 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger8();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/assignable.js
  var require_assignable4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/errors.js
  var require_errors11 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/response.js
  var require_response4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/index.js
  var require_provider9 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client4();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response4();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/types/lib/index.js
  var require_lib14 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable4(), exports2);
      __exportStar(require_errors11(), exports2);
      __exportStar(require_provider9(), exports2);
    }
  });

  // node_modules/@near-js/accounts/node_modules/base-x/index.js
  var require_base_x4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-js/accounts/node_modules/bs58/index.js
  var require_bs584 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x4();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/format.js
  var require_format5 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs584());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors5 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib14();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format5();
      var error_messages_json_1 = __importDefault(require_error_messages4());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema4());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors12 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors10();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors5();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logging.js
  var require_logging4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors12();
      var logger_1 = require_logger8();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/provider.js
  var require_provider10 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/utils.js
  var require_utils12 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/validators.js
  var require_validators4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils12();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/index.js
  var require_lib15 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants8(), exports2);
      __exportStar(require_errors12(), exports2);
      __exportStar(require_format5(), exports2);
      __exportStar(require_logging4(), exports2);
      __exportStar(require_provider10(), exports2);
      __exportStar(require_validators4(), exports2);
      __exportStar(require_logger8(), exports2);
      __exportStar(require_utils12(), exports2);
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
  var require_assert5 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
  var require_crypto5 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
  var require_utils13 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto5();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
  var require_sha25 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert5();
      var utils_js_1 = require_utils13();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js
  var require_u644 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js
  var require_sha5124 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha25();
      var _u64_js_1 = require_u644();
      var utils_js_1 = require_utils13();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/utils.js
  var require_utils14 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/modular.js
  var require_modular4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils14();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/curve.js
  var require_curve4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular4();
      var utils_js_1 = require_utils14();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular4();
      var ut = require_utils14();
      var utils_js_1 = require_utils14();
      var curve_js_1 = require_curve4();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular4();
      var utils_js_1 = require_utils14();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular4();
      var utils_js_1 = require_utils14();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/curves/ed25519.js
  var require_ed255194 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha5124();
      var utils_1 = require_utils13();
      var edwards_js_1 = require_edwards4();
      var montgomery_js_1 = require_montgomery4();
      var modular_js_1 = require_modular4();
      var utils_js_1 = require_utils14();
      var hash_to_curve_js_1 = require_hash_to_curve4();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key4 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib14();
      var utils_1 = require_lib15();
      var ed25519_1 = require_ed255194();
      var constants_1 = require_constants7();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed255194 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib15();
      var ed25519_1 = require_ed255194();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants7();
      var key_pair_base_1 = require_key_pair_base4();
      var public_key_1 = require_public_key4();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair5 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base4();
      var key_pair_ed25519_1 = require_key_pair_ed255194();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/index.js
  var require_lib16 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants7();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair5();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255194();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key4();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/exponential-backoff.js
  var require_exponential_backoff2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/exponential-backoff.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.exponentialBackoff = void 0;
      function exponentialBackoff2(startWaitTime, retryNumber, waitBackoff, getResult) {
        return __awaiter6(this, void 0, void 0, function* () {
          let waitTime = startWaitTime;
          for (let i = 0; i < retryNumber; i++) {
            const result = yield getResult();
            if (result) {
              return result;
            }
            yield sleep(waitTime);
            waitTime *= waitBackoff;
          }
          return null;
        });
      }
      exports2.exponentialBackoff = exponentialBackoff2;
      function sleep(millis) {
        return new Promise((resolve5) => setTimeout(resolve5, millis));
      }
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/actions.js
  var require_actions2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/actions.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Action = exports2.SignedDelegate = exports2.DeleteAccount = exports2.DeleteKey = exports2.AddKey = exports2.Stake = exports2.Transfer = exports2.FunctionCall = exports2.DeployContract = exports2.CreateAccount = exports2.IAction = exports2.AccessKey = exports2.AccessKeyPermission = exports2.FullAccessPermission = exports2.FunctionCallPermission = void 0;
      var types_1 = require_lib14();
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
            this.enum = key;
          });
        }
      };
      var FunctionCallPermission = class extends types_1.Assignable {
      };
      exports2.FunctionCallPermission = FunctionCallPermission;
      var FullAccessPermission = class extends types_1.Assignable {
      };
      exports2.FullAccessPermission = FullAccessPermission;
      var AccessKeyPermission = class extends Enum {
      };
      exports2.AccessKeyPermission = AccessKeyPermission;
      var AccessKey = class extends types_1.Assignable {
      };
      exports2.AccessKey = AccessKey;
      var IAction = class extends types_1.Assignable {
      };
      exports2.IAction = IAction;
      var CreateAccount = class extends IAction {
      };
      exports2.CreateAccount = CreateAccount;
      var DeployContract = class extends IAction {
      };
      exports2.DeployContract = DeployContract;
      var FunctionCall = class extends IAction {
      };
      exports2.FunctionCall = FunctionCall;
      var Transfer = class extends IAction {
      };
      exports2.Transfer = Transfer;
      var Stake = class extends IAction {
      };
      exports2.Stake = Stake;
      var AddKey = class extends IAction {
      };
      exports2.AddKey = AddKey;
      var DeleteKey = class extends IAction {
      };
      exports2.DeleteKey = DeleteKey;
      var DeleteAccount = class extends IAction {
      };
      exports2.DeleteAccount = DeleteAccount;
      var SignedDelegate = class extends IAction {
      };
      exports2.SignedDelegate = SignedDelegate;
      var Action = class extends Enum {
      };
      exports2.Action = Action;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/action_creators.js
  var require_action_creators2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/action_creators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.actionCreators = exports2.stringifyJsonOrBytes = void 0;
      var actions_1 = require_actions2();
      function fullAccessKey() {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            fullAccess: new actions_1.FullAccessPermission({})
          })
        });
      }
      function functionCallAccessKey(receiverId, methodNames, allowance) {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            functionCall: new actions_1.FunctionCallPermission({
              receiverId,
              allowance,
              methodNames
            })
          })
        });
      }
      function createAccount() {
        return new actions_1.Action({ createAccount: new actions_1.CreateAccount({}) });
      }
      function deployContract(code) {
        return new actions_1.Action({ deployContract: new actions_1.DeployContract({ code }) });
      }
      function stringifyJsonOrBytes(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        return isUint8Array ? args : Buffer.from(JSON.stringify(args));
      }
      exports2.stringifyJsonOrBytes = stringifyJsonOrBytes;
      function functionCall(methodName, args, gas = BigInt(0), deposit = BigInt(0), stringify2 = stringifyJsonOrBytes, jsContract = false) {
        if (jsContract) {
          return new actions_1.Action({
            functionCall: new actions_1.FunctionCall({ methodName, args, gas, deposit })
          });
        }
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({
            methodName,
            args: stringify2(args),
            gas,
            deposit
          })
        });
      }
      function transfer(deposit = BigInt(0)) {
        return new actions_1.Action({ transfer: new actions_1.Transfer({ deposit }) });
      }
      function stake(stake2 = BigInt(0), publicKey) {
        return new actions_1.Action({ stake: new actions_1.Stake({ stake: stake2, publicKey }) });
      }
      function addKey(publicKey, accessKey) {
        return new actions_1.Action({ addKey: new actions_1.AddKey({ publicKey, accessKey }) });
      }
      function deleteKey(publicKey) {
        return new actions_1.Action({ deleteKey: new actions_1.DeleteKey({ publicKey }) });
      }
      function deleteAccount(beneficiaryId) {
        return new actions_1.Action({ deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }) });
      }
      function signedDelegate({ delegateAction, signature }) {
        return new actions_1.Action({
          signedDelegate: new actions_1.SignedDelegate({ delegateAction, signature })
        });
      }
      exports2.actionCreators = {
        addKey,
        createAccount,
        deleteAccount,
        deleteKey,
        deployContract,
        fullAccessKey,
        functionCall,
        functionCallAccessKey,
        signedDelegate,
        stake,
        transfer
      };
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/prefix.js
  var require_prefix2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/prefix.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DelegateActionPrefix = void 0;
      var types_1 = require_lib14();
      var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
      var NEP = {
        MetaTransactions: 366
      };
      var NEPPrefix = class extends types_1.Assignable {
      };
      var ActionableMessagePrefix = class extends NEPPrefix {
        /** Given the NEP number, set the prefix using 2^30 as the offset **/
        constructor(prefix) {
          super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
        }
      };
      var DelegateActionPrefix = class extends ActionableMessagePrefix {
        constructor() {
          super(NEP.MetaTransactions);
        }
      };
      exports2.DelegateActionPrefix = DelegateActionPrefix;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/schema.js
  var require_schema2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/schema.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SCHEMA = exports2.SignedTransaction = exports2.Transaction = exports2.decodeSignedTransaction = exports2.decodeTransaction = exports2.encodeTransaction = exports2.encodeSignedDelegate = exports2.encodeDelegateAction = void 0;
      var types_1 = require_lib14();
      var borsh_1 = require_cjs();
      var prefix_1 = require_prefix2();
      function encodeDelegateAction(delegateAction) {
        return new Uint8Array([
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateActionPrefix, new prefix_1.DelegateActionPrefix()),
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateAction, delegateAction)
        ]);
      }
      exports2.encodeDelegateAction = encodeDelegateAction;
      function encodeSignedDelegate(signedDelegate) {
        return (0, borsh_1.serialize)(exports2.SCHEMA.SignedDelegate, signedDelegate);
      }
      exports2.encodeSignedDelegate = encodeSignedDelegate;
      function encodeTransaction(transaction) {
        const schema = transaction instanceof SignedTransaction ? exports2.SCHEMA.SignedTransaction : exports2.SCHEMA.Transaction;
        return (0, borsh_1.serialize)(schema, transaction);
      }
      exports2.encodeTransaction = encodeTransaction;
      function decodeTransaction(bytes) {
        return new Transaction((0, borsh_1.deserialize)(exports2.SCHEMA.Transaction, bytes));
      }
      exports2.decodeTransaction = decodeTransaction;
      function decodeSignedTransaction(bytes) {
        return new SignedTransaction((0, borsh_1.deserialize)(exports2.SCHEMA.SignedTransaction, bytes));
      }
      exports2.decodeSignedTransaction = decodeSignedTransaction;
      var Transaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeTransaction(bytes);
        }
      };
      exports2.Transaction = Transaction;
      var SignedTransaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeSignedTransaction(bytes);
        }
      };
      exports2.SignedTransaction = SignedTransaction;
      exports2.SCHEMA = new class BorshSchema {
        constructor() {
          this.Signature = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 64 } }
            }
          };
          this.PublicKey = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 32 } }
            }
          };
          this.FunctionCallPermission = {
            struct: {
              allowance: { option: "u128" },
              receiverId: "string",
              methodNames: { array: { type: "string" } }
            }
          };
          this.FullAccessPermission = {
            struct: {}
          };
          this.AccessKeyPermission = {
            enum: [
              { struct: { functionCall: this.FunctionCallPermission } },
              { struct: { fullAccess: this.FullAccessPermission } }
            ]
          };
          this.AccessKey = {
            struct: {
              nonce: "u64",
              permission: this.AccessKeyPermission
            }
          };
          this.CreateAccount = {
            struct: {}
          };
          this.DeployContract = {
            struct: {
              code: { array: { type: "u8" } }
            }
          };
          this.FunctionCall = {
            struct: {
              methodName: "string",
              args: { array: { type: "u8" } },
              gas: "u64",
              deposit: "u128"
            }
          };
          this.Transfer = {
            struct: {
              deposit: "u128"
            }
          };
          this.Stake = {
            struct: {
              stake: "u128",
              publicKey: this.PublicKey
            }
          };
          this.AddKey = {
            struct: {
              publicKey: this.PublicKey,
              accessKey: this.AccessKey
            }
          };
          this.DeleteKey = {
            struct: {
              publicKey: this.PublicKey
            }
          };
          this.DeleteAccount = {
            struct: {
              beneficiaryId: "string"
            }
          };
          this.DelegateActionPrefix = {
            struct: {
              prefix: "u32"
            }
          };
          this.ClassicActions = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } }
            ]
          };
          this.DelegateAction = {
            struct: {
              senderId: "string",
              receiverId: "string",
              actions: { array: { type: this.ClassicActions } },
              nonce: "u64",
              maxBlockHeight: "u64",
              publicKey: this.PublicKey
            }
          };
          this.SignedDelegate = {
            struct: {
              delegateAction: this.DelegateAction,
              signature: this.Signature
            }
          };
          this.Action = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } },
              { struct: { signedDelegate: this.SignedDelegate } }
            ]
          };
          this.Transaction = {
            struct: {
              signerId: "string",
              publicKey: this.PublicKey,
              nonce: "u64",
              receiverId: "string",
              blockHash: { array: { type: "u8", len: 32 } },
              actions: { array: { type: this.Action } }
            }
          };
          this.SignedTransaction = {
            struct: {
              transaction: this.Transaction,
              signature: this.Signature
            }
          };
        }
      }();
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/create_transaction.js
  var require_create_transaction2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/create_transaction.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createTransaction = void 0;
      var schema_1 = require_schema2();
      function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
        return new schema_1.Transaction({
          signerId,
          publicKey,
          nonce: txNonce,
          receiverId,
          actions,
          blockHash
        });
      }
      exports2.createTransaction = createTransaction;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/delegate.js
  var require_delegate2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/delegate.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildDelegateAction = exports2.DelegateAction = void 0;
      var types_1 = require_lib14();
      var action_creators_1 = require_action_creators2();
      var { addKey, createAccount, deleteAccount, deleteKey, deployContract, functionCall, stake, transfer } = action_creators_1.actionCreators;
      var DelegateAction = class extends types_1.Assignable {
      };
      exports2.DelegateAction = DelegateAction;
      function buildDelegateAction({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
        return new DelegateAction({
          senderId,
          receiverId,
          actions: actions.map((a) => {
            if (!a.type && !a.params) {
              return a;
            }
            switch (a.type) {
              case "AddKey": {
                const { publicKey: publicKey2, accessKey } = a.params;
                return addKey(publicKey2, accessKey);
              }
              case "CreateAccount": {
                return createAccount(a.params.createAccount);
              }
              case "DeleteAccount": {
                return deleteAccount(a.params.deleteAccount);
              }
              case "DeleteKey": {
                return deleteKey(a.params.publicKey);
              }
              case "DeployContract": {
                return deployContract(a.params.code);
              }
              case "FunctionCall": {
                const { methodName, args, gas, deposit } = a.params;
                return functionCall(methodName, args, gas, deposit);
              }
              case "Stake": {
                return stake(a.params.stake, a.params.publicKey);
              }
              case "Transfer": {
                const { deposit } = a.params;
                return transfer(deposit);
              }
            }
            throw new Error("Unrecognized action");
          }),
          nonce,
          maxBlockHeight,
          publicKey
        });
      }
      exports2.buildDelegateAction = buildDelegateAction;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js
  var require_assert6 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js
  var require_crypto6 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js
  var require_utils15 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto6();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!isBytes(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/hashes/_sha2.js
  var require_sha26 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert6();
      var utils_js_1 = require_utils15();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js
  var require_sha2562 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha224 = exports2.sha256 = void 0;
      var _sha2_js_1 = require_sha26();
      var utils_js_1 = require_utils15();
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/signature.js
  var require_signature2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/signature.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signature = void 0;
      var types_1 = require_lib14();
      var Signature = class extends types_1.Assignable {
      };
      exports2.Signature = Signature;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/sign.js
  var require_sign2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/sign.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signDelegateAction = exports2.signTransaction = void 0;
      var sha256_1 = require_sha2562();
      var actions_1 = require_actions2();
      var create_transaction_1 = require_create_transaction2();
      var schema_1 = require_schema2();
      var signature_1 = require_signature2();
      function signTransactionObject(transaction, signer, accountId, networkId) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeTransaction)(transaction);
          const hash = new Uint8Array((0, sha256_1.sha256)(message));
          const signature = yield signer.signMessage(message, accountId, networkId);
          const signedTx = new schema_1.SignedTransaction({
            transaction,
            signature: new signature_1.Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })
          });
          return [hash, signedTx];
        });
      }
      function signTransaction(...args) {
        return __awaiter6(this, void 0, void 0, function* () {
          if (args[0].constructor === schema_1.Transaction) {
            const [transaction, signer, accountId, networkId] = args;
            return signTransactionObject(transaction, signer, accountId, networkId);
          } else {
            const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
            const publicKey = yield signer.getPublicKey(accountId, networkId);
            const transaction = (0, create_transaction_1.createTransaction)(accountId, publicKey, receiverId, nonce, actions, blockHash);
            return signTransactionObject(transaction, signer, accountId, networkId);
          }
        });
      }
      exports2.signTransaction = signTransaction;
      function signDelegateAction({ delegateAction, signer }) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeDelegateAction)(delegateAction);
          const signature = yield signer.sign(message);
          const signedDelegateAction = new actions_1.SignedDelegate({
            delegateAction,
            signature: new signature_1.Signature({
              keyType: delegateAction.publicKey.keyType,
              data: signature
            })
          });
          return {
            hash: new Uint8Array((0, sha256_1.sha256)(message)),
            signedDelegateAction
          };
        });
      }
      exports2.signDelegateAction = signDelegateAction;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/index.js
  var require_lib17 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/transactions/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_action_creators2(), exports2);
      __exportStar(require_actions2(), exports2);
      __exportStar(require_create_transaction2(), exports2);
      __exportStar(require_delegate2(), exports2);
      __exportStar(require_schema2(), exports2);
      __exportStar(require_sign2(), exports2);
      __exportStar(require_signature2(), exports2);
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/provider.js
  var require_provider11 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Provider = void 0;
      var Provider2 = class {
      };
      exports2.Provider = Provider2;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/fetch.js
  var require_fetch2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/fetch.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var node_fetch_1 = __importDefault(require_browser4());
      var http_1 = __importDefault(require_http());
      var https_1 = __importDefault(require_https());
      var httpAgent = new http_1.default.Agent({ keepAlive: true });
      var httpsAgent = new https_1.default.Agent({ keepAlive: true });
      function agent(_parsedURL) {
        if (_parsedURL.protocol === "http:") {
          return httpAgent;
        } else {
          return httpsAgent;
        }
      }
      function default_1(resource, init3) {
        return (0, node_fetch_1.default)(resource, Object.assign({ agent: agent(new URL(resource.toString())) }, init3));
      }
      exports2.default = default_1;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/fetch_json.js
  var require_fetch_json2 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/fetch_json.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fetchJson = void 0;
      var types_1 = require_lib14();
      var utils_1 = require_lib15();
      var http_errors_1 = __importDefault(require_http_errors());
      var exponential_backoff_1 = require_exponential_backoff2();
      var START_WAIT_TIME_MS = 1e3;
      var BACKOFF_MULTIPLIER = 1.5;
      var RETRY_NUMBER = 10;
      function fetchJson(connectionInfoOrUrl, json) {
        return __awaiter6(this, void 0, void 0, function* () {
          let connectionInfo = { url: null };
          if (typeof connectionInfoOrUrl === "string") {
            connectionInfo.url = connectionInfoOrUrl;
          } else {
            connectionInfo = connectionInfoOrUrl;
          }
          const response = yield (0, exponential_backoff_1.exponentialBackoff)(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, () => __awaiter6(this, void 0, void 0, function* () {
            var _a;
            try {
              const response2 = yield ((_a = globalThis.fetch) !== null && _a !== void 0 ? _a : (yield Promise.resolve().then(() => __importStar(require_fetch2()))).default)(connectionInfo.url, {
                method: json ? "POST" : "GET",
                body: json ? json : void 0,
                headers: Object.assign(Object.assign({}, connectionInfo.headers), { "Content-Type": "application/json" })
              });
              if (!response2.ok) {
                if (response2.status === 503) {
                  utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);
                  return null;
                } else if (response2.status === 408) {
                  utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} as the previous connection was unused for some time`);
                  return null;
                }
                throw (0, http_errors_1.default)(response2.status, yield response2.text());
              }
              return response2;
            } catch (error2) {
              if (error2.toString().includes("FetchError") || error2.toString().includes("Failed to fetch")) {
                utils_1.Logger.warn(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error2}`);
                return null;
              }
              throw error2;
            }
          }));
          if (!response) {
            throw new types_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, "RetriesExceeded");
          }
          return yield response.json();
        });
      }
      exports2.fetchJson = fetchJson;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/json-rpc-provider.js
  var require_json_rpc_provider3 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/json-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonRpcProvider = void 0;
      var utils_1 = require_lib15();
      var types_1 = require_lib14();
      var transactions_1 = require_lib17();
      var exponential_backoff_1 = require_exponential_backoff2();
      var provider_1 = require_provider11();
      var fetch_json_1 = require_fetch_json2();
      var REQUEST_RETRY_NUMBER = 12;
      var REQUEST_RETRY_WAIT = 500;
      var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
      var _nextId = 123;
      var JsonRpcProvider3 = class extends provider_1.Provider {
        /**
         * @param connectionInfo Connection info
         */
        constructor(connectionInfo, options) {
          super();
          this.connection = connectionInfo || { url: "" };
          const defaultOptions = {
            retries: REQUEST_RETRY_NUMBER,
            wait: REQUEST_RETRY_WAIT,
            backoff: REQUEST_RETRY_WAIT_BACKOFF
          };
          this.options = Object.assign({}, defaultOptions, options);
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        status() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("status", []);
          });
        }
        /**
         * Sends a signed transaction to the RPC
         *
         * @param signedTransaction The signed transaction being sent
         * @param waitUntil
         */
        sendTransactionUntil(signedTransaction, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            const bytes = (0, transactions_1.encodeTransaction)(signedTransaction);
            return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes).toString("base64"), wait_until: waitUntil });
          });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        sendTransaction(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
          });
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        sendTransactionAsync(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendTransactionUntil(signedTransaction, "NONE");
          });
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         */
        txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof txHash === "string") {
              return this.txStatusString(txHash, accountId, waitUntil);
            } else {
              return this.txStatusUint8Array(txHash, accountId, waitUntil);
            }
          });
        }
        txStatusUint8Array(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("tx", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
          });
        }
        txStatusString(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
          });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         * @returns {Promise<FinalExecutionOutcome>}
         */
        txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof txHash === "string") {
              return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
            } else {
              return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
            }
          });
        }
        /**
         * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
         * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
         *
         * @typeParam T the shape of the returned query response
         */
        query(...args) {
          return __awaiter6(this, void 0, void 0, function* () {
            let result;
            if (args.length === 1) {
              const _a = args[0], { block_id, blockId } = _a, otherParams = __rest(_a, ["block_id", "blockId"]);
              result = yield this.sendJsonRpc("query", Object.assign(Object.assign({}, otherParams), { block_id: block_id || blockId }));
            } else {
              const [path7, data7] = args;
              result = yield this.sendJsonRpc("query", [path7, data7]);
            }
            if (result && result.error) {
              throw new types_1.TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, (0, utils_1.getErrorTypeFromErrorMessage)(result.error, result.error.name));
            }
            return result;
          });
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        block(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("block", { block_id: blockId, finality });
          });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        blockChanges(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
          });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        chunk(chunkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("chunk", [chunkId]);
          });
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        validators(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.sendJsonRpc("validators", [blockId]);
          });
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        experimental_protocolConfig(blockReference) {
          return __awaiter6(this, void 0, void 0, function* () {
            const _a = blockReference, { blockId } = _a, otherParams = __rest(_a, ["blockId"]);
            return yield this.sendJsonRpc("EXPERIMENTAL_protocol_config", Object.assign(Object.assign({}, otherParams), { block_id: blockId }));
          });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        lightClientProof(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request3);
          });
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        nextLightClientBlock(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("next_light_client_block", request3);
          });
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        accessKeyChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "all_access_key_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "single_access_key_changes",
              keys: accessKeyArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        accountChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "account_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "data_changes",
              account_ids: accountIdArray,
              key_prefix_base64: keyPrefix,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractCodeChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { finality } = blockQuery;
            const { blockId } = blockQuery;
            return this.sendJsonRpc("EXPERIMENTAL_changes", {
              changes_type: "contract_code_changes",
              account_ids: accountIdArray,
              block_id: blockId,
              finality
            });
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        gasPrice(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.sendJsonRpc("gas_price", [blockId]);
          });
        }
        /**
         * Directly call the RPC specifying the method and params
         *
         * @param method RPC method
         * @param params Parameters to the method
         */
        sendJsonRpc(method2, params) {
          return __awaiter6(this, void 0, void 0, function* () {
            const response = yield (0, exponential_backoff_1.exponentialBackoff)(this.options.wait, this.options.retries, this.options.backoff, () => __awaiter6(this, void 0, void 0, function* () {
              var _a;
              try {
                const request3 = {
                  method: method2,
                  params,
                  id: _nextId++,
                  jsonrpc: "2.0"
                };
                const response2 = yield (0, fetch_json_1.fetchJson)(this.connection, JSON.stringify(request3));
                if (response2.error) {
                  if (typeof response2.error.data === "object") {
                    if (typeof response2.error.data.error_message === "string" && typeof response2.error.data.error_type === "string") {
                      throw new types_1.TypedError(response2.error.data.error_message, response2.error.data.error_type);
                    }
                    throw (0, utils_1.parseRpcError)(response2.error.data);
                  } else {
                    const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
                    if (response2.error.data === "Timeout" || errorMessage.includes("Timeout error") || errorMessage.includes("query has timed out")) {
                      throw new types_1.TypedError(errorMessage, "TimeoutError");
                    }
                    const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.error.data, "");
                    if (errorType) {
                      throw new types_1.TypedError((0, utils_1.formatError)(errorType, params), errorType);
                    }
                    throw new types_1.TypedError(errorMessage, response2.error.name);
                  }
                } else if (typeof ((_a = response2.result) === null || _a === void 0 ? void 0 : _a.error) === "string") {
                  const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.result.error, "");
                  if (errorType) {
                    throw new utils_1.ServerError((0, utils_1.formatError)(errorType, params), errorType);
                  }
                }
                return response2;
              } catch (error2) {
                if (error2.type === "TimeoutError") {
                  utils_1.Logger.warn(`Retrying request to ${method2} as it has timed out`, params);
                  return null;
                }
                throw error2;
              }
            }));
            const { result } = response;
            if (typeof result === "undefined") {
              throw new types_1.TypedError(`Exceeded ${this.options.retries} attempts for request to ${method2}.`, "RetriesExceeded");
            }
            return result;
          });
        }
      };
      exports2.JsonRpcProvider = JsonRpcProvider3;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/failover-rpc-provider.js
  var require_failover_rpc_provider3 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/failover-rpc-provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FailoverRpcProvider = void 0;
      var utils_1 = require_lib15();
      var types_1 = require_lib14();
      var provider_1 = require_provider11();
      var FailoverRpcProvider2 = class extends provider_1.Provider {
        /**
         * @param providers list of providers
         */
        constructor(providers4) {
          super();
          if (providers4.length === 0) {
            throw new Error("At least one provider must be specified");
          }
          this.providers = providers4;
          this.currentProviderIndex = 0;
        }
        switchToNextProvider() {
          if (this.providers.length === 1)
            return;
          if (this.providers.length - 1 <= this.currentProviderIndex) {
            this.currentProviderIndex = 0;
          } else {
            this.currentProviderIndex += 1;
          }
          utils_1.Logger.debug(`Switched to provider at the index ${this.currentProviderIndex}`);
        }
        get currentProvider() {
          const provider = this.providers[this.currentProviderIndex];
          if (!provider)
            throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
          return provider;
        }
        withBackoff(getResult) {
          return __awaiter6(this, void 0, void 0, function* () {
            for (let i = 0; i < this.providers.length; i++) {
              try {
                const result = yield getResult(this.currentProvider);
                if (result)
                  return result;
              } catch (_a) {
                this.switchToNextProvider();
              }
            }
            throw new types_1.TypedError(`Exceeded ${this.providers.length} providers to execute request`, "RetriesExceeded");
          });
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        status() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.status());
          });
        }
        sendTransactionUntil(signedTransaction, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
          });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        sendTransaction(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
          });
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        sendTransactionAsync(signedTransaction) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
          });
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         */
        txStatus(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil));
          });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @returns {Promise<FinalExecutionOutcome>}
         */
        txStatusReceipts(txHash, accountId, waitUntil) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil));
          });
        }
        query(paramsOrPath, data7) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (data7) {
              return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath, data7));
            }
            return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath));
          });
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        block(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
          });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        blockChanges(blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
          });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        chunk(chunkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
          });
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        validators(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
          });
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        experimental_protocolConfig(blockReference) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
          });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        lightClientProof(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request3));
          });
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        nextLightClientBlock(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request3));
          });
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        accessKeyChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        accountChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        contractCodeChanges(accountIdArray, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        gasPrice(blockId) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
          });
        }
      };
      exports2.FailoverRpcProvider = FailoverRpcProvider2;
    }
  });

  // node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/index.js
  var require_lib18 = __commonJS({
    "node_modules/@near-js/accounts/node_modules/@near-js/providers/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fetchJson = exports2.Provider = exports2.FailoverRpcProvider = exports2.JsonRpcProvider = exports2.exponentialBackoff = void 0;
      var exponential_backoff_1 = require_exponential_backoff2();
      Object.defineProperty(exports2, "exponentialBackoff", { enumerable: true, get: function() {
        return exponential_backoff_1.exponentialBackoff;
      } });
      var json_rpc_provider_1 = require_json_rpc_provider3();
      Object.defineProperty(exports2, "JsonRpcProvider", { enumerable: true, get: function() {
        return json_rpc_provider_1.JsonRpcProvider;
      } });
      var failover_rpc_provider_1 = require_failover_rpc_provider3();
      Object.defineProperty(exports2, "FailoverRpcProvider", { enumerable: true, get: function() {
        return failover_rpc_provider_1.FailoverRpcProvider;
      } });
      var provider_1 = require_provider11();
      Object.defineProperty(exports2, "Provider", { enumerable: true, get: function() {
        return provider_1.Provider;
      } });
      var fetch_json_1 = require_fetch_json2();
      Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
        return fetch_json_1.fetchJson;
      } });
    }
  });

  // node_modules/@near-js/accounts/lib/utils.js
  var require_utils16 = __commonJS({
    "node_modules/@near-js/accounts/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.viewFunction = exports2.viewState = exports2.encodeJSContractArgs = exports2.validateArgs = void 0;
      var types_1 = require_lib14();
      var utils_1 = require_lib15();
      function parseJsonFromRawResponse(response) {
        return JSON.parse(Buffer.from(response).toString());
      }
      function bytesJsonStringify(input) {
        return Buffer.from(JSON.stringify(input));
      }
      function validateArgs(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        if (isUint8Array) {
          return;
        }
        if (Array.isArray(args) || typeof args !== "object") {
          throw new types_1.PositionalArgsError();
        }
      }
      exports2.validateArgs = validateArgs;
      function encodeJSContractArgs(contractId, method2, args) {
        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method2), Buffer.from([0]), Buffer.from(args)]);
      }
      exports2.encodeJSContractArgs = encodeJSContractArgs;
      function viewState(connection, accountId, prefix, blockQuery = { finality: "optimistic" }) {
        return __awaiter6(this, void 0, void 0, function* () {
          const { values: values2 } = yield connection.provider.query(Object.assign(Object.assign({ request_type: "view_state" }, blockQuery), { account_id: accountId, prefix_base64: Buffer.from(prefix).toString("base64") }));
          return values2.map(({ key, value }) => ({
            key: Buffer.from(key, "base64"),
            value: Buffer.from(value, "base64")
          }));
        });
      }
      exports2.viewState = viewState;
      function viewFunction(connection, { contractId, methodName, args = {}, parse: parse3 = parseJsonFromRawResponse, stringify: stringify2 = bytesJsonStringify, jsContract = false, blockQuery = { finality: "optimistic" } }) {
        return __awaiter6(this, void 0, void 0, function* () {
          let encodedArgs;
          validateArgs(args);
          if (jsContract) {
            encodedArgs = encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : "");
          } else {
            encodedArgs = stringify2(args);
          }
          const result = yield connection.provider.query(Object.assign(Object.assign({ request_type: "call_function" }, blockQuery), { account_id: jsContract ? connection.jsvmAccountId : contractId, method_name: jsContract ? "view_js_contract" : methodName, args_base64: encodedArgs.toString("base64") }));
          if (result.logs) {
            (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });
          }
          return result.result && result.result.length > 0 && parse3(Buffer.from(result.result));
        });
      }
      exports2.viewFunction = viewFunction;
    }
  });

  // node_modules/@near-js/accounts/lib/account.js
  var require_account = __commonJS({
    "node_modules/@near-js/accounts/lib/account.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Account = void 0;
      var crypto_1 = require_lib16();
      var providers_1 = require_lib18();
      var transactions_1 = require_lib17();
      var types_1 = require_lib14();
      var utils_1 = require_lib15();
      var utils_2 = require_utils16();
      var { addKey, createAccount, deleteAccount, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey, stake, transfer } = transactions_1.actionCreators;
      var TX_NONCE_RETRY_NUMBER = 12;
      var TX_NONCE_RETRY_WAIT = 500;
      var TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
      var Account = class _Account {
        constructor(connection, accountId) {
          this.accessKeyByPublicKeyCache = {};
          this.connection = connection;
          this.accountId = accountId;
        }
        getConnection() {
          return this.connection;
        }
        /**
         * Returns basic NEAR account information via the `view_account` RPC query method
         * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
         */
        state() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.connection.provider.query({
              request_type: "view_account",
              account_id: this.accountId,
              finality: "optimistic"
            });
          });
        }
        /**
         * Create a signed transaction which can be broadcast to the network
         * @param receiverId NEAR account receiving the transaction
         * @param actions list of actions to perform as part of the transaction
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
         */
        signTransaction(receiverId, actions) {
          return __awaiter6(this, void 0, void 0, function* () {
            const accessKeyInfo = yield this.findAccessKey(receiverId, actions);
            if (!accessKeyInfo) {
              throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
            }
            const { accessKey } = accessKeyInfo;
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = block.header.hash;
            const nonce = accessKey.nonce + BigInt(1);
            return yield (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, utils_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
          });
        }
        /**
         * Sign a transaction to perform a list of actions and broadcast it using the RPC API.
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }
         *
         * @param options The options for signing and sending the transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be performed in the transaction.
         * @param options.returnError Whether to return an error if the transaction fails.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        signAndSendTransaction({ receiverId, actions, returnError }) {
          return __awaiter6(this, void 0, void 0, function* () {
            let txHash, signedTx;
            const result = yield (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, () => __awaiter6(this, void 0, void 0, function* () {
              [txHash, signedTx] = yield this.signTransaction(receiverId, actions);
              const publicKey = signedTx.transaction.publicKey;
              try {
                return yield this.connection.provider.sendTransaction(signedTx);
              } catch (error2) {
                if (error2.type === "InvalidNonce") {
                  utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} with new nonce.`);
                  delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                  return null;
                }
                if (error2.type === "Expired") {
                  utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} due to expired block hash`);
                  return null;
                }
                error2.context = new types_1.ErrorContext((0, utils_1.baseEncode)(txHash));
                throw error2;
              }
            }));
            if (!result) {
              throw new types_1.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
            }
            (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });
            if (!returnError && typeof result.status === "object" && typeof result.status.Failure === "object" && result.status.Failure !== null) {
              if (result.status.Failure.error_message && result.status.Failure.error_type) {
                throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
              } else {
                throw (0, utils_1.parseResultError)(result);
              }
            }
            return result;
          });
        }
        /**
         * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link "@near-js/keystores".keystore.KeyStore | Keystore}.
         *
         * @todo Find matching access key based on transaction (i.e. receiverId and actions)
         *
         * @param receiverId currently unused (see todo)
         * @param actions currently unused (see todo)
         * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        findAccessKey(receiverId, actions) {
          return __awaiter6(this, void 0, void 0, function* () {
            const publicKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
            if (!publicKey) {
              throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
            }
            const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
            if (cachedAccessKey !== void 0) {
              return { publicKey, accessKey: cachedAccessKey };
            }
            try {
              const rawAccessKey = yield this.connection.provider.query({
                request_type: "view_access_key",
                account_id: this.accountId,
                public_key: publicKey.toString(),
                finality: "optimistic"
              });
              const accessKey = Object.assign(Object.assign({}, rawAccessKey), { nonce: BigInt(rawAccessKey.nonce || 0) });
              if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
              }
              this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
              return { publicKey, accessKey };
            } catch (e) {
              if (e.type == "AccessKeyDoesNotExist") {
                return null;
              }
              throw e;
            }
          });
        }
        /**
         * Create a new account and deploy a contract to it
         *
         * @param contractId NEAR account where the contract is deployed
         * @param publicKey The public key to add to the created contract account
         * @param data The compiled contract code
         * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
         */
        createAndDeployContract(contractId, publicKey, data7, amount) {
          return __awaiter6(this, void 0, void 0, function* () {
            const accessKey = fullAccessKey();
            yield this.signAndSendTransaction({
              receiverId: contractId,
              actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey), deployContract(data7)]
            });
            const contractAccount = new _Account(this.connection, contractId);
            return contractAccount;
          });
        }
        /**
         * @param receiverId NEAR account receiving 
         * @param amount Amount to send in yocto
         */
        sendMoney(receiverId, amount) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId,
              actions: [transfer(amount)]
            });
          });
        }
        /**
         * @param newAccountId NEAR account name to be created
         * @param publicKey A public key created from the masterAccount
         */
        createAccount(newAccountId, publicKey, amount) {
          return __awaiter6(this, void 0, void 0, function* () {
            const accessKey = fullAccessKey();
            return this.signAndSendTransaction({
              receiverId: newAccountId,
              actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey)]
            });
          });
        }
        /**
         * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
         */
        deleteAccount(beneficiaryId) {
          return __awaiter6(this, void 0, void 0, function* () {
            utils_1.Logger.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.");
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [deleteAccount(beneficiaryId)]
            });
          });
        }
        /**
         * @param data The compiled contract code
         */
        deployContract(data7) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [deployContract(data7)]
            });
          });
        }
        /** @hidden */
        encodeJSContractArgs(contractId, method2, args) {
          return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method2), Buffer.from([0]), Buffer.from(args)]);
        }
        /**
          * Execute a function call.
          * @param options The options for the function call.
          * @param options.contractId The NEAR account ID of the smart contract.
          * @param options.methodName The name of the method to be called on the smart contract.
          * @param options.args The arguments to be passed to the method.
          * @param options.gas The maximum amount of gas to be used for the function call.
          * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.
          * @param options.walletMeta Metadata for wallet integration.
          * @param options.walletCallbackUrl The callback URL for wallet integration.
          * @param options.stringify A function to convert input arguments into bytes array
          * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.
          * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.
          */
        functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify: stringify2, jsContract }) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.validateArgs(args);
            let functionCallArgs;
            if (jsContract) {
              const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));
              functionCallArgs = ["call_js_contract", encodedArgs, gas, attachedDeposit, null, true];
            } else {
              const stringifyArg = stringify2 === void 0 ? transactions_1.stringifyJsonOrBytes : stringify2;
              functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];
            }
            return this.signAndSendTransaction({
              receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
              // eslint-disable-next-line prefer-spread
              actions: [functionCall.apply(void 0, functionCallArgs)],
              walletMeta,
              walletCallbackUrl
            });
          });
        }
        /**
         * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
         * @todo expand this API to support more options.
         * @param publicKey A public key to be associated with the contract
         * @param contractId NEAR account where the contract is deployed
         * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
         * @param amount Payment in yocto that is sent to the contract during this function call
         */
        addKey(publicKey, contractId, methodNames, amount) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (!methodNames) {
              methodNames = [];
            }
            if (!Array.isArray(methodNames)) {
              methodNames = [methodNames];
            }
            let accessKey;
            if (!contractId) {
              accessKey = fullAccessKey();
            } else {
              accessKey = functionCallAccessKey(contractId, methodNames, amount);
            }
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)]
            });
          });
        }
        /**
         * @param publicKey The public key to be deleted
         * @returns {Promise<FinalExecutionOutcome>}
         */
        deleteKey(publicKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [deleteKey(crypto_1.PublicKey.from(publicKey))]
            });
          });
        }
        /**
         * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
         *
         * @param publicKey The public key for the account that's staking
         * @param amount The account to stake in yocto
         */
        stake(publicKey, amount) {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [stake(amount, crypto_1.PublicKey.from(publicKey))]
            });
          });
        }
        /**
         * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance
         *
         * @param options Options for the transaction.
         * @param options.actions Actions to be included in the meta transaction
         * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction
         * @param options.receiverId Receiver account of the meta transaction
         */
        signedDelegate({ actions, blockHeightTtl, receiverId }) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { provider, signer } = this.connection;
            const { header } = yield provider.block({ finality: "final" });
            const { accessKey, publicKey } = yield this.findAccessKey(null, null);
            const delegateAction = (0, transactions_1.buildDelegateAction)({
              actions,
              maxBlockHeight: BigInt(header.height) + BigInt(blockHeightTtl),
              nonce: BigInt(accessKey.nonce) + BigInt(1),
              publicKey,
              receiverId,
              senderId: this.accountId
            });
            const { signedDelegateAction } = yield (0, transactions_1.signDelegateAction)({
              delegateAction,
              signer: {
                sign: (message) => __awaiter6(this, void 0, void 0, function* () {
                  const { signature } = yield signer.signMessage(message, delegateAction.senderId, this.connection.networkId);
                  return signature;
                })
              }
            });
            return signedDelegateAction;
          });
        }
        /** @hidden */
        validateArgs(args) {
          const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
          if (isUint8Array) {
            return;
          }
          if (Array.isArray(args) || typeof args !== "object") {
            throw new types_1.PositionalArgsError();
          }
        }
        /**
         * Invoke a contract view function using the RPC API.
         * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
         *
         * @param options Function call options.
         * @param options.contractId NEAR account where the contract is deployed
         * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
         * @param options.args Any arguments to the view contract method, wrapped in JSON
         * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
         * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
         * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
         * @param options.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         * @returns {Promise<any>}
         */
        viewFunction(options) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield (0, utils_2.viewFunction)(this.connection, options);
          });
        }
        /**
         * Returns the state (key value pairs) of this account's contract based on the key prefix.
         * Pass an empty string for prefix if you would like to return the entire state.
         * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
         *
         * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
         * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         */
        viewState(prefix, blockQuery = { finality: "optimistic" }) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield (0, utils_2.viewState)(this.connection, this.accountId, prefix, blockQuery);
          });
        }
        /**
         * Get all access keys for the account
         * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
         */
        getAccessKeys() {
          var _a;
          return __awaiter6(this, void 0, void 0, function* () {
            const response = yield this.connection.provider.query({
              request_type: "view_access_key_list",
              account_id: this.accountId,
              finality: "optimistic"
            });
            return (_a = response === null || response === void 0 ? void 0 : response.keys) === null || _a === void 0 ? void 0 : _a.map((key) => Object.assign(Object.assign({}, key), { access_key: Object.assign(Object.assign({}, key.access_key), { nonce: BigInt(key.access_key.nonce) }) }));
          });
        }
        /**
         * Returns a list of authorized apps
         * @todo update the response value to return all the different keys, not just app keys.
         */
        getAccountDetails() {
          return __awaiter6(this, void 0, void 0, function* () {
            const accessKeys = yield this.getAccessKeys();
            const authorizedApps = accessKeys.filter((item) => item.access_key.permission !== "FullAccess").map((item) => {
              const perm = item.access_key.permission;
              return {
                contractId: perm.FunctionCall.receiver_id,
                amount: perm.FunctionCall.allowance,
                publicKey: item.public_key
              };
            });
            return { authorizedApps };
          });
        }
        /**
         * Returns calculated account balance
         */
        getAccountBalance() {
          return __awaiter6(this, void 0, void 0, function* () {
            const protocolConfig = yield this.connection.provider.experimental_protocolConfig({ finality: "final" });
            const state = yield this.state();
            const costPerByte = BigInt(protocolConfig.runtime_config.storage_amount_per_byte);
            const stateStaked = BigInt(state.storage_usage) * costPerByte;
            const staked = BigInt(state.locked);
            const totalBalance = BigInt(state.amount) + staked;
            const availableBalance = totalBalance - (staked > stateStaked ? staked : stateStaked);
            return {
              total: totalBalance.toString(),
              stateStaked: stateStaked.toString(),
              staked: staked.toString(),
              available: availableBalance.toString()
            };
          });
        }
        /**
         * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
         *
         * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
         * @returns {Promise<ActiveDelegatedStakeBalance>}
         */
        getActiveDelegatedStakeBalance() {
          return __awaiter6(this, void 0, void 0, function* () {
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = block.header.hash;
            const epochId = block.header.epoch_id;
            const { current_validators, next_validators, current_proposals } = yield this.connection.provider.validators(epochId);
            const pools = /* @__PURE__ */ new Set();
            [...current_validators, ...next_validators, ...current_proposals].forEach((validator) => pools.add(validator.account_id));
            const uniquePools = [...pools];
            const promises = uniquePools.map((validator) => this.viewFunction({
              contractId: validator,
              methodName: "get_account_total_balance",
              args: { account_id: this.accountId },
              blockQuery: { blockId: blockHash }
            }));
            const results = yield Promise.allSettled(promises);
            const hasTimeoutError = results.some((result) => {
              if (result.status === "rejected" && result.reason.type === "TimeoutError") {
                return true;
              }
              return false;
            });
            if (hasTimeoutError) {
              throw new Error("Failed to get delegated stake balance");
            }
            const summary = results.reduce((result, state, index) => {
              const validatorId = uniquePools[index];
              if (state.status === "fulfilled") {
                const currentBN = BigInt(state.value);
                if (currentBN !== BigInt(0)) {
                  return Object.assign(Object.assign({}, result), { stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }], total: result.total + currentBN });
                }
              }
              if (state.status === "rejected") {
                return Object.assign(Object.assign({}, result), { failedValidators: [...result.failedValidators, { validatorId, error: state.reason }] });
              }
              return result;
            }, { stakedValidators: [], failedValidators: [], total: BigInt(0) });
            return Object.assign(Object.assign({}, summary), { total: summary.total.toString() });
          });
        }
      };
      exports2.Account = Account;
    }
  });

  // node_modules/@near-js/accounts/lib/constants.js
  var require_constants9 = __commonJS({
    "node_modules/@near-js/accounts/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MULTISIG_CONFIRM_METHODS = exports2.MULTISIG_CHANGE_METHODS = exports2.MULTISIG_DEPOSIT = exports2.MULTISIG_GAS = exports2.MULTISIG_ALLOWANCE = exports2.MULTISIG_STORAGE_KEY = void 0;
      var utils_1 = require_lib15();
      exports2.MULTISIG_STORAGE_KEY = "__multisigRequest";
      exports2.MULTISIG_ALLOWANCE = BigInt((0, utils_1.parseNearAmount)("1"));
      exports2.MULTISIG_GAS = BigInt("100000000000000");
      exports2.MULTISIG_DEPOSIT = BigInt("0");
      exports2.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"];
      exports2.MULTISIG_CONFIRM_METHODS = ["confirm"];
    }
  });

  // node_modules/@near-js/accounts/lib/types.js
  var require_types2 = __commonJS({
    "node_modules/@near-js/accounts/lib/types.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MultisigStateStatus = exports2.MultisigDeleteRequestRejectionError = void 0;
      var MultisigDeleteRequestRejectionError;
      (function(MultisigDeleteRequestRejectionError2) {
        MultisigDeleteRequestRejectionError2["CANNOT_DESERIALIZE_STATE"] = "Cannot deserialize the contract state";
        MultisigDeleteRequestRejectionError2["MULTISIG_NOT_INITIALIZED"] = "Smart contract panicked: Multisig contract should be initialized before usage";
        MultisigDeleteRequestRejectionError2["NO_SUCH_REQUEST"] = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
        MultisigDeleteRequestRejectionError2["REQUEST_COOLDOWN_ERROR"] = "Request cannot be deleted immediately after creation.";
        MultisigDeleteRequestRejectionError2["METHOD_NOT_FOUND"] = "Contract method is not found";
      })(MultisigDeleteRequestRejectionError = exports2.MultisigDeleteRequestRejectionError || (exports2.MultisigDeleteRequestRejectionError = {}));
      var MultisigStateStatus;
      (function(MultisigStateStatus2) {
        MultisigStateStatus2[MultisigStateStatus2["INVALID_STATE"] = 0] = "INVALID_STATE";
        MultisigStateStatus2[MultisigStateStatus2["STATE_NOT_INITIALIZED"] = 1] = "STATE_NOT_INITIALIZED";
        MultisigStateStatus2[MultisigStateStatus2["VALID_STATE"] = 2] = "VALID_STATE";
        MultisigStateStatus2[MultisigStateStatus2["UNKNOWN_STATE"] = 3] = "UNKNOWN_STATE";
      })(MultisigStateStatus = exports2.MultisigStateStatus || (exports2.MultisigStateStatus = {}));
    }
  });

  // node_modules/@near-js/accounts/lib/account_multisig.js
  var require_account_multisig = __commonJS({
    "node_modules/@near-js/accounts/lib/account_multisig.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccountMultisig = void 0;
      var transactions_1 = require_lib17();
      var utils_1 = require_lib15();
      var account_1 = require_account();
      var constants_1 = require_constants9();
      var types_1 = require_types2();
      var { deployContract, functionCall } = transactions_1.actionCreators;
      var MultisigCodeStatus;
      (function(MultisigCodeStatus2) {
        MultisigCodeStatus2[MultisigCodeStatus2["INVALID_CODE"] = 0] = "INVALID_CODE";
        MultisigCodeStatus2[MultisigCodeStatus2["VALID_CODE"] = 1] = "VALID_CODE";
        MultisigCodeStatus2[MultisigCodeStatus2["UNKNOWN_CODE"] = 2] = "UNKNOWN_CODE";
      })(MultisigCodeStatus || (MultisigCodeStatus = {}));
      var storageFallback = {
        [constants_1.MULTISIG_STORAGE_KEY]: null
      };
      var AccountMultisig = class extends account_1.Account {
        /**
         * Constructs an instance of the `AccountMultisig` class.
         * @param connection The NEAR connection object.
         * @param accountId The NEAR account ID.
         * @param options Additional options for the multisig account.
         * @param options.storage Storage to store data related to multisig operations.
         * @param options.onAddRequestResult Callback function to handle the result of adding a request.
         */
        constructor(connection, accountId, options) {
          super(connection, accountId);
          this.storage = options.storage;
          this.onAddRequestResult = options.onAddRequestResult;
        }
        /**
         * Sign and send a transaction with the multisig account as the sender.
         * @param receiverId - The NEAR account ID of the transaction receiver.
         * @param actions - The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        signAndSendTransactionWithAccount(receiverId, actions) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            return _super.signAndSendTransaction.call(this, { receiverId, actions });
          });
        }
        /**
         * Sign and send a multisig transaction to add a request and confirm it.
         * @param options Options for the multisig transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        signAndSendTransaction({ receiverId, actions }) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const args = Buffer.from(JSON.stringify({
              request: {
                receiver_id: receiverId,
                actions: convertActions(actions, accountId, receiverId)
              }
            }));
            let result;
            try {
              result = yield _super.signAndSendTransaction.call(this, {
                receiverId: accountId,
                actions: [
                  functionCall("add_request_and_confirm", args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
                ]
              });
            } catch (e) {
              if (e.toString().includes("Account has too many active requests. Confirm or delete some")) {
                yield this.deleteUnconfirmedRequests();
                return yield this.signAndSendTransaction({ receiverId, actions });
              }
              throw e;
            }
            if (!result.status) {
              throw new Error("Request failed");
            }
            const status = Object.assign({}, result.status);
            if (!status.SuccessValue || typeof status.SuccessValue !== "string") {
              throw new Error("Request failed");
            }
            this.setRequest({
              accountId,
              actions,
              requestId: parseInt(Buffer.from(status.SuccessValue, "base64").toString("ascii"), 10)
            });
            if (this.onAddRequestResult) {
              yield this.onAddRequestResult(result);
            }
            this.deleteUnconfirmedRequests();
            return result;
          });
        }
        /**
         * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state
         * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.
         * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.
         * @param contractBytes The bytecode of the multisig contract.
         * @returns {Promise<{ codeStatus: MultisigCodeStatus; stateStatus: MultisigStateStatus }>} A promise that resolves to the status of the code and state.
         */
        checkMultisigCodeAndStateStatus(contractBytes) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            const u32_max = 4294967295;
            const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;
            try {
              if (contractBytes) {
                yield _super.signAndSendTransaction.call(this, {
                  receiverId: this.accountId,
                  actions: [
                    deployContract(contractBytes),
                    functionCall("delete_request", { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
                  ]
                });
              } else {
                yield this.deleteRequest(u32_max);
              }
              return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
            } catch (e) {
              if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {
                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };
              } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {
                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };
              } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {
                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
              } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {
                return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };
              }
              throw e;
            }
          });
        }
        /**
         * Delete a multisig request by its ID.
         * @param request_id The ID of the multisig request to be deleted.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deletion.
         */
        deleteRequest(request_id) {
          return super.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [functionCall("delete_request", { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
          });
        }
        /**
         * Delete all multisig requests associated with the account.
         * @returns {Promise<void>} A promise that resolves when all requests are deleted.
         */
        deleteAllRequests() {
          return __awaiter6(this, void 0, void 0, function* () {
            const request_ids = yield this.getRequestIds();
            if (request_ids.length) {
              yield Promise.all(request_ids.map((id7) => this.deleteRequest(id7)));
            }
          });
        }
        /**
         * Delete unconfirmed multisig requests associated with the account.
         * @returns {Promise<void>} A promise that resolves when unconfirmed requests are deleted.
         */
        deleteUnconfirmedRequests() {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            const request_ids = yield this.getRequestIds();
            const { requestId } = this.getRequest();
            for (const requestIdToDelete of request_ids) {
              if (requestIdToDelete == requestId) {
                continue;
              }
              try {
                yield _super.signAndSendTransaction.call(this, {
                  receiverId: this.accountId,
                  actions: [functionCall("delete_request", { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
                });
              } catch (e) {
                utils_1.Logger.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
              }
            }
          });
        }
        // helpers
        getRequestIds() {
          return __awaiter6(this, void 0, void 0, function* () {
            return this.viewFunction({
              contractId: this.accountId,
              methodName: "list_request_ids"
            });
          });
        }
        getRequest() {
          if (this.storage) {
            return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || "{}");
          }
          return storageFallback[constants_1.MULTISIG_STORAGE_KEY];
        }
        setRequest(data7) {
          if (this.storage) {
            return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data7));
          }
          storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data7;
        }
      };
      exports2.AccountMultisig = AccountMultisig;
      var convertPKForContract = (pk) => pk.toString().replace("ed25519:", "");
      var convertActions = (actions, accountId, receiverId) => actions.map((a) => {
        const type = a.enum;
        const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];
        const action = {
          type: type[0].toUpperCase() + type.substr(1),
          gas: gas && gas.toString() || void 0,
          public_key: publicKey && convertPKForContract(publicKey) || void 0,
          method_name: methodName,
          args: args && Buffer.from(args).toString("base64") || void 0,
          code: code && Buffer.from(code).toString("base64") || void 0,
          amount: deposit && deposit.toString() || void 0,
          deposit: deposit && deposit.toString() || "0",
          permission: void 0
        };
        if (accessKey) {
          if (receiverId === accountId && accessKey.permission.enum !== "fullAccess") {
            action.permission = {
              receiver_id: accountId,
              allowance: constants_1.MULTISIG_ALLOWANCE.toString(),
              method_names: constants_1.MULTISIG_CHANGE_METHODS
            };
          }
          if (accessKey.permission.enum === "functionCall") {
            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
            action.permission = {
              receiver_id,
              allowance: allowance && allowance.toString() || void 0,
              method_names
            };
          }
        }
        return action;
      });
    }
  });

  // node_modules/@near-js/accounts/lib/account_2fa.js
  var require_account_2fa = __commonJS({
    "node_modules/@near-js/accounts/lib/account_2fa.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Account2FA = void 0;
      var crypto_1 = require_lib16();
      var types_1 = require_lib14();
      var providers_1 = require_lib18();
      var transactions_1 = require_lib17();
      var utils_1 = require_lib15();
      var account_multisig_1 = require_account_multisig();
      var constants_1 = require_constants9();
      var types_2 = require_types2();
      var { addKey, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey } = transactions_1.actionCreators;
      var Account2FA = class extends account_multisig_1.AccountMultisig {
        constructor(connection, accountId, options) {
          super(connection, accountId, options);
          this.helperUrl = "https://helper.testnet.near.org";
          this.helperUrl = options.helperUrl || this.helperUrl;
          this.storage = options.storage;
          this.sendCode = options.sendCode || this.sendCodeDefault;
          this.getCode = options.getCode || this.getCodeDefault;
          this.verifyCode = options.verifyCode || this.verifyCodeDefault;
          this.onConfirmResult = options.onConfirmResult;
        }
        /**
         * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
         *
         * @param options Options for the transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        signAndSendTransaction({ receiverId, actions }) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            yield _super.signAndSendTransaction.call(this, { receiverId, actions });
            yield this.sendCode();
            const result = yield this.promptAndVerify();
            if (this.onConfirmResult) {
              yield this.onConfirmResult(result);
            }
            return result;
          });
        }
        // default helpers for CH deployments of multisig
        /**
         * Deploy a multisig contract with 2FA and handle the deployment process.
         * @param contractBytes - The bytecode of the multisig contract.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.
         */
        deployMultisig(contractBytes) {
          const _super = Object.create(null, {
            signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const seedOrLedgerKey = (yield this.getRecoveryMethods()).data.filter(({ kind, publicKey }) => (kind === "phrase" || kind === "ledger") && publicKey !== null).map((rm) => rm.publicKey);
            const fak2lak = (yield this.getAccessKeys()).filter(({ public_key, access_key: { permission } }) => permission === "FullAccess" && !seedOrLedgerKey.includes(public_key)).map((ak) => ak.public_key).map(toPK);
            const confirmOnlyKey = toPK((yield this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
            const newArgs = Buffer.from(JSON.stringify({ "num_confirmations": 2 }));
            const actions = [
              ...fak2lak.map((pk) => deleteKey(pk)),
              ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),
              addKey(confirmOnlyKey, functionCallAccessKey(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),
              deployContract(contractBytes)
            ];
            const newFunctionCallActionBatch = actions.concat(functionCall("new", newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));
            utils_1.Logger.log("deploying multisig contract for", accountId);
            const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);
            switch (multisigStateStatus) {
              case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:
                return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);
              case types_2.MultisigStateStatus.VALID_STATE:
                return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);
              case types_2.MultisigStateStatus.INVALID_STATE:
                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
              default:
                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
            }
          });
        }
        /**
         * Disable 2FA with the option to clean up contract state.
         * @param options Options for disabling 2FA.
         * @param options.contractBytes The bytecode of the contract to deploy.
         * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
         */
        disableWithFAK({ contractBytes, cleanupContractBytes }) {
          return __awaiter6(this, void 0, void 0, function* () {
            let cleanupActions = [];
            if (cleanupContractBytes) {
              yield this.deleteAllRequests().catch((e) => e);
              cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);
            }
            const keyConversionActions = yield this.get2faDisableKeyConversionActions();
            const actions = [
              ...cleanupActions,
              ...keyConversionActions,
              deployContract(contractBytes)
            ];
            const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);
            if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== "FullAccess") {
              throw new types_1.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
            }
            return this.signAndSendTransactionWithAccount(this.accountId, actions);
          });
        }
        /**
         * Retrieves cleanup actions for disabling 2FA.
         * @param cleanupContractBytes - The bytecode of the cleanup contract.
         * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.
         */
        get2faDisableCleanupActions(cleanupContractBytes) {
          return __awaiter6(this, void 0, void 0, function* () {
            const currentAccountState = yield this.viewState("").catch((error2) => {
              const cause = error2.cause && error2.cause.name;
              if (cause == "NO_CONTRACT_CODE") {
                return [];
              }
              throw cause == "TOO_LARGE_CONTRACT_STATE" ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : error2;
            });
            const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString("base64"));
            return currentAccountState.length ? [
              deployContract(cleanupContractBytes),
              functionCall("clean", { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, BigInt("0"))
            ] : [];
          });
        }
        /**
         * Retrieves key conversion actions for disabling 2FA.
         * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.
         */
        get2faDisableKeyConversionActions() {
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const accessKeys = yield this.getAccessKeys();
            const lak2fak = accessKeys.filter(({ access_key }) => access_key.permission !== "FullAccess").filter(({ access_key }) => {
              const perm = access_key.permission.FunctionCall;
              return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes("add_request_and_confirm");
            });
            const confirmOnlyKey = crypto_1.PublicKey.from((yield this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
            return [
              deleteKey(confirmOnlyKey),
              ...lak2fak.map(({ public_key }) => deleteKey(crypto_1.PublicKey.from(public_key))),
              ...lak2fak.map(({ public_key }) => addKey(crypto_1.PublicKey.from(public_key), fullAccessKey()))
            ];
          });
        }
        /**
         * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
         * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
         * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
         */
        disable(contractBytes, cleanupContractBytes) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();
            if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {
              throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
            }
            let deleteAllRequestsError;
            yield this.deleteAllRequests().catch((e) => deleteAllRequestsError = e);
            const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch((e) => {
              if (e.type === "ContractHasExistingState") {
                throw deleteAllRequestsError || e;
              }
              throw e;
            });
            const actions = [
              ...cleanupActions,
              ...yield this.get2faDisableKeyConversionActions(),
              deployContract(contractBytes)
            ];
            utils_1.Logger.log("disabling 2fa for", this.accountId);
            return yield this.signAndSendTransaction({
              receiverId: this.accountId,
              actions
            });
          });
        }
        /**
         * Default implementation for sending the 2FA code.
         * @returns {Promise<string>} - A promise that resolves to the request ID.
         */
        sendCodeDefault() {
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const { requestId } = this.getRequest();
            const method2 = yield this.get2faMethod();
            yield this.postSignedJson("/2fa/send", {
              accountId,
              method: method2,
              requestId
            });
            return requestId;
          });
        }
        getCodeDefault() {
          return __awaiter6(this, void 0, void 0, function* () {
            throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
          });
        }
        /**
         * Prompts the user to enter and verify the 2FA code.
         * @returns {Promise<any>} - A promise that resolves to the verification result.
         */
        promptAndVerify() {
          return __awaiter6(this, void 0, void 0, function* () {
            const method2 = yield this.get2faMethod();
            const securityCode = yield this.getCode(method2);
            try {
              const result = yield this.verifyCode(securityCode);
              return result;
            } catch (e) {
              utils_1.Logger.warn("Error validating security code:", e);
              if (e.toString().includes("invalid 2fa code provided") || e.toString().includes("2fa code not valid")) {
                return yield this.promptAndVerify();
              }
              throw e;
            }
          });
        }
        /**
         * Verify the 2FA code using the default method.
         * @param securityCode - The security code to verify.
         * @returns {Promise<any>} A promise that resolves to the verification result.
         */
        verifyCodeDefault(securityCode) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const request3 = this.getRequest();
            if (!request3) {
              throw new Error("no request pending");
            }
            const { requestId } = request3;
            return yield this.postSignedJson("/2fa/verify", {
              accountId,
              securityCode,
              requestId
            });
          });
        }
        /**
         * Retrieves recovery methods for the account.
         * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.
         */
        getRecoveryMethods() {
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            return {
              accountId,
              data: yield this.postSignedJson("/account/recoveryMethods", { accountId })
            };
          });
        }
        /**
         * Gets the 2FA method (kind and detail).
         * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.
         */
        get2faMethod() {
          return __awaiter6(this, void 0, void 0, function* () {
            let { data: data7 } = yield this.getRecoveryMethods();
            if (data7 && data7.length) {
              data7 = data7.find((m) => m.kind.indexOf("2fa-") === 0);
            }
            if (!data7)
              return null;
            const { kind, detail } = data7;
            return { kind, detail };
          });
        }
        /**
        * Generates a signature for the latest finalized block.
        * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.
        */
        signatureFor() {
          return __awaiter6(this, void 0, void 0, function* () {
            const { accountId } = this;
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockNumber = block.header.height.toString();
            const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
            const blockNumberSignature = Buffer.from(signed.signature).toString("base64");
            return { blockNumber, blockNumberSignature };
          });
        }
        /**
        * Sends a signed JSON request to a specified path.
        * @param path - The path for the request.
        * @param body - The request body.
        * @returns {Promise<any>} - A promise that resolves to the response from the helper.
        */
        postSignedJson(path7, body) {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield (0, providers_1.fetchJson)(this.helperUrl + path7, JSON.stringify(Object.assign(Object.assign({}, body), yield this.signatureFor())));
          });
        }
      };
      exports2.Account2FA = Account2FA;
      var toPK = (pk) => crypto_1.PublicKey.from(pk);
    }
  });

  // node_modules/@near-js/accounts/lib/account_creator.js
  var require_account_creator = __commonJS({
    "node_modules/@near-js/accounts/lib/account_creator.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.UrlAccountCreator = exports2.LocalAccountCreator = exports2.AccountCreator = void 0;
      var providers_1 = require_lib18();
      var AccountCreator = class {
      };
      exports2.AccountCreator = AccountCreator;
      var LocalAccountCreator = class extends AccountCreator {
        constructor(masterAccount, initialBalance) {
          super();
          this.masterAccount = masterAccount;
          this.initialBalance = initialBalance;
        }
        /**
         * Creates an account using a masterAccount, meaning the new account is created from an existing account
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        createAccount(newAccountId, publicKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            yield this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
          });
        }
      };
      exports2.LocalAccountCreator = LocalAccountCreator;
      var UrlAccountCreator = class extends AccountCreator {
        constructor(connection, helperUrl) {
          super();
          this.connection = connection;
          this.helperUrl = helperUrl;
        }
        /**
         * Creates an account using a helperUrl
         * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        createAccount(newAccountId, publicKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            yield (0, providers_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));
          });
        }
      };
      exports2.UrlAccountCreator = UrlAccountCreator;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/constants.js
  var require_constants10 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/constants.js
  var require_constants11 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger9 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger5();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger10 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger9();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors13 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger10();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/assignable.js
  var require_assignable5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/errors.js
  var require_errors14 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/response.js
  var require_response5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/index.js
  var require_provider12 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client5();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response5();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/types/lib/index.js
  var require_lib19 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable5(), exports2);
      __exportStar(require_errors14(), exports2);
      __exportStar(require_provider12(), exports2);
    }
  });

  // node_modules/@near-js/signers/node_modules/base-x/index.js
  var require_base_x5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-js/signers/node_modules/bs58/index.js
  var require_bs585 = __commonJS({
    "node_modules/@near-js/signers/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x5();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/format.js
  var require_format6 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs585());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors6 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib19();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format6();
      var error_messages_json_1 = __importDefault(require_error_messages5());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema5());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors15 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors13();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors6();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logging.js
  var require_logging5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors15();
      var logger_1 = require_logger10();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/provider.js
  var require_provider13 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/utils.js
  var require_utils17 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/validators.js
  var require_validators5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils17();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/utils/lib/index.js
  var require_lib20 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants11(), exports2);
      __exportStar(require_errors15(), exports2);
      __exportStar(require_format6(), exports2);
      __exportStar(require_logging5(), exports2);
      __exportStar(require_provider13(), exports2);
      __exportStar(require_validators5(), exports2);
      __exportStar(require_logger10(), exports2);
      __exportStar(require_utils17(), exports2);
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
  var require_assert7 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
  var require_crypto7 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
  var require_utils18 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto7();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
  var require_sha27 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert7();
      var utils_js_1 = require_utils18();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js
  var require_u645 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js
  var require_sha5125 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha27();
      var _u64_js_1 = require_u645();
      var utils_js_1 = require_utils18();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/utils.js
  var require_utils19 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/modular.js
  var require_modular5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils19();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/curve.js
  var require_curve5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular5();
      var utils_js_1 = require_utils19();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular5();
      var ut = require_utils19();
      var utils_js_1 = require_utils19();
      var curve_js_1 = require_curve5();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular5();
      var utils_js_1 = require_utils19();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular5();
      var utils_js_1 = require_utils19();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/curves/ed25519.js
  var require_ed255195 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha5125();
      var utils_1 = require_utils18();
      var edwards_js_1 = require_edwards5();
      var montgomery_js_1 = require_montgomery5();
      var modular_js_1 = require_modular5();
      var utils_js_1 = require_utils19();
      var hash_to_curve_js_1 = require_hash_to_curve5();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key5 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib19();
      var utils_1 = require_lib20();
      var ed25519_1 = require_ed255195();
      var constants_1 = require_constants10();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed255195 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib20();
      var ed25519_1 = require_ed255195();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants10();
      var key_pair_base_1 = require_key_pair_base5();
      var public_key_1 = require_public_key5();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair6 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base5();
      var key_pair_ed25519_1 = require_key_pair_ed255195();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/index.js
  var require_lib21 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants10();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair6();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255195();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key5();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js
  var require_assert8 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js
  var require_crypto8 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js
  var require_utils20 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto8();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!isBytes(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js
  var require_sha28 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert8();
      var utils_js_1 = require_utils20();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js
  var require_sha2563 = __commonJS({
    "node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha224 = exports2.sha256 = void 0;
      var _sha2_js_1 = require_sha28();
      var utils_js_1 = require_utils20();
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // node_modules/@near-js/signers/lib/signer.js
  var require_signer = __commonJS({
    "node_modules/@near-js/signers/lib/signer.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signer = void 0;
      var Signer = class {
      };
      exports2.Signer = Signer;
    }
  });

  // node_modules/@near-js/signers/lib/in_memory_signer.js
  var require_in_memory_signer = __commonJS({
    "node_modules/@near-js/signers/lib/in_memory_signer.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InMemorySigner = void 0;
      var crypto_1 = require_lib21();
      var keystores_1 = require_lib4();
      var sha256_1 = require_sha2563();
      var signer_1 = require_signer();
      var InMemorySigner = class _InMemorySigner extends signer_1.Signer {
        constructor(keyStore) {
          super();
          this.keyStore = keyStore;
        }
        /**
         * Creates a single account Signer instance with account, network and keyPair provided.
         *
         * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
         *
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @param accountId The NEAR account to assign the key pair to
         * @param keyPair The keyPair to use for signing
         */
        static fromKeyPair(networkId, accountId, keyPair) {
          return __awaiter6(this, void 0, void 0, function* () {
            const keyStore = new keystores_1.InMemoryKeyStore();
            yield keyStore.setKey(networkId, accountId, keyPair);
            return new _InMemorySigner(keyStore);
          });
        }
        /**
         * Creates a public key for the account given
         * @param accountId The NEAR account to assign a public key to
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @returns {Promise<PublicKey>}
         */
        createKey(accountId, networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const keyPair = crypto_1.KeyPair.fromRandom("ed25519");
            yield this.keyStore.setKey(networkId, accountId, keyPair);
            return keyPair.getPublicKey();
          });
        }
        /**
         * Gets the existing public key for a given account
         * @param accountId The NEAR account to assign a public key to
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @returns {Promise<PublicKey>} Returns the public key or null if not found
         */
        getPublicKey(accountId, networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const keyPair = yield this.keyStore.getKey(networkId, accountId);
            if (keyPair === null) {
              return null;
            }
            return keyPair.getPublicKey();
          });
        }
        /**
         * @param message A message to be signed, typically a serialized transaction
         * @param accountId the NEAR account signing the message
         * @param networkId The targeted network. (ex. default, betanet, etc)
         * @returns {Promise<Signature>}
         */
        signMessage(message, accountId, networkId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const hash = new Uint8Array((0, sha256_1.sha256)(message));
            if (!accountId) {
              throw new Error("InMemorySigner requires provided account id");
            }
            const keyPair = yield this.keyStore.getKey(networkId, accountId);
            if (keyPair === null) {
              throw new Error(`Key for ${accountId} not found in ${networkId}`);
            }
            return keyPair.sign(hash);
          });
        }
        toString() {
          return `InMemorySigner(${this.keyStore})`;
        }
      };
      exports2.InMemorySigner = InMemorySigner;
    }
  });

  // node_modules/@near-js/signers/lib/index.js
  var require_lib22 = __commonJS({
    "node_modules/@near-js/signers/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signer = exports2.InMemorySigner = void 0;
      var in_memory_signer_1 = require_in_memory_signer();
      Object.defineProperty(exports2, "InMemorySigner", { enumerable: true, get: function() {
        return in_memory_signer_1.InMemorySigner;
      } });
      var signer_1 = require_signer();
      Object.defineProperty(exports2, "Signer", { enumerable: true, get: function() {
        return signer_1.Signer;
      } });
    }
  });

  // node_modules/@near-js/accounts/lib/connection.js
  var require_connection = __commonJS({
    "node_modules/@near-js/accounts/lib/connection.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Connection = void 0;
      var signers_1 = require_lib22();
      var providers_1 = require_lib18();
      function getProvider(config4) {
        switch (config4.type) {
          case void 0:
            return config4;
          case "JsonRpcProvider":
            return new providers_1.JsonRpcProvider(Object.assign({}, config4.args));
          case "FailoverRpcProvider": {
            const providers4 = ((config4 === null || config4 === void 0 ? void 0 : config4.args) || []).map((arg) => new providers_1.JsonRpcProvider(arg));
            return new providers_1.FailoverRpcProvider(providers4);
          }
          default:
            throw new Error(`Unknown provider type ${config4.type}`);
        }
      }
      function getSigner(config4) {
        switch (config4.type) {
          case void 0:
            return config4;
          case "InMemorySigner": {
            return new signers_1.InMemorySigner(config4.keyStore);
          }
          default:
            throw new Error(`Unknown signer type ${config4.type}`);
        }
      }
      var Connection = class _Connection {
        constructor(networkId, provider, signer, jsvmAccountId) {
          this.networkId = networkId;
          this.provider = provider;
          this.signer = signer;
          this.jsvmAccountId = jsvmAccountId;
        }
        getConnection() {
          return this;
        }
        /**
         * @param config Contains connection info details
         */
        static fromConfig(config4) {
          const provider = getProvider(config4.provider);
          const signer = getSigner(config4.signer);
          return new _Connection(config4.networkId, provider, signer, config4.jsvmAccountId);
        }
      };
      exports2.Connection = Connection;
    }
  });

  // node_modules/lru_map/dist/lru.js
  var require_lru = __commonJS({
    "node_modules/lru_map/dist/lru.js"(exports2, module2) {
      init_process();
      init_buffer();
      !(function(g, c) {
        typeof exports2 == "object" && typeof module2 != "undefined" ? c(exports2) : typeof define == "function" && define.amd ? define(["exports"], c) : c((g = g || self).lru_map = g.lru_map || {});
      })(exports2, function(g) {
        const c = Symbol("newer"), e = Symbol("older");
        class n {
          constructor(a, b) {
            typeof a !== "number" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));
          }
          _markEntryAsUsed(a) {
            if (a === this.newest) return;
            a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;
          }
          assign(a) {
            let b, d = this.limit || Number.MAX_VALUE;
            this._keymap.clear();
            let m = a[Symbol.iterator]();
            for (let h = m.next(); !h.done; h = m.next()) {
              let f = new l(h.value[0], h.value[1]);
              this._keymap.set(f.key, f), b ? (b[c] = f, f[e] = b) : this.oldest = f, b = f;
              if (d-- == 0) throw new Error("overflow");
            }
            this.newest = b, this.size = this._keymap.size;
          }
          get(a) {
            var b = this._keymap.get(a);
            return b ? (this._markEntryAsUsed(b), b.value) : void 0;
          }
          set(a, b) {
            var d = this._keymap.get(a);
            return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);
          }
          shift() {
            var a = this.oldest;
            if (a) return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];
          }
          find(a) {
            let b = this._keymap.get(a);
            return b ? b.value : void 0;
          }
          has(a) {
            return this._keymap.has(a);
          }
          delete(a) {
            var b = this._keymap.get(a);
            return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
          }
          clear() {
            this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
          }
          keys() {
            return new j(this.oldest);
          }
          values() {
            return new k(this.oldest);
          }
          entries() {
            return this;
          }
          [Symbol.iterator]() {
            return new i(this.oldest);
          }
          forEach(a, b) {
            typeof b !== "object" && (b = this);
            let d = this.oldest;
            for (; d; ) a.call(b, d.value, d.key, this), d = d[c];
          }
          toJSON() {
            for (var a = new Array(this.size), b = 0, d = this.oldest; d; ) a[b++] = { key: d.key, value: d.value }, d = d[c];
            return a;
          }
          toString() {
            for (var a = "", b = this.oldest; b; ) a += String(b.key) + ":" + b.value, b = b[c], b && (a += " < ");
            return a;
          }
        }
        g.LRUMap = n;
        function l(a, b) {
          this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;
        }
        function i(a) {
          this.entry = a;
        }
        i.prototype[Symbol.iterator] = function() {
          return this;
        }, i.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: [a.key, a.value] }) : { done: true, value: void 0 };
        };
        function j(a) {
          this.entry = a;
        }
        j.prototype[Symbol.iterator] = function() {
          return this;
        }, j.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: a.key }) : { done: true, value: void 0 };
        };
        function k(a) {
          this.entry = a;
        }
        k.prototype[Symbol.iterator] = function() {
          return this;
        }, k.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: a.value }) : { done: true, value: void 0 };
        };
      });
    }
  });

  // node_modules/@near-js/accounts/lib/local-view-execution/storage.js
  var require_storage = __commonJS({
    "node_modules/@near-js/accounts/lib/local-view-execution/storage.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Storage = void 0;
      var lru_map_1 = require_lru();
      var Storage = class _Storage {
        constructor(options = { max: _Storage.MAX_ELEMENTS }) {
          this.cache = new lru_map_1.LRUMap(options.max);
          this.blockHeights = /* @__PURE__ */ new Map();
        }
        load(blockRef) {
          const noBlockId = !("blockId" in blockRef);
          if (noBlockId)
            return void 0;
          let blockId = blockRef.blockId;
          if (blockId.toString().length == 44) {
            blockId = this.blockHeights.get(blockId.toString());
          }
          return this.cache.get(blockId);
        }
        save(blockHash, { blockHeight, blockTimestamp, contractCode, contractState }) {
          this.blockHeights.set(blockHash, blockHeight);
          this.cache.set(blockHeight, { blockHeight, blockTimestamp, contractCode, contractState });
        }
      };
      exports2.Storage = Storage;
      Storage.MAX_ELEMENTS = 100;
    }
  });

  // node-modules-polyfills:crypto
  var crypto_exports = {};
  __export(crypto_exports, {
    default: () => crypto_default
  });
  var crypto_default;
  var init_crypto = __esm({
    "node-modules-polyfills:crypto"() {
      init_process();
      init_buffer();
      crypto_default = {};
    }
  });

  // node-modules-polyfills-commonjs:crypto
  var require_crypto9 = __commonJS({
    "node-modules-polyfills-commonjs:crypto"(exports2, module2) {
      init_process();
      init_buffer();
      var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k in polyfill) {
          module2.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/@near-js/accounts/lib/local-view-execution/runtime.js
  var require_runtime = __commonJS({
    "node_modules/@near-js/accounts/lib/local-view-execution/runtime.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Runtime = void 0;
      var crypto_1 = require_crypto9();
      var notImplemented = (name) => () => {
        throw new Error("method not implemented: " + name);
      };
      var prohibitedInView = (name) => () => {
        throw new Error("method not available for view calls: " + name);
      };
      var Runtime = class {
        constructor(_a) {
          var { contractCode } = _a, context2 = __rest(_a, ["contractCode"]);
          this.context = context2;
          this.wasm = this.prepareWASM(Buffer.from(contractCode, "base64"));
          this.memory = new WebAssembly.Memory({ initial: 1024, maximum: 2048 });
          this.registers = {};
          this.logs = [];
          this.result = Buffer.from([]);
        }
        readUTF16CStr(ptr) {
          const arr = [];
          const mem = new Uint16Array(this.memory.buffer);
          let key = Number(ptr) / 2;
          while (mem[key] != 0) {
            arr.push(mem[key]);
            key++;
          }
          return Buffer.from(Uint16Array.from(arr).buffer).toString("ucs2");
        }
        readUTF8CStr(len, ptr) {
          const arr = [];
          const mem = new Uint8Array(this.memory.buffer);
          let key = Number(ptr);
          for (let i = 0; i < len && mem[key] != 0; i++) {
            arr.push(mem[key]);
            key++;
          }
          return Buffer.from(arr).toString("utf8");
        }
        storageRead(keyLen, keyPtr) {
          const storageKey = Buffer.from(new Uint8Array(this.memory.buffer, Number(keyPtr), Number(keyLen)));
          const stateVal = this.context.contractState.filter((obj) => Buffer.compare(obj.key, storageKey) === 0).map((obj) => obj.value);
          if (stateVal.length === 0)
            return null;
          return stateVal.length > 1 ? stateVal : stateVal[0];
        }
        prepareWASM(input) {
          const parts = [];
          const magic = input.subarray(0, 4);
          if (magic.toString("utf8") !== "\0asm") {
            throw new Error("Invalid magic number");
          }
          const version7 = input.readUInt32LE(4);
          if (version7 != 1) {
            throw new Error("Invalid version: " + version7);
          }
          let offset = 8;
          parts.push(input.subarray(0, offset));
          function decodeLEB128() {
            let result = 0;
            let shift = 0;
            let byte;
            do {
              byte = input[offset++];
              result |= (byte & 127) << shift;
              shift += 7;
            } while (byte & 128);
            return result;
          }
          function decodeLimits() {
            const flags6 = input[offset++];
            const hasMax = flags6 & 1;
            const initial = decodeLEB128();
            const max7 = hasMax ? decodeLEB128() : null;
            return { initial, max: max7 };
          }
          function decodeString() {
            const length = decodeLEB128();
            const result = input.subarray(offset, offset + length);
            offset += length;
            return result.toString("utf8");
          }
          function encodeLEB128(value) {
            const result = [];
            do {
              let byte = value & 127;
              value >>= 7;
              if (value !== 0) {
                byte |= 128;
              }
              result.push(byte);
            } while (value !== 0);
            return Buffer.from(result);
          }
          function encodeString(value) {
            const result = Buffer.from(value, "utf8");
            return Buffer.concat([encodeLEB128(result.length), result]);
          }
          do {
            const sectionStart = offset;
            const sectionId = input.readUInt8(offset);
            offset++;
            const sectionSize = decodeLEB128();
            const sectionEnd = offset + sectionSize;
            if (sectionId == 5) {
              parts.push(Buffer.from([5, 1, 0]));
            } else if (sectionId == 2) {
              const sectionParts = [];
              const numImports = decodeLEB128();
              for (let i = 0; i < numImports; i++) {
                const importStart = offset;
                decodeString();
                decodeString();
                const kind = input.readUInt8(offset);
                offset++;
                let skipImport = false;
                switch (kind) {
                  case 0:
                    decodeLEB128();
                    break;
                  case 1:
                    offset++;
                    decodeLimits();
                    break;
                  case 2:
                    decodeLimits();
                    skipImport = true;
                    break;
                  case 3:
                    offset++;
                    offset++;
                    break;
                  default:
                    throw new Error("Invalid import kind: " + kind);
                }
                if (!skipImport) {
                  sectionParts.push(input.subarray(importStart, offset));
                }
              }
              const importMemory = Buffer.concat([
                encodeString("env"),
                encodeString("memory"),
                Buffer.from([2]),
                Buffer.from([0]),
                encodeLEB128(1)
              ]);
              sectionParts.push(importMemory);
              const sectionData = Buffer.concat([
                encodeLEB128(sectionParts.length),
                ...sectionParts
              ]);
              parts.push(Buffer.concat([
                Buffer.from([2]),
                encodeLEB128(sectionData.length),
                sectionData
              ]));
            } else if (sectionId == 7) {
              const sectionParts = [];
              const numExports = decodeLEB128();
              for (let i = 0; i < numExports; i++) {
                const exportStart = offset;
                decodeString();
                const kind = input.readUInt8(offset);
                offset++;
                decodeLEB128();
                if (kind !== 2) {
                  sectionParts.push(input.subarray(exportStart, offset));
                }
              }
              const sectionData = Buffer.concat([
                encodeLEB128(sectionParts.length),
                ...sectionParts
              ]);
              parts.push(Buffer.concat([
                Buffer.from([7]),
                encodeLEB128(sectionData.length),
                sectionData
              ]));
            } else {
              parts.push(input.subarray(sectionStart, sectionEnd));
            }
            offset = sectionEnd;
          } while (offset < input.length);
          return Buffer.concat(parts);
        }
        // Host functions
        getRegisterLength(registerId) {
          return BigInt(this.registers[registerId.toString()] ? this.registers[registerId.toString()].length : Number.MAX_SAFE_INTEGER);
        }
        readFromRegister(registerId, ptr) {
          const mem = new Uint8Array(this.memory.buffer);
          mem.set(this.registers[registerId.toString()] || Buffer.from([]), Number(ptr));
        }
        getCurrentAccountId(registerId) {
          this.registers[registerId.toString()] = Buffer.from(this.context.contractId);
        }
        inputMethodArgs(registerId) {
          this.registers[registerId.toString()] = Buffer.from(this.context.methodArgs);
        }
        getBlockHeight() {
          return BigInt(this.context.blockHeight);
        }
        getBlockTimestamp() {
          return BigInt(this.context.blockTimestamp);
        }
        sha256(valueLen, valuePtr, registerId) {
          const value = new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen));
          const hash = (0, crypto_1.createHash)("sha256");
          hash.update(value);
          this.registers[registerId.toString()] = hash.digest();
        }
        returnValue(valueLen, valuePtr) {
          this.result = Buffer.from(new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen)));
        }
        panic(message) {
          throw new Error("panic: " + message);
        }
        abort(msg_ptr, filename_ptr, line, col) {
          const msg = this.readUTF16CStr(msg_ptr);
          const filename = this.readUTF16CStr(filename_ptr);
          const message = `${msg} ${filename}:${line}:${col}`;
          if (!msg || !filename) {
            throw new Error("abort: String encoding is bad UTF-16 sequence.");
          }
          throw new Error("abort: " + message);
        }
        appendToLog(len, ptr) {
          this.logs.push(this.readUTF8CStr(len, ptr));
        }
        readStorage(key_len, key_ptr, register_id) {
          const result = this.storageRead(key_len, key_ptr);
          if (result == null) {
            return BigInt(0);
          }
          this.registers[register_id] = result;
          return BigInt(1);
        }
        hasStorageKey(key_len, key_ptr) {
          const result = this.storageRead(key_len, key_ptr);
          if (result == null) {
            return BigInt(0);
          }
          return BigInt(1);
        }
        getHostImports() {
          return {
            register_len: this.getRegisterLength.bind(this),
            read_register: this.readFromRegister.bind(this),
            current_account_id: this.getCurrentAccountId.bind(this),
            input: this.inputMethodArgs.bind(this),
            block_index: this.getBlockHeight.bind(this),
            block_timestamp: this.getBlockTimestamp.bind(this),
            sha256: this.sha256.bind(this),
            value_return: this.returnValue.bind(this),
            abort: this.abort.bind(this),
            log_utf8: this.appendToLog.bind(this),
            log_utf16: this.appendToLog.bind(this),
            storage_read: this.readStorage.bind(this),
            storage_has_key: this.hasStorageKey.bind(this),
            panic: () => this.panic("explicit guest panic"),
            panic_utf8: (len, ptr) => this.panic(this.readUTF8CStr(len, ptr)),
            // Not implemented
            epoch_height: notImplemented("epoch_height"),
            storage_usage: notImplemented("storage_usage"),
            account_balance: notImplemented("account_balance"),
            account_locked_balance: notImplemented("account_locked_balance"),
            random_seed: notImplemented("random_seed"),
            ripemd160: notImplemented("ripemd160"),
            keccak256: notImplemented("keccak256"),
            keccak512: notImplemented("keccak512"),
            ecrecover: notImplemented("ecrecover"),
            validator_stake: notImplemented("validator_stake"),
            validator_total_stake: notImplemented("validator_total_stake"),
            // Prohibited
            write_register: prohibitedInView("write_register"),
            signer_account_id: prohibitedInView("signer_account_id"),
            signer_account_pk: prohibitedInView("signer_account_pk"),
            predecessor_account_id: prohibitedInView("predecessor_account_id"),
            attached_deposit: prohibitedInView("attached_deposit"),
            prepaid_gas: prohibitedInView("prepaid_gas"),
            used_gas: prohibitedInView("used_gas"),
            promise_create: prohibitedInView("promise_create"),
            promise_then: prohibitedInView("promise_then"),
            promise_and: prohibitedInView("promise_and"),
            promise_batch_create: prohibitedInView("promise_batch_create"),
            promise_batch_then: prohibitedInView("promise_batch_then"),
            promise_batch_action_create_account: prohibitedInView("promise_batch_action_create_account"),
            promise_batch_action_deploy_contract: prohibitedInView("promise_batch_action_deploy_contract"),
            promise_batch_action_function_call: prohibitedInView("promise_batch_action_function_call"),
            promise_batch_action_function_call_weight: prohibitedInView("promise_batch_action_function_call_weight"),
            promise_batch_action_transfer: prohibitedInView("promise_batch_action_transfer"),
            promise_batch_action_stake: prohibitedInView("promise_batch_action_stake"),
            promise_batch_action_add_key_with_full_access: prohibitedInView("promise_batch_action_add_key_with_full_access"),
            promise_batch_action_add_key_with_function_call: prohibitedInView("promise_batch_action_add_key_with_function_call"),
            promise_batch_action_delete_key: prohibitedInView("promise_batch_action_delete_key"),
            promise_batch_action_delete_account: prohibitedInView("promise_batch_action_delete_account"),
            promise_results_count: prohibitedInView("promise_results_count"),
            promise_result: prohibitedInView("promise_result"),
            promise_return: prohibitedInView("promise_return"),
            storage_write: prohibitedInView("storage_write"),
            storage_remove: prohibitedInView("storage_remove")
          };
        }
        execute(methodName) {
          return __awaiter6(this, void 0, void 0, function* () {
            const module3 = yield WebAssembly.compile(this.wasm);
            const instance = yield WebAssembly.instantiate(module3, { env: Object.assign(Object.assign({}, this.getHostImports()), { memory: this.memory }) });
            const callMethod = instance.exports[methodName];
            if (callMethod == void 0) {
              throw new Error(`Contract method '${methodName}' does not exists in contract ${this.context.contractId} for block id ${this.context.blockHeight}`);
            }
            callMethod();
            return {
              result: this.result,
              logs: this.logs
            };
          });
        }
      };
      exports2.Runtime = Runtime;
    }
  });

  // node_modules/@near-js/accounts/lib/local-view-execution/index.js
  var require_local_view_execution = __commonJS({
    "node_modules/@near-js/accounts/lib/local-view-execution/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LocalViewExecution = void 0;
      var utils_1 = require_lib15();
      var storage_1 = require_storage();
      var runtime_1 = require_runtime();
      var utils_2 = require_utils16();
      var LocalViewExecution = class {
        constructor(connection) {
          this.connection = connection.getConnection();
          this.storage = new storage_1.Storage();
        }
        fetchContractCode(contractId, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = yield this.connection.provider.query(Object.assign({ request_type: "view_code", account_id: contractId }, blockQuery));
            return result.code_base64;
          });
        }
        fetchContractState(contractId, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            return (0, utils_2.viewState)(this.connection, contractId, "", blockQuery);
          });
        }
        fetch(contractId, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const block = yield this.connection.provider.block(blockQuery);
            const blockHash = block.header.hash;
            const blockHeight = block.header.height;
            const blockTimestamp = block.header.timestamp;
            const contractCode = yield this.fetchContractCode(contractId, blockQuery);
            const contractState = yield this.fetchContractState(contractId, blockQuery);
            return {
              blockHash,
              blockHeight,
              blockTimestamp,
              contractCode,
              contractState
            };
          });
        }
        loadOrFetch(contractId, blockQuery) {
          return __awaiter6(this, void 0, void 0, function* () {
            const stored = this.storage.load(blockQuery);
            if (stored) {
              return stored;
            }
            const _a = yield this.fetch(contractId, blockQuery), { blockHash } = _a, fetched = __rest(_a, ["blockHash"]);
            this.storage.save(blockHash, fetched);
            return fetched;
          });
        }
        /**
         * Calls a view function on a contract, fetching the contract code and state if needed.
         * @param options Options for calling the view function.
         * @param options.contractId The contract account ID.
         * @param options.methodName The name of the view function to call.
         * @param options.args The arguments to pass to the view function.
         * @param options.blockQuery The block query options.
         * @returns {Promise<any>} - A promise that resolves to the result of the view function.
         */
        viewFunction(_a) {
          var { contractId, methodName, args = {}, blockQuery = { finality: "optimistic" } } = _a, ignored = __rest(_a, ["contractId", "methodName", "args", "blockQuery"]);
          return __awaiter6(this, void 0, void 0, function* () {
            const methodArgs = JSON.stringify(args);
            const { contractCode, contractState, blockHeight, blockTimestamp } = yield this.loadOrFetch(contractId, blockQuery);
            const runtime = new runtime_1.Runtime({ contractId, contractCode, contractState, blockHeight, blockTimestamp, methodArgs });
            const { result, logs } = yield runtime.execute(methodName);
            if (logs) {
              (0, utils_1.printTxOutcomeLogs)({ contractId, logs });
            }
            return JSON.parse(Buffer.from(result).toString());
          });
        }
      };
      exports2.LocalViewExecution = LocalViewExecution;
    }
  });

  // node_modules/is-property/is-property.js
  var require_is_property = __commonJS({
    "node_modules/is-property/is-property.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      function isProperty(str) {
        return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str);
      }
      module2.exports = isProperty;
    }
  });

  // node_modules/generate-object-property/index.js
  var require_generate_object_property = __commonJS({
    "node_modules/generate-object-property/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var isProperty = require_is_property();
      var gen = function(obj, prop) {
        return isProperty(prop) ? obj + "." + prop : obj + "[" + JSON.stringify(prop) + "]";
      };
      gen.valid = isProperty;
      gen.property = function(prop) {
        return isProperty(prop) ? prop : JSON.stringify(prop);
      };
      module2.exports = gen;
    }
  });

  // node-modules-polyfills-commonjs:util
  var require_util = __commonJS({
    "node-modules-polyfills-commonjs:util"(exports2, module2) {
      init_process();
      init_buffer();
      var polyfill = (init_util(), __toCommonJS(util_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k in polyfill) {
          module2.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/generate-function/index.js
  var require_generate_function = __commonJS({
    "node_modules/generate-function/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var util = require_util();
      var isProperty = require_is_property();
      var INDENT_START = /[\{\[]/;
      var INDENT_END = /[\}\]]/;
      var RESERVED = [
        "do",
        "if",
        "in",
        "for",
        "let",
        "new",
        "try",
        "var",
        "case",
        "else",
        "enum",
        "eval",
        "null",
        "this",
        "true",
        "void",
        "with",
        "await",
        "break",
        "catch",
        "class",
        "const",
        "false",
        "super",
        "throw",
        "while",
        "yield",
        "delete",
        "export",
        "import",
        "public",
        "return",
        "static",
        "switch",
        "typeof",
        "default",
        "extends",
        "finally",
        "package",
        "private",
        "continue",
        "debugger",
        "function",
        "arguments",
        "interface",
        "protected",
        "implements",
        "instanceof",
        "NaN",
        "undefined"
      ];
      var RESERVED_MAP = {};
      for (i = 0; i < RESERVED.length; i++) {
        RESERVED_MAP[RESERVED[i]] = true;
      }
      var i;
      var isVariable = function(name) {
        return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
      };
      var formats = {
        s: function(s) {
          return "" + s;
        },
        d: function(d) {
          return "" + Number(d);
        },
        o: function(o) {
          return JSON.stringify(o);
        }
      };
      var genfun = function() {
        var lines = [];
        var indent = 0;
        var vars = {};
        var push2 = function(str) {
          var spaces = "";
          while (spaces.length < indent * 2) spaces += "  ";
          lines.push(spaces + str);
        };
        var pushLine = function(line2) {
          if (INDENT_END.test(line2.trim()[0]) && INDENT_START.test(line2[line2.length - 1])) {
            indent--;
            push2(line2);
            indent++;
            return;
          }
          if (INDENT_START.test(line2[line2.length - 1])) {
            push2(line2);
            indent++;
            return;
          }
          if (INDENT_END.test(line2.trim()[0])) {
            indent--;
            push2(line2);
            return;
          }
          push2(line2);
        };
        var line = function(fmt) {
          if (!fmt) return line;
          if (arguments.length === 1 && fmt.indexOf("\n") > -1) {
            var lines2 = fmt.trim().split("\n");
            for (var i2 = 0; i2 < lines2.length; i2++) {
              pushLine(lines2[i2].trim());
            }
          } else {
            pushLine(util.format.apply(util, arguments));
          }
          return line;
        };
        line.scope = {};
        line.formats = formats;
        line.sym = function(name) {
          if (!name || !isVariable(name)) name = "tmp";
          if (!vars[name]) vars[name] = 0;
          return name + (vars[name]++ || "");
        };
        line.property = function(obj, name) {
          if (arguments.length === 1) {
            name = obj;
            obj = "";
          }
          name = name + "";
          if (isProperty(name)) return obj ? obj + "." + name : name;
          return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
        };
        line.toString = function() {
          return lines.join("\n");
        };
        line.toFunction = function(scope) {
          if (!scope) scope = {};
          var src = "return (" + line.toString() + ")";
          Object.keys(line.scope).forEach(function(key) {
            if (!scope[key]) scope[key] = line.scope[key];
          });
          var keys14 = Object.keys(scope).map(function(key) {
            return key;
          });
          var vals = keys14.map(function(key) {
            return scope[key];
          });
          return Function.apply(null, keys14.concat(src)).apply(null, vals);
        };
        if (arguments.length) line.apply(null, arguments);
        return line;
      };
      genfun.formats = formats;
      module2.exports = genfun;
    }
  });

  // node_modules/jsonpointer/jsonpointer.js
  var require_jsonpointer = __commonJS({
    "node_modules/jsonpointer/jsonpointer.js"(exports2) {
      init_process();
      init_buffer();
      var hasExcape = /~/;
      var escapeMatcher = /~[01]/g;
      function escapeReplacer(m) {
        switch (m) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Invalid tilde escape: " + m);
      }
      function untilde(str) {
        if (!hasExcape.test(str)) return str;
        return str.replace(escapeMatcher, escapeReplacer);
      }
      function setter(obj, pointer, value) {
        var part;
        var hasNextPart;
        for (var p = 1, len = pointer.length; p < len; ) {
          if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
          part = untilde(pointer[p++]);
          hasNextPart = len > p;
          if (typeof obj[part] === "undefined") {
            if (Array.isArray(obj) && part === "-") {
              part = obj.length;
            }
            if (hasNextPart) {
              if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
              else obj[part] = {};
            }
          }
          if (!hasNextPart) break;
          obj = obj[part];
        }
        var oldValue = obj[part];
        if (value === void 0) delete obj[part];
        else obj[part] = value;
        return oldValue;
      }
      function compilePointer(pointer) {
        if (typeof pointer === "string") {
          pointer = pointer.split("/");
          if (pointer[0] === "") return pointer;
          throw new Error("Invalid JSON pointer.");
        } else if (Array.isArray(pointer)) {
          for (const part of pointer) {
            if (typeof part !== "string" && typeof part !== "number") {
              throw new Error("Invalid JSON pointer. Must be of type string or number.");
            }
          }
          return pointer;
        }
        throw new Error("Invalid JSON pointer.");
      }
      function get10(obj, pointer) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        var len = pointer.length;
        if (len === 1) return obj;
        for (var p = 1; p < len; ) {
          obj = obj[untilde(pointer[p++])];
          if (len === p) return obj;
          if (typeof obj !== "object" || obj === null) return void 0;
        }
      }
      function set9(obj, pointer, value) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
        return setter(obj, pointer, value);
      }
      function compile(pointer) {
        var compiled = compilePointer(pointer);
        return {
          get: function(object) {
            return get10(object, compiled);
          },
          set: function(object, value) {
            return set9(object, compiled, value);
          }
        };
      }
      exports2.get = get10;
      exports2.set = set9;
      exports2.compile = compile;
    }
  });

  // node_modules/xtend/immutable.js
  var require_immutable = __commonJS({
    "node_modules/xtend/immutable.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = extend;
      var hasOwnProperty9 = Object.prototype.hasOwnProperty;
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (hasOwnProperty9.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }
    }
  });

  // node_modules/is-my-ip-valid/index.js
  var require_is_my_ip_valid = __commonJS({
    "node_modules/is-my-ip-valid/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var reIpv4FirstPass = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      var reSubnetString = /\/\d{1,3}(?=%|$)/;
      var reForwardSlash = /\//;
      var reZone = /%.*$/;
      var reBadCharacters = /([^0-9a-f:/%])/i;
      var reBadAddress = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;
      function validate4(input) {
        if (!reIpv4FirstPass.test(input)) return false;
        var parts = input.split(".");
        if (parts.length !== 4) return false;
        if (parts[0][0] === "0" && parts[0].length > 1) return false;
        if (parts[1][0] === "0" && parts[1].length > 1) return false;
        if (parts[2][0] === "0" && parts[2].length > 1) return false;
        if (parts[3][0] === "0" && parts[3].length > 1) return false;
        var n0 = Number(parts[0]);
        var n1 = Number(parts[1]);
        var n2 = Number(parts[2]);
        var n3 = Number(parts[3]);
        return n0 >= 0 && n0 < 256 && n1 >= 0 && n1 < 256 && n2 >= 0 && n2 < 256 && n3 >= 0 && n3 < 256;
      }
      function validate6(input) {
        var withoutSubnet = input.replace(reSubnetString, "");
        var hasSubnet = input.length !== withoutSubnet.length;
        if (hasSubnet) return false;
        if (!hasSubnet) {
          if (reForwardSlash.test(input)) return false;
        }
        var withoutZone = withoutSubnet.replace(reZone, "");
        var lastPartSeparator = withoutZone.lastIndexOf(":");
        if (lastPartSeparator === -1) return false;
        var lastPart = withoutZone.substring(lastPartSeparator + 1);
        var hasV4Part = validate4(lastPart);
        var address = hasV4Part ? withoutZone.substring(0, lastPartSeparator + 1) + "1234:5678" : withoutZone;
        if (reBadCharacters.test(address)) return false;
        if (reBadAddress.test(address)) return false;
        var halves = address.split("::");
        if (halves.length > 2) return false;
        if (halves.length === 2) {
          var first = halves[0] === "" ? [] : halves[0].split(":");
          var last5 = halves[1] === "" ? [] : halves[1].split(":");
          var remainingLength = 8 - (first.length + last5.length);
          if (remainingLength <= 0) return false;
        } else {
          if (address.split(":").length !== 8) return false;
        }
        return true;
      }
      function validate(input) {
        return validate4(input) || validate6(input);
      }
      module2.exports = function validator(options) {
        if (!options) options = {};
        if (options.version === 4) return validate4;
        if (options.version === 6) return validate6;
        if (options.version == null) return validate;
        throw new Error("Unknown version: " + options.version);
      };
      module2.exports["__all_regexes__"] = [
        reIpv4FirstPass,
        reSubnetString,
        reForwardSlash,
        reZone,
        reBadCharacters,
        reBadAddress
      ];
    }
  });

  // node_modules/is-my-json-valid/formats.js
  var require_formats = __commonJS({
    "node_modules/is-my-json-valid/formats.js"(exports2) {
      init_process();
      init_buffer();
      var createIpValidator = require_is_my_ip_valid();
      var reEmailWhitespace = /\s/;
      var reHostnameFirstPass = /^[a-zA-Z0-9.-]+$/;
      var reHostnamePart = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/;
      var rePhoneFirstPass = /^\+[0-9][0-9 ]{5,27}[0-9]$/;
      var rePhoneDoubleSpace = / {2}/;
      var rePhoneGlobalSpace = / /g;
      exports2["date-time"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(?:\.\d+|)([zZ]|[+-]\d{2}:\d{2})$/;
      exports2["date"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/;
      exports2["time"] = /^\d{2}:\d{2}:\d{2}$/;
      exports2["email"] = function(input) {
        return input.indexOf("@") !== -1 && !reEmailWhitespace.test(input);
      };
      exports2["ip-address"] = exports2["ipv4"] = createIpValidator({ version: 4 });
      exports2["ipv6"] = createIpValidator({ version: 6 });
      exports2["uri"] = /^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/;
      exports2["color"] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/;
      exports2["hostname"] = function(input) {
        if (!reHostnameFirstPass.test(input)) return false;
        var parts = input.split(".");
        for (var i = 0; i < parts.length; i++) {
          if (!reHostnamePart.test(parts[i])) return false;
        }
        return true;
      };
      exports2["alpha"] = /^[a-zA-Z]+$/;
      exports2["alphanumeric"] = /^[a-zA-Z0-9]+$/;
      exports2["style"] = /.:\s*[^;]/g;
      exports2["phone"] = function(input) {
        if (!rePhoneFirstPass.test(input)) return false;
        if (rePhoneDoubleSpace.test(input)) return false;
        var digits = input.substring(1).replace(rePhoneGlobalSpace, "").length;
        return digits >= 7 && digits <= 15;
      };
      exports2["utc-millisec"] = /^[0-9]{1,15}\.?[0-9]{0,15}$/;
    }
  });

  // node_modules/is-my-json-valid/index.js
  var require_is_my_json_valid = __commonJS({
    "node_modules/is-my-json-valid/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var genobj = require_generate_object_property();
      var genfun = require_generate_function();
      var jsonpointer = require_jsonpointer();
      var xtend = require_immutable();
      var formats = require_formats();
      var get10 = function(obj, additionalSchemas, ptr) {
        var visit = function(sub) {
          if (sub && sub.id === ptr) return sub;
          if (typeof sub !== "object" || !sub) return null;
          return Object.keys(sub).reduce(function(res2, k) {
            return res2 || visit(sub[k]);
          }, null);
        };
        var res = visit(obj);
        if (res) return res;
        ptr = ptr.replace(/^#/, "");
        ptr = ptr.replace(/\/$/, "");
        try {
          return jsonpointer.get(obj, decodeURI(ptr));
        } catch (err) {
          var end = ptr.indexOf("#");
          var other;
          if (end !== 0) {
            if (end === -1) {
              other = additionalSchemas[ptr];
            } else {
              var ext = ptr.slice(0, end);
              other = additionalSchemas[ext];
              var fragment = ptr.slice(end).replace(/^#/, "");
              try {
                return jsonpointer.get(other, fragment);
              } catch (err2) {
              }
            }
          } else {
            other = additionalSchemas[ptr];
          }
          return other || null;
        }
      };
      var types = {};
      types.any = function() {
        return "true";
      };
      types.null = function(name) {
        return name + " === null";
      };
      types.boolean = function(name) {
        return "typeof " + name + ' === "boolean"';
      };
      types.array = function(name) {
        return "Array.isArray(" + name + ")";
      };
      types.object = function(name) {
        return "typeof " + name + ' === "object" && ' + name + " && !Array.isArray(" + name + ")";
      };
      types.number = function(name) {
        return "typeof " + name + ' === "number" && isFinite(' + name + ")";
      };
      types.integer = function(name) {
        return "typeof " + name + ' === "number" && (Math.floor(' + name + ") === " + name + " || " + name + " > 9007199254740992 || " + name + " < -9007199254740992)";
      };
      types.string = function(name) {
        return "typeof " + name + ' === "string"';
      };
      var unique = function(array, len) {
        len = Math.min(len === -1 ? array.length : len, array.length);
        var list = [];
        for (var i = 0; i < len; i++) {
          list.push(typeof array[i] === "object" ? JSON.stringify(array[i]) : array[i]);
        }
        for (var i = 1; i < list.length; i++) {
          if (list.indexOf(list[i]) !== i) return false;
        }
        return true;
      };
      var isMultipleOf = function(name, multipleOf) {
        var res;
        var factor = (multipleOf | 0) !== multipleOf ? Math.pow(10, multipleOf.toString().split(".").pop().length) : 1;
        if (factor > 1) {
          var factorName = (name | 0) !== name ? Math.pow(10, name.toString().split(".").pop().length) : 1;
          if (factorName > factor) res = true;
          else res = Math.round(factor * name) % (factor * multipleOf);
        } else res = name % multipleOf;
        return !res;
      };
      var testLimitedRegex = function(r, s, maxLength) {
        if (maxLength > -1 && s.length > maxLength) return true;
        return r.test(s);
      };
      var compile = function(schema, cache3, root3, reporter, opts) {
        var fmts = opts ? xtend(formats, opts.formats) : formats;
        var scope = { unique, formats: fmts, isMultipleOf, testLimitedRegex };
        var verbose = opts ? !!opts.verbose : false;
        var greedy = opts && opts.greedy !== void 0 ? opts.greedy : false;
        var syms = {};
        var allocated = [];
        var gensym = function(name) {
          var res = name + (syms[name] = (syms[name] || 0) + 1);
          allocated.push(res);
          return res;
        };
        var formatName = function(field) {
          var s = JSON.stringify(field);
          try {
            var pattern = /\[([^\[\]"]+)\]/;
            while (pattern.test(s)) s = s.replace(pattern, replacer2);
            return s;
          } catch (_) {
            return JSON.stringify(field);
          }
          function replacer2(match5, v) {
            if (allocated.indexOf(v) === -1) throw new Error("Unreplaceable");
            return '." + ' + v + ' + "';
          }
        };
        var reversePatterns = {};
        var patterns = function(p) {
          if (reversePatterns[p]) return reversePatterns[p];
          var n = gensym("pattern");
          scope[n] = new RegExp(p);
          reversePatterns[p] = n;
          return n;
        };
        var vars = ["i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"];
        var genloop = function() {
          var v = vars.shift();
          vars.push(v + v[0]);
          allocated.push(v);
          return v;
        };
        var visit = function(name, node5, reporter2, filter, schemaPath) {
          var properties = node5.properties;
          var type = node5.type;
          var tuple = false;
          if (Array.isArray(node5.items)) {
            properties = {};
            node5.items.forEach(function(item, i2) {
              properties[i2] = item;
            });
            type = "array";
            tuple = true;
          }
          var indent = 0;
          var error2 = function(msg, prop, value) {
            validate("errors++");
            if (reporter2 === true) {
              validate("if (validate.errors === null) validate.errors = []");
              if (verbose) {
                validate(
                  "validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})",
                  formatName(prop || name),
                  JSON.stringify(msg),
                  value || name,
                  JSON.stringify(type),
                  JSON.stringify(schemaPath)
                );
              } else {
                validate("validate.errors.push({field:%s,message:%s})", formatName(prop || name), JSON.stringify(msg));
              }
            }
          };
          if (node5.required === true) {
            indent++;
            validate("if (%s === undefined) {", name);
            error2("is required");
            validate("} else {");
          } else {
            indent++;
            validate("if (%s !== undefined) {", name);
          }
          var valid = [].concat(type).map(function(t) {
            if (t && !types.hasOwnProperty(t)) {
              throw new Error("Unknown type: " + t);
            }
            return types[t || "any"](name);
          }).join(" || ") || "true";
          if (valid !== "true") {
            indent++;
            validate("if (!(%s)) {", valid);
            error2("is the wrong type");
            validate("} else {");
          }
          if (tuple) {
            if (node5.additionalItems === false) {
              validate("if (%s.length > %d) {", name, node5.items.length);
              error2("has additional items");
              validate("}");
            } else if (node5.additionalItems) {
              var i = genloop();
              validate("for (var %s = %d; %s < %s.length; %s++) {", i, node5.items.length, i, name, i);
              visit(name + "[" + i + "]", node5.additionalItems, reporter2, filter, schemaPath.concat("additionalItems"));
              validate("}");
            }
          }
          if (node5.format && fmts[node5.format]) {
            if (type !== "string" && formats[node5.format]) validate("if (%s) {", types.string(name));
            var n = gensym("format");
            scope[n] = fmts[node5.format];
            if (typeof scope[n] === "function") validate("if (!%s(%s)) {", n, name);
            else validate("if (!testLimitedRegex(%s, %s, %d)) {", n, name, typeof node5.maxLength === "undefined" ? -1 : node5.maxLength);
            error2("must be " + node5.format + " format");
            validate("}");
            if (type !== "string" && formats[node5.format]) validate("}");
          }
          if (Array.isArray(node5.required)) {
            var n = gensym("missing");
            validate("var %s = 0", n);
            var checkRequired = function(req) {
              var prop = genobj(name, req);
              validate("if (%s === undefined) {", prop);
              error2("is required", prop);
              validate("%s++", n);
              validate("}");
            };
            validate("if ((%s)) {", type !== "object" ? types.object(name) : "true");
            node5.required.map(checkRequired);
            validate("}");
            if (!greedy) {
              validate("if (%s === 0) {", n);
              indent++;
            }
          }
          if (node5.uniqueItems) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (!(unique(%s, %d))) {", name, node5.maxItems || -1);
            error2("must be unique");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node5.enum) {
            var complex = node5.enum.some(function(e) {
              return typeof e === "object";
            });
            var compare5 = complex ? function(e) {
              return "JSON.stringify(" + name + ") !== JSON.stringify(" + JSON.stringify(e) + ")";
            } : function(e) {
              return name + " !== " + JSON.stringify(e);
            };
            validate("if (%s) {", node5.enum.map(compare5).join(" && ") || "false");
            error2("must be an enum value");
            validate("}");
          }
          if (node5.dependencies) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            Object.keys(node5.dependencies).forEach(function(key) {
              var deps = node5.dependencies[key];
              if (typeof deps === "string") deps = [deps];
              var exists = function(k) {
                return genobj(name, k) + " !== undefined";
              };
              if (Array.isArray(deps)) {
                validate("if (%s !== undefined && !(%s)) {", genobj(name, key), deps.map(exists).join(" && ") || "true");
                error2("dependencies not set");
                validate("}");
              }
              if (typeof deps === "object") {
                validate("if (%s !== undefined) {", genobj(name, key));
                visit(name, deps, reporter2, filter, schemaPath.concat(["dependencies", key]));
                validate("}");
              }
            });
            if (type !== "object") validate("}");
          }
          if (node5.additionalProperties || node5.additionalProperties === false) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            var i = genloop();
            var keys14 = gensym("keys");
            var toCompare = function(p2) {
              return keys14 + "[" + i + "] !== " + JSON.stringify(p2);
            };
            var toTest = function(p2) {
              return "!" + patterns(p2) + ".test(" + keys14 + "[" + i + "])";
            };
            var additionalProp = Object.keys(properties || {}).map(toCompare).concat(Object.keys(node5.patternProperties || {}).map(toTest)).join(" && ") || "true";
            validate("var %s = Object.keys(%s)", keys14, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys14, i)("if (%s) {", additionalProp);
            if (node5.additionalProperties === false) {
              if (filter) validate("delete %s", name + "[" + keys14 + "[" + i + "]]");
              error2("has additional properties", null, JSON.stringify(name + ".") + " + " + keys14 + "[" + i + "]");
            } else {
              visit(name + "[" + keys14 + "[" + i + "]]", node5.additionalProperties, reporter2, filter, schemaPath.concat(["additionalProperties"]));
            }
            validate("}")("}");
            if (type !== "object") validate("}");
          }
          if (node5.$ref) {
            var sub = get10(root3, opts && opts.schemas || {}, node5.$ref);
            if (sub) {
              var fn = cache3[node5.$ref];
              if (!fn) {
                cache3[node5.$ref] = function proxy(data7) {
                  return fn(data7);
                };
                fn = compile(sub, cache3, root3, false, opts);
              }
              var n = gensym("ref");
              scope[n] = fn;
              validate("if (!(%s(%s))) {", n, name);
              error2("referenced schema does not match");
              validate("}");
            }
          }
          if (node5.not) {
            var prev = gensym("prev");
            validate("var %s = errors", prev);
            visit(name, node5.not, false, filter, schemaPath.concat("not"));
            validate("if (%s === errors) {", prev);
            error2("negative schema matches");
            validate("} else {")("errors = %s", prev)("}");
          }
          if (node5.items && !tuple) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            var i = genloop();
            validate("for (var %s = 0; %s < %s.length; %s++) {", i, i, name, i);
            visit(name + "[" + i + "]", node5.items, reporter2, filter, schemaPath.concat("items"));
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node5.patternProperties) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            var keys14 = gensym("keys");
            var i = genloop();
            validate("var %s = Object.keys(%s)", keys14, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys14, i);
            Object.keys(node5.patternProperties).forEach(function(key) {
              var p2 = patterns(key);
              validate("if (%s.test(%s)) {", p2, keys14 + "[" + i + "]");
              visit(name + "[" + keys14 + "[" + i + "]]", node5.patternProperties[key], reporter2, filter, schemaPath.concat(["patternProperties", key]));
              validate("}");
            });
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node5.pattern) {
            var p = patterns(node5.pattern);
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (!(testLimitedRegex(%s, %s, %d))) {", p, name, typeof node5.maxLength === "undefined" ? -1 : node5.maxLength);
            error2("pattern mismatch");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node5.allOf) {
            node5.allOf.forEach(function(sch, key) {
              visit(name, sch, reporter2, filter, schemaPath.concat(["allOf", key]));
            });
          }
          if (node5.anyOf && node5.anyOf.length) {
            var prev = gensym("prev");
            node5.anyOf.forEach(function(sch, i2) {
              if (i2 === 0) {
                validate("var %s = errors", prev);
              } else {
                validate("if (errors !== %s) {", prev)("errors = %s", prev);
              }
              visit(name, sch, false, false, schemaPath);
            });
            node5.anyOf.forEach(function(sch, i2) {
              if (i2) validate("}");
            });
            validate("if (%s !== errors) {", prev);
            error2("no schemas match");
            validate("}");
          }
          if (node5.oneOf && node5.oneOf.length) {
            var prev = gensym("prev");
            var passes = gensym("passes");
            validate("var %s = errors", prev)("var %s = 0", passes);
            node5.oneOf.forEach(function(sch, i2) {
              visit(name, sch, false, false, schemaPath);
              validate("if (%s === errors) {", prev)("%s++", passes)("} else {")("errors = %s", prev)("}");
            });
            validate("if (%s !== 1) {", passes);
            error2("no (or more than one) schemas match");
            validate("}");
          }
          if (node5.multipleOf !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (!isMultipleOf(%s, %d)) {", name, node5.multipleOf);
            error2("has a remainder");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (node5.maxProperties !== void 0) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            validate("if (Object.keys(%s).length > %d) {", name, node5.maxProperties);
            error2("has more properties than allowed");
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node5.minProperties !== void 0) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            validate("if (Object.keys(%s).length < %d) {", name, node5.minProperties);
            error2("has less properties than allowed");
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node5.maxItems !== void 0) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (%s.length > %d) {", name, node5.maxItems);
            error2("has more items than allowed");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node5.minItems !== void 0) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (%s.length < %d) {", name, node5.minItems);
            error2("has less items than allowed");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node5.maxLength !== void 0) {
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (%s.length > %d) {", name, node5.maxLength);
            error2("has longer length than allowed");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node5.minLength !== void 0) {
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (%s.length < %d) {", name, node5.minLength);
            error2("has less length than allowed");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node5.minimum !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (%s %s %d) {", name, node5.exclusiveMinimum ? "<=" : "<", node5.minimum);
            error2("is less than minimum");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (node5.maximum !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (%s %s %d) {", name, node5.exclusiveMaximum ? ">=" : ">", node5.maximum);
            error2("is more than maximum");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (properties) {
            Object.keys(properties).forEach(function(p2) {
              if (Array.isArray(type) && type.indexOf("null") !== -1) validate("if (%s !== null) {", name);
              visit(
                genobj(name, p2),
                properties[p2],
                reporter2,
                filter,
                schemaPath.concat(tuple ? p2 : ["properties", p2])
              );
              if (Array.isArray(type) && type.indexOf("null") !== -1) validate("}");
            });
          }
          while (indent--) validate("}");
        };
        var validate = genfun("function validate(data) {")("if (data === undefined) data = null")("validate.errors = null")("var errors = 0");
        visit("data", schema, reporter, opts && opts.filter, []);
        validate("return errors === 0")("}");
        validate = validate.toFunction(scope);
        validate.errors = null;
        if (Object.defineProperty) {
          Object.defineProperty(validate, "error", {
            get: function() {
              if (!validate.errors) return "";
              return validate.errors.map(function(err) {
                return err.field + " " + err.message;
              }).join("\n");
            }
          });
        }
        validate.toJSON = function() {
          return schema;
        };
        return validate;
      };
      module2.exports = function(schema, opts) {
        if (typeof schema === "string") schema = JSON.parse(schema);
        return compile(schema, {}, schema, true, opts);
      };
      module2.exports.filter = function(schema, opts) {
        var validate = module2.exports(schema, xtend(opts, { filter: true }));
        return function(sch) {
          validate(sch);
          return sch;
        };
      };
    }
  });

  // node_modules/near-abi/lib/index.js
  var require_lib23 = __commonJS({
    "node_modules/near-abi/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbiSerializationType = exports2.AbiFunctionModifier = exports2.AbiFunctionKind = exports2.SCHEMA_VERSION = void 0;
      exports2.SCHEMA_VERSION = "0.3.0";
      var AbiFunctionKind;
      (function(AbiFunctionKind2) {
        AbiFunctionKind2["View"] = "view";
        AbiFunctionKind2["Call"] = "call";
      })(AbiFunctionKind = exports2.AbiFunctionKind || (exports2.AbiFunctionKind = {}));
      var AbiFunctionModifier;
      (function(AbiFunctionModifier2) {
        AbiFunctionModifier2["Init"] = "init";
        AbiFunctionModifier2["Private"] = "private";
        AbiFunctionModifier2["Payable"] = "payable";
      })(AbiFunctionModifier = exports2.AbiFunctionModifier || (exports2.AbiFunctionModifier = {}));
      var AbiSerializationType;
      (function(AbiSerializationType2) {
        AbiSerializationType2["Json"] = "json";
        AbiSerializationType2["Borsh"] = "borsh";
      })(AbiSerializationType = exports2.AbiSerializationType || (exports2.AbiSerializationType = {}));
    }
  });

  // node_modules/@near-js/accounts/lib/errors.js
  var require_errors16 = __commonJS({
    "node_modules/@near-js/accounts/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConflictingOptions = exports2.ArgumentSchemaError = exports2.UnknownArgumentError = exports2.UnsupportedSerializationError = void 0;
      var UnsupportedSerializationError = class extends Error {
        constructor(methodName, serializationType) {
          super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);
        }
      };
      exports2.UnsupportedSerializationError = UnsupportedSerializationError;
      var UnknownArgumentError = class extends Error {
        constructor(actualArgName, expectedArgNames) {
          super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);
        }
      };
      exports2.UnknownArgumentError = UnknownArgumentError;
      var ArgumentSchemaError = class extends Error {
        constructor(argName, errors2) {
          super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors2)}'`);
        }
      };
      exports2.ArgumentSchemaError = ArgumentSchemaError;
      var ConflictingOptions = class extends Error {
        constructor() {
          super("Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.");
        }
      };
      exports2.ConflictingOptions = ConflictingOptions;
    }
  });

  // node_modules/@near-js/accounts/lib/contract.js
  var require_contract = __commonJS({
    "node_modules/@near-js/accounts/lib/contract.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Contract = void 0;
      var utils_1 = require_lib15();
      var types_1 = require_lib14();
      var local_view_execution_1 = require_local_view_execution();
      var is_my_json_valid_1 = __importDefault(require_is_my_json_valid());
      var depd_1 = __importDefault(require_browser());
      var near_abi_1 = require_lib23();
      var account_1 = require_account();
      var errors_1 = require_errors16();
      var utils_2 = require_utils16();
      function nameFunction(name, body) {
        return {
          [name](...args) {
            return body(...args);
          }
        }[name];
      }
      function validateArguments(args, abiFunction, abiRoot) {
        var _a;
        if (!isObject8(args))
          return;
        if (abiFunction.params && abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {
          throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);
        }
        if (abiFunction.result && abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {
          throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);
        }
        const params = ((_a = abiFunction.params) === null || _a === void 0 ? void 0 : _a.args) || [];
        for (const p of params) {
          const arg = args[p.name];
          const typeSchema = p.type_schema;
          typeSchema.definitions = abiRoot.body.root_schema.definitions;
          const validate = (0, is_my_json_valid_1.default)(typeSchema);
          const valid = validate(arg);
          if (!valid) {
            throw new errors_1.ArgumentSchemaError(p.name, validate.errors);
          }
        }
        for (const argName of Object.keys(args)) {
          const param = params.find((p) => p.name === argName);
          if (!param) {
            throw new errors_1.UnknownArgumentError(argName, params.map((p) => p.name));
          }
        }
      }
      var isUint8Array = (x) => x && x.byteLength !== void 0 && x.byteLength === x.length;
      var isObject8 = (x) => Object.prototype.toString.call(x) === "[object Object]";
      var Contract = class {
        /**
         * @param account NEAR account to sign change method transactions
         * @param contractId NEAR account id where the contract is deployed
         * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
         */
        constructor(connection, contractId, options) {
          this.connection = connection.getConnection();
          if (connection instanceof account_1.Account) {
            const deprecate2 = (0, depd_1.default)("new Contract(account, contractId, options)");
            deprecate2("use `new Contract(connection, contractId, options)` instead");
            this.account = connection;
          }
          this.contractId = contractId;
          this.lve = new local_view_execution_1.LocalViewExecution(connection);
          const { viewMethods = [], changeMethods = [], abi: abiRoot, useLocalViewExecution } = options;
          let viewMethodsWithAbi = viewMethods.map((name) => ({
            name,
            abi: null
          }));
          let changeMethodsWithAbi = changeMethods.map((name) => ({
            name,
            abi: null
          }));
          if (abiRoot) {
            if (viewMethodsWithAbi.length > 0 || changeMethodsWithAbi.length > 0) {
              throw new errors_1.ConflictingOptions();
            }
            viewMethodsWithAbi = abiRoot.body.functions.filter((m) => m.kind === near_abi_1.AbiFunctionKind.View).map((m) => ({ name: m.name, abi: m }));
            changeMethodsWithAbi = abiRoot.body.functions.filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call).map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));
          }
          viewMethodsWithAbi.forEach(({ name, abi }) => {
            Object.defineProperty(this, name, {
              writable: false,
              enumerable: true,
              value: nameFunction(name, (args = {}, options2 = {}, ...ignored) => __awaiter6(this, void 0, void 0, function* () {
                if (ignored.length || !(isObject8(args) || isUint8Array(args)) || !isObject8(options2)) {
                  throw new types_1.PositionalArgsError();
                }
                if (abi) {
                  validateArguments(args, abi, abiRoot);
                }
                if (useLocalViewExecution) {
                  try {
                    return yield this.lve.viewFunction(Object.assign({ contractId: this.contractId, methodName: name, args }, options2));
                  } catch (error2) {
                    utils_1.Logger.warn(`Local view execution failed with: "${error2.message}"`);
                    utils_1.Logger.warn(`Fallback to normal RPC call`);
                  }
                }
                if (this.account) {
                  return this.account.viewFunction(Object.assign({ contractId: this.contractId, methodName: name, args }, options2));
                }
                return (0, utils_2.viewFunction)(this.connection, Object.assign({ contractId: this.contractId, methodName: name, args }, options2));
              }))
            });
          });
          changeMethodsWithAbi.forEach(({ name, abi }) => {
            Object.defineProperty(this, name, {
              writable: false,
              enumerable: true,
              value: nameFunction(name, (...args) => __awaiter6(this, void 0, void 0, function* () {
                if (args.length && (args.length > 3 || !(isObject8(args[0]) || isUint8Array(args[0])))) {
                  throw new types_1.PositionalArgsError();
                }
                if (args.length > 1 || !(args[0] && args[0].args)) {
                  const deprecate2 = (0, depd_1.default)("contract.methodName(args, gas, amount)");
                  deprecate2("use `contract.methodName({ signerAccount, args, gas?, amount?, callbackUrl?, meta? })` instead");
                  args[0] = {
                    args: args[0],
                    gas: args[1],
                    amount: args[2]
                  };
                }
                if (abi) {
                  validateArguments(args[0].args, abi, abiRoot);
                }
                return this._changeMethod(Object.assign({ methodName: name }, args[0]));
              }))
            });
          });
        }
        _changeMethod({ signerAccount, args, methodName, gas, amount, meta, callbackUrl }) {
          return __awaiter6(this, void 0, void 0, function* () {
            validateBNLike({ gas, amount });
            const account = this.account || signerAccount;
            if (!account)
              throw new Error(`signerAccount must be specified`);
            const rawResult = yield account.functionCall({
              contractId: this.contractId,
              methodName,
              args,
              gas,
              attachedDeposit: amount,
              walletMeta: meta,
              walletCallbackUrl: callbackUrl
            });
            return (0, utils_1.getTransactionLastResult)(rawResult);
          });
        }
      };
      exports2.Contract = Contract;
      function validateBNLike(argMap) {
        const bnLike = "number, decimal string or BigInt";
        for (const argName of Object.keys(argMap)) {
          const argValue = argMap[argName];
          if (argValue && typeof argValue !== "bigint" && isNaN(argValue)) {
            throw new types_1.ArgumentTypeError(argName, bnLike, argValue);
          }
        }
      }
    }
  });

  // node_modules/@near-js/accounts/lib/index.js
  var require_lib24 = __commonJS({
    "node_modules/@near-js/accounts/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MultisigStateStatus = exports2.MultisigDeleteRequestRejectionError = exports2.UnsupportedSerializationError = exports2.UnknownArgumentError = exports2.ConflictingOptions = exports2.ArgumentSchemaError = exports2.Contract = exports2.MULTISIG_CONFIRM_METHODS = exports2.MULTISIG_CHANGE_METHODS = exports2.MULTISIG_DEPOSIT = exports2.MULTISIG_GAS = exports2.MULTISIG_ALLOWANCE = exports2.MULTISIG_STORAGE_KEY = exports2.Connection = exports2.AccountMultisig = exports2.UrlAccountCreator = exports2.LocalAccountCreator = exports2.AccountCreator = exports2.Account2FA = exports2.Account = void 0;
      var account_1 = require_account();
      Object.defineProperty(exports2, "Account", { enumerable: true, get: function() {
        return account_1.Account;
      } });
      var account_2fa_1 = require_account_2fa();
      Object.defineProperty(exports2, "Account2FA", { enumerable: true, get: function() {
        return account_2fa_1.Account2FA;
      } });
      var account_creator_1 = require_account_creator();
      Object.defineProperty(exports2, "AccountCreator", { enumerable: true, get: function() {
        return account_creator_1.AccountCreator;
      } });
      Object.defineProperty(exports2, "LocalAccountCreator", { enumerable: true, get: function() {
        return account_creator_1.LocalAccountCreator;
      } });
      Object.defineProperty(exports2, "UrlAccountCreator", { enumerable: true, get: function() {
        return account_creator_1.UrlAccountCreator;
      } });
      var account_multisig_1 = require_account_multisig();
      Object.defineProperty(exports2, "AccountMultisig", { enumerable: true, get: function() {
        return account_multisig_1.AccountMultisig;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports2, "Connection", { enumerable: true, get: function() {
        return connection_1.Connection;
      } });
      var constants_1 = require_constants9();
      Object.defineProperty(exports2, "MULTISIG_STORAGE_KEY", { enumerable: true, get: function() {
        return constants_1.MULTISIG_STORAGE_KEY;
      } });
      Object.defineProperty(exports2, "MULTISIG_ALLOWANCE", { enumerable: true, get: function() {
        return constants_1.MULTISIG_ALLOWANCE;
      } });
      Object.defineProperty(exports2, "MULTISIG_GAS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_GAS;
      } });
      Object.defineProperty(exports2, "MULTISIG_DEPOSIT", { enumerable: true, get: function() {
        return constants_1.MULTISIG_DEPOSIT;
      } });
      Object.defineProperty(exports2, "MULTISIG_CHANGE_METHODS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_CHANGE_METHODS;
      } });
      Object.defineProperty(exports2, "MULTISIG_CONFIRM_METHODS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_CONFIRM_METHODS;
      } });
      var contract_1 = require_contract();
      Object.defineProperty(exports2, "Contract", { enumerable: true, get: function() {
        return contract_1.Contract;
      } });
      var errors_1 = require_errors16();
      Object.defineProperty(exports2, "ArgumentSchemaError", { enumerable: true, get: function() {
        return errors_1.ArgumentSchemaError;
      } });
      Object.defineProperty(exports2, "ConflictingOptions", { enumerable: true, get: function() {
        return errors_1.ConflictingOptions;
      } });
      Object.defineProperty(exports2, "UnknownArgumentError", { enumerable: true, get: function() {
        return errors_1.UnknownArgumentError;
      } });
      Object.defineProperty(exports2, "UnsupportedSerializationError", { enumerable: true, get: function() {
        return errors_1.UnsupportedSerializationError;
      } });
      var types_1 = require_types2();
      Object.defineProperty(exports2, "MultisigDeleteRequestRejectionError", { enumerable: true, get: function() {
        return types_1.MultisigDeleteRequestRejectionError;
      } });
      Object.defineProperty(exports2, "MultisigStateStatus", { enumerable: true, get: function() {
        return types_1.MultisigStateStatus;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/errors.js
  var require_errors17 = __commonJS({
    "node_modules/near-api-js/lib/utils/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = exports2.TypedError = exports2.PositionalArgsError = exports2.ErrorContext = exports2.ArgumentTypeError = exports2.UnsupportedSerializationError = exports2.UnknownArgumentError = exports2.ConflictingOptions = exports2.ArgumentSchemaError = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "ArgumentSchemaError", { enumerable: true, get: function() {
        return accounts_1.ArgumentSchemaError;
      } });
      Object.defineProperty(exports2, "ConflictingOptions", { enumerable: true, get: function() {
        return accounts_1.ConflictingOptions;
      } });
      Object.defineProperty(exports2, "UnknownArgumentError", { enumerable: true, get: function() {
        return accounts_1.UnknownArgumentError;
      } });
      Object.defineProperty(exports2, "UnsupportedSerializationError", { enumerable: true, get: function() {
        return accounts_1.UnsupportedSerializationError;
      } });
      var types_1 = require_lib9();
      Object.defineProperty(exports2, "ArgumentTypeError", { enumerable: true, get: function() {
        return types_1.ArgumentTypeError;
      } });
      Object.defineProperty(exports2, "ErrorContext", { enumerable: true, get: function() {
        return types_1.ErrorContext;
      } });
      Object.defineProperty(exports2, "PositionalArgsError", { enumerable: true, get: function() {
        return types_1.PositionalArgsError;
      } });
      Object.defineProperty(exports2, "TypedError", { enumerable: true, get: function() {
        return types_1.TypedError;
      } });
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return utils_1.logWarning;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/logger.js
  var require_logger11 = __commonJS({
    "node_modules/near-api-js/lib/utils/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return utils_1.Logger;
      } });
    }
  });

  // node_modules/near-api-js/lib/utils/index.js
  var require_utils21 = __commonJS({
    "node_modules/near-api-js/lib/utils/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = exports2.logWarning = exports2.rpc_errors = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.PublicKey = exports2.format = exports2.enums = exports2.web = exports2.serialize = exports2.key_pair = void 0;
      var key_pair = __importStar(require_key_pair4());
      exports2.key_pair = key_pair;
      var serialize3 = __importStar(require_serialize2());
      exports2.serialize = serialize3;
      var web = __importStar(require_web());
      exports2.web = web;
      var enums = __importStar(require_enums());
      exports2.enums = enums;
      var format3 = __importStar(require_format4());
      exports2.format = format3;
      var rpc_errors = __importStar(require_rpc_errors4());
      exports2.rpc_errors = rpc_errors;
      var key_pair_1 = require_key_pair4();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return key_pair_1.PublicKey;
      } });
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_1.KeyPairEd25519;
      } });
      var errors_1 = require_errors17();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var logger_1 = require_logger11();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/near-api-js/lib/transaction.js
  var require_transaction = __commonJS({
    "node_modules/near-api-js/lib/transaction.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.transfer = exports2.stake = exports2.functionCallAccessKey = exports2.functionCall = exports2.fullAccessKey = exports2.deployContract = exports2.deleteKey = exports2.deleteAccount = exports2.createAccount = exports2.addKey = exports2.encodeTransaction = exports2.encodeDelegateAction = exports2.encodeSignedDelegate = exports2.Transaction = exports2.SignedTransaction = exports2.Signature = exports2.signTransaction = exports2.createTransaction = exports2.SCHEMA = exports2.Transfer = exports2.Stake = exports2.FunctionCallPermission = exports2.FunctionCall = exports2.FullAccessPermission = exports2.DeployContract = exports2.DeleteKey = exports2.DeleteAccount = exports2.CreateAccount = exports2.AddKey = exports2.AccessKeyPermission = exports2.AccessKey = exports2.Action = exports2.stringifyJsonOrBytes = void 0;
      var transactions_1 = require_lib11();
      Object.defineProperty(exports2, "stringifyJsonOrBytes", { enumerable: true, get: function() {
        return transactions_1.stringifyJsonOrBytes;
      } });
      Object.defineProperty(exports2, "Action", { enumerable: true, get: function() {
        return transactions_1.Action;
      } });
      Object.defineProperty(exports2, "AccessKey", { enumerable: true, get: function() {
        return transactions_1.AccessKey;
      } });
      Object.defineProperty(exports2, "AccessKeyPermission", { enumerable: true, get: function() {
        return transactions_1.AccessKeyPermission;
      } });
      Object.defineProperty(exports2, "AddKey", { enumerable: true, get: function() {
        return transactions_1.AddKey;
      } });
      Object.defineProperty(exports2, "CreateAccount", { enumerable: true, get: function() {
        return transactions_1.CreateAccount;
      } });
      Object.defineProperty(exports2, "DeleteAccount", { enumerable: true, get: function() {
        return transactions_1.DeleteAccount;
      } });
      Object.defineProperty(exports2, "DeleteKey", { enumerable: true, get: function() {
        return transactions_1.DeleteKey;
      } });
      Object.defineProperty(exports2, "DeployContract", { enumerable: true, get: function() {
        return transactions_1.DeployContract;
      } });
      Object.defineProperty(exports2, "FullAccessPermission", { enumerable: true, get: function() {
        return transactions_1.FullAccessPermission;
      } });
      Object.defineProperty(exports2, "FunctionCall", { enumerable: true, get: function() {
        return transactions_1.FunctionCall;
      } });
      Object.defineProperty(exports2, "FunctionCallPermission", { enumerable: true, get: function() {
        return transactions_1.FunctionCallPermission;
      } });
      Object.defineProperty(exports2, "Stake", { enumerable: true, get: function() {
        return transactions_1.Stake;
      } });
      Object.defineProperty(exports2, "Transfer", { enumerable: true, get: function() {
        return transactions_1.Transfer;
      } });
      Object.defineProperty(exports2, "SCHEMA", { enumerable: true, get: function() {
        return transactions_1.SCHEMA;
      } });
      Object.defineProperty(exports2, "createTransaction", { enumerable: true, get: function() {
        return transactions_1.createTransaction;
      } });
      Object.defineProperty(exports2, "signTransaction", { enumerable: true, get: function() {
        return transactions_1.signTransaction;
      } });
      Object.defineProperty(exports2, "Signature", { enumerable: true, get: function() {
        return transactions_1.Signature;
      } });
      Object.defineProperty(exports2, "SignedTransaction", { enumerable: true, get: function() {
        return transactions_1.SignedTransaction;
      } });
      Object.defineProperty(exports2, "Transaction", { enumerable: true, get: function() {
        return transactions_1.Transaction;
      } });
      Object.defineProperty(exports2, "encodeSignedDelegate", { enumerable: true, get: function() {
        return transactions_1.encodeSignedDelegate;
      } });
      Object.defineProperty(exports2, "encodeDelegateAction", { enumerable: true, get: function() {
        return transactions_1.encodeDelegateAction;
      } });
      Object.defineProperty(exports2, "encodeTransaction", { enumerable: true, get: function() {
        return transactions_1.encodeTransaction;
      } });
      var transactions_2 = require_lib11();
      var addKey = (publicKey, accessKey) => transactions_2.actionCreators.addKey(publicKey, accessKey);
      exports2.addKey = addKey;
      var createAccount = () => transactions_2.actionCreators.createAccount();
      exports2.createAccount = createAccount;
      var deleteAccount = (beneficiaryId) => transactions_2.actionCreators.deleteAccount(beneficiaryId);
      exports2.deleteAccount = deleteAccount;
      var deleteKey = (publicKey) => transactions_2.actionCreators.deleteKey(publicKey);
      exports2.deleteKey = deleteKey;
      var deployContract = (code) => transactions_2.actionCreators.deployContract(code);
      exports2.deployContract = deployContract;
      var fullAccessKey = () => transactions_2.actionCreators.fullAccessKey();
      exports2.fullAccessKey = fullAccessKey;
      var functionCall = (methodName, args, gas, deposit, stringify2, jsContract) => transactions_2.actionCreators.functionCall(methodName, args, gas, deposit, stringify2, jsContract);
      exports2.functionCall = functionCall;
      var functionCallAccessKey = (receiverId, methodNames, allowance) => transactions_2.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
      exports2.functionCallAccessKey = functionCallAccessKey;
      var stake = (stake2, publicKey) => transactions_2.actionCreators.stake(stake2, publicKey);
      exports2.stake = stake;
      var transfer = (deposit) => transactions_2.actionCreators.transfer(deposit);
      exports2.transfer = transfer;
    }
  });

  // node_modules/near-api-js/lib/validators.js
  var require_validators6 = __commonJS({
    "node_modules/near-api-js/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.findSeatPrice = exports2.diffEpochValidators = void 0;
      var utils_1 = require_lib10();
      Object.defineProperty(exports2, "diffEpochValidators", { enumerable: true, get: function() {
        return utils_1.diffEpochValidators;
      } });
      Object.defineProperty(exports2, "findSeatPrice", { enumerable: true, get: function() {
        return utils_1.findSeatPrice;
      } });
    }
  });

  // node_modules/near-api-js/lib/account.js
  var require_account2 = __commonJS({
    "node_modules/near-api-js/lib/account.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Account = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "Account", { enumerable: true, get: function() {
        return accounts_1.Account;
      } });
    }
  });

  // node_modules/near-api-js/lib/account_multisig.js
  var require_account_multisig2 = __commonJS({
    "node_modules/near-api-js/lib/account_multisig.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MultisigStateStatus = exports2.MultisigDeleteRequestRejectionError = exports2.MULTISIG_CONFIRM_METHODS = exports2.MULTISIG_CHANGE_METHODS = exports2.MULTISIG_DEPOSIT = exports2.MULTISIG_GAS = exports2.MULTISIG_ALLOWANCE = exports2.MULTISIG_STORAGE_KEY = exports2.AccountMultisig = exports2.Account2FA = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "Account2FA", { enumerable: true, get: function() {
        return accounts_1.Account2FA;
      } });
      Object.defineProperty(exports2, "AccountMultisig", { enumerable: true, get: function() {
        return accounts_1.AccountMultisig;
      } });
      Object.defineProperty(exports2, "MULTISIG_STORAGE_KEY", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_STORAGE_KEY;
      } });
      Object.defineProperty(exports2, "MULTISIG_ALLOWANCE", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_ALLOWANCE;
      } });
      Object.defineProperty(exports2, "MULTISIG_GAS", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_GAS;
      } });
      Object.defineProperty(exports2, "MULTISIG_DEPOSIT", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_DEPOSIT;
      } });
      Object.defineProperty(exports2, "MULTISIG_CHANGE_METHODS", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_CHANGE_METHODS;
      } });
      Object.defineProperty(exports2, "MULTISIG_CONFIRM_METHODS", { enumerable: true, get: function() {
        return accounts_1.MULTISIG_CONFIRM_METHODS;
      } });
      Object.defineProperty(exports2, "MultisigDeleteRequestRejectionError", { enumerable: true, get: function() {
        return accounts_1.MultisigDeleteRequestRejectionError;
      } });
      Object.defineProperty(exports2, "MultisigStateStatus", { enumerable: true, get: function() {
        return accounts_1.MultisigStateStatus;
      } });
    }
  });

  // node_modules/near-api-js/lib/account_creator.js
  var require_account_creator2 = __commonJS({
    "node_modules/near-api-js/lib/account_creator.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.UrlAccountCreator = exports2.LocalAccountCreator = exports2.AccountCreator = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "AccountCreator", { enumerable: true, get: function() {
        return accounts_1.AccountCreator;
      } });
      Object.defineProperty(exports2, "LocalAccountCreator", { enumerable: true, get: function() {
        return accounts_1.LocalAccountCreator;
      } });
      Object.defineProperty(exports2, "UrlAccountCreator", { enumerable: true, get: function() {
        return accounts_1.UrlAccountCreator;
      } });
    }
  });

  // node_modules/near-api-js/lib/connection.js
  var require_connection2 = __commonJS({
    "node_modules/near-api-js/lib/connection.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Connection = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "Connection", { enumerable: true, get: function() {
        return accounts_1.Connection;
      } });
    }
  });

  // node_modules/near-api-js/lib/signer.js
  var require_signer2 = __commonJS({
    "node_modules/near-api-js/lib/signer.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signer = exports2.InMemorySigner = void 0;
      var signers_1 = require_lib22();
      Object.defineProperty(exports2, "InMemorySigner", { enumerable: true, get: function() {
        return signers_1.InMemorySigner;
      } });
      Object.defineProperty(exports2, "Signer", { enumerable: true, get: function() {
        return signers_1.Signer;
      } });
    }
  });

  // node_modules/near-api-js/lib/contract.js
  var require_contract2 = __commonJS({
    "node_modules/near-api-js/lib/contract.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Contract = void 0;
      var accounts_1 = require_lib24();
      Object.defineProperty(exports2, "Contract", { enumerable: true, get: function() {
        return accounts_1.Contract;
      } });
    }
  });

  // node_modules/@near-js/wallet-account/lib/near.js
  var require_near = __commonJS({
    "node_modules/@near-js/wallet-account/lib/near.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Near = void 0;
      var accounts_1 = require_lib24();
      var Near = class {
        constructor(config4) {
          var _a;
          this.config = config4;
          this.connection = accounts_1.Connection.fromConfig({
            networkId: config4.networkId,
            provider: config4.provider || { type: "JsonRpcProvider", args: { url: config4.nodeUrl, headers: config4.headers } },
            signer: config4.signer || { type: "InMemorySigner", keyStore: config4.keyStore || ((_a = config4.deps) === null || _a === void 0 ? void 0 : _a.keyStore) },
            jsvmAccountId: config4.jsvmAccountId || `jsvm.${config4.networkId}`
          });
          if (config4.masterAccount) {
            const initialBalance = config4.initialBalance ? BigInt(config4.initialBalance) : BigInt("500000000000000000000000000");
            this.accountCreator = new accounts_1.LocalAccountCreator(new accounts_1.Account(this.connection, config4.masterAccount), initialBalance);
          } else if (config4.helperUrl) {
            this.accountCreator = new accounts_1.UrlAccountCreator(this.connection, config4.helperUrl);
          } else {
            this.accountCreator = null;
          }
        }
        /**
         * @param accountId near accountId used to interact with the network.
         */
        account(accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const account = new accounts_1.Account(this.connection, accountId);
            return account;
          });
        }
        /**
         * Create an account using the {@link AccountCreator}. Either:
         * * using a masterAccount with {@link LocalAccountCreator}
         * * using the helperUrl with {@link UrlAccountCreator}
         * @see {@link NearConfig#masterAccount} and {@link NearConfig#helperUrl}
         *
         * @param accountId
         * @param publicKey
         */
        createAccount(accountId, publicKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (!this.accountCreator) {
              throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
            }
            yield this.accountCreator.createAccount(accountId, publicKey);
            return new accounts_1.Account(this.connection, accountId);
          });
        }
      };
      exports2.Near = Near;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/constants.js
  var require_constants12 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      var KeySize;
      (function(KeySize2) {
        KeySize2[KeySize2["SECRET_KEY"] = 32] = "SECRET_KEY";
      })(KeySize = exports2.KeySize || (exports2.KeySize = {}));
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair_base.js
  var require_key_pair_base6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/constants.js
  var require_constants13 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger12 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger6();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger13 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger12();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors18 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger13();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/assignable.js
  var require_assignable6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/errors.js
  var require_errors19 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/response.js
  var require_response6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/index.js
  var require_provider14 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client6();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response6();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/index.js
  var require_lib25 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable6(), exports2);
      __exportStar(require_errors19(), exports2);
      __exportStar(require_provider14(), exports2);
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/base-x/index.js
  var require_base_x6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/bs58/index.js
  var require_bs586 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x6();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/format.js
  var require_format7 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs586());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors7 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib25();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format7();
      var error_messages_json_1 = __importDefault(require_error_messages6());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema6());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors20 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors18();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors7();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logging.js
  var require_logging6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors20();
      var logger_1 = require_logger13();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/provider.js
  var require_provider15 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/utils.js
  var require_utils22 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/validators.js
  var require_validators7 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils22();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/index.js
  var require_lib26 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants13(), exports2);
      __exportStar(require_errors20(), exports2);
      __exportStar(require_format7(), exports2);
      __exportStar(require_logging6(), exports2);
      __exportStar(require_provider15(), exports2);
      __exportStar(require_validators7(), exports2);
      __exportStar(require_logger13(), exports2);
      __exportStar(require_utils22(), exports2);
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
  var require_assert9 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
  var require_crypto10 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
  var require_utils23 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto10();
      var u8a = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!u8a(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
  var require_sha29 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert9();
      var utils_js_1 = require_utils23();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js
  var require_u646 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split7;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js
  var require_sha5126 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha29();
      var _u64_js_1 = require_u646();
      var utils_js_1 = require_utils23();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/utils.js
  var require_utils24 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a = (a) => a instanceof Uint8Array;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports2.hexToNumber = hexToNumber;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports2.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports2.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports2.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports2.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title3} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title3} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title3} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports2.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad2 = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad2);
          pad2 += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports2.equalBytes = equalBytes;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports2.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports2.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports2.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports2.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports2.validateObject = validateObject;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/modular.js
  var require_modular6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
      var utils_js_1 = require_utils24();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports2.mod = mod;
      function pow3(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports2.pow = pow3;
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports2.pow2 = pow22;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports2.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports2.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports2.FpSqrt = FpSqrt;
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports2.validateField = validateField;
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports2.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports2.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports2.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports2.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports2.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports2.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      exports2.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      exports2.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports2.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports2.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports2.mapHashToField = mapHashToField;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/curve.js
  var require_curve6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateBasic = exports2.wNAF = void 0;
      var modular_js_1 = require_modular6();
      var utils_js_1 = require_utils24();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports2.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports2.validateBasic = validateBasic;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = void 0;
      var modular_js_1 = require_modular6();
      var ut = require_utils24();
      var utils_js_1 = require_utils24();
      var curve_js_1 = require_curve6();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        const inBig = (n) => typeof n === "bigint" && _0n < n;
        const inRange = (n, max7) => inBig(n) && inBig(max7) && n < max7;
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
        function assertInRange(n, max7) {
          if (inRange(n, max7))
            return n;
          throw new Error(`Expected valid scalar < ${max7}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n)
              return I;
            if (this.equals(I) || n === _1n)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n : Fp.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n, y: _1n };
            if (zz !== _1n)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
      exports2.twistedEdwards = twistedEdwards;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = void 0;
      var modular_js_1 = require_modular6();
      var utils_js_1 = require_utils24();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports2.montgomery = montgomery;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
      var modular_js_1 = require_modular6();
      var utils_js_1 = require_utils24();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports2.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes(msg);
        isBytes(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports2.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports2.hash_to_field = hash_to_field;
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports2.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports2.createHasher = createHasher;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/curves/ed25519.js
  var require_ed255196 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomeryPriv = exports2.edwardsToMontgomery = exports2.edwardsToMontgomeryPub = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha5126();
      var utils_1 = require_utils23();
      var edwards_js_1 = require_edwards6();
      var montgomery_js_1 = require_montgomery6();
      var modular_js_1 = require_modular6();
      var utils_js_1 = require_utils24();
      var hash_to_curve_js_1 = require_hash_to_curve6();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _5n = BigInt(5);
      var _10n = BigInt(10);
      var _20n = BigInt(20);
      var _40n = BigInt(40);
      var _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = (0, modular_js_1.Field)(ED25519_P, void 0, true);
      var ed25519Defaults = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      };
      exports2.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      });
      exports2.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      });
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
      var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/public_key.js
  var require_public_key6 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var types_1 = require_lib25();
      var utils_1 = require_lib26();
      var ed25519_1 = require_ed255196();
      var constants_1 = require_constants12();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      var PublicKey = class _PublicKey extends types_1.Assignable {
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType = constants_1.KeyType.ED25519;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (decodedPublicKey.length !== constants_1.KeySize.SECRET_KEY) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${constants_1.KeySize.SECRET_KEY}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, utils_1.baseEncode)(this.data)}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          switch (this.keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair_ed25519.js
  var require_key_pair_ed255196 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_lib26();
      var ed25519_1 = require_ed255196();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants12();
      var key_pair_base_1 = require_key_pair_base6();
      var public_key_1 = require_public_key6();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair.js
  var require_key_pair7 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base6();
      var key_pair_ed25519_1 = require_key_pair_ed255196();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/index.js
  var require_lib27 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/crypto/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants12();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair7();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255196();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var public_key_1 = require_public_key6();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/actions.js
  var require_actions3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/actions.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Action = exports2.SignedDelegate = exports2.DeleteAccount = exports2.DeleteKey = exports2.AddKey = exports2.Stake = exports2.Transfer = exports2.FunctionCall = exports2.DeployContract = exports2.CreateAccount = exports2.IAction = exports2.AccessKey = exports2.AccessKeyPermission = exports2.FullAccessPermission = exports2.FunctionCallPermission = void 0;
      var types_1 = require_lib25();
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
            this.enum = key;
          });
        }
      };
      var FunctionCallPermission = class extends types_1.Assignable {
      };
      exports2.FunctionCallPermission = FunctionCallPermission;
      var FullAccessPermission = class extends types_1.Assignable {
      };
      exports2.FullAccessPermission = FullAccessPermission;
      var AccessKeyPermission = class extends Enum {
      };
      exports2.AccessKeyPermission = AccessKeyPermission;
      var AccessKey = class extends types_1.Assignable {
      };
      exports2.AccessKey = AccessKey;
      var IAction = class extends types_1.Assignable {
      };
      exports2.IAction = IAction;
      var CreateAccount = class extends IAction {
      };
      exports2.CreateAccount = CreateAccount;
      var DeployContract = class extends IAction {
      };
      exports2.DeployContract = DeployContract;
      var FunctionCall = class extends IAction {
      };
      exports2.FunctionCall = FunctionCall;
      var Transfer = class extends IAction {
      };
      exports2.Transfer = Transfer;
      var Stake = class extends IAction {
      };
      exports2.Stake = Stake;
      var AddKey = class extends IAction {
      };
      exports2.AddKey = AddKey;
      var DeleteKey = class extends IAction {
      };
      exports2.DeleteKey = DeleteKey;
      var DeleteAccount = class extends IAction {
      };
      exports2.DeleteAccount = DeleteAccount;
      var SignedDelegate = class extends IAction {
      };
      exports2.SignedDelegate = SignedDelegate;
      var Action = class extends Enum {
      };
      exports2.Action = Action;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/action_creators.js
  var require_action_creators3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/action_creators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.actionCreators = exports2.stringifyJsonOrBytes = void 0;
      var actions_1 = require_actions3();
      function fullAccessKey() {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            fullAccess: new actions_1.FullAccessPermission({})
          })
        });
      }
      function functionCallAccessKey(receiverId, methodNames, allowance) {
        return new actions_1.AccessKey({
          nonce: 0,
          permission: new actions_1.AccessKeyPermission({
            functionCall: new actions_1.FunctionCallPermission({
              receiverId,
              allowance,
              methodNames
            })
          })
        });
      }
      function createAccount() {
        return new actions_1.Action({ createAccount: new actions_1.CreateAccount({}) });
      }
      function deployContract(code) {
        return new actions_1.Action({ deployContract: new actions_1.DeployContract({ code }) });
      }
      function stringifyJsonOrBytes(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        return isUint8Array ? args : Buffer.from(JSON.stringify(args));
      }
      exports2.stringifyJsonOrBytes = stringifyJsonOrBytes;
      function functionCall(methodName, args, gas = BigInt(0), deposit = BigInt(0), stringify2 = stringifyJsonOrBytes, jsContract = false) {
        if (jsContract) {
          return new actions_1.Action({
            functionCall: new actions_1.FunctionCall({ methodName, args, gas, deposit })
          });
        }
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({
            methodName,
            args: stringify2(args),
            gas,
            deposit
          })
        });
      }
      function transfer(deposit = BigInt(0)) {
        return new actions_1.Action({ transfer: new actions_1.Transfer({ deposit }) });
      }
      function stake(stake2 = BigInt(0), publicKey) {
        return new actions_1.Action({ stake: new actions_1.Stake({ stake: stake2, publicKey }) });
      }
      function addKey(publicKey, accessKey) {
        return new actions_1.Action({ addKey: new actions_1.AddKey({ publicKey, accessKey }) });
      }
      function deleteKey(publicKey) {
        return new actions_1.Action({ deleteKey: new actions_1.DeleteKey({ publicKey }) });
      }
      function deleteAccount(beneficiaryId) {
        return new actions_1.Action({ deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }) });
      }
      function signedDelegate({ delegateAction, signature }) {
        return new actions_1.Action({
          signedDelegate: new actions_1.SignedDelegate({ delegateAction, signature })
        });
      }
      exports2.actionCreators = {
        addKey,
        createAccount,
        deleteAccount,
        deleteKey,
        deployContract,
        fullAccessKey,
        functionCall,
        functionCallAccessKey,
        signedDelegate,
        stake,
        transfer
      };
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/prefix.js
  var require_prefix3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/prefix.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DelegateActionPrefix = void 0;
      var types_1 = require_lib25();
      var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
      var NEP = {
        MetaTransactions: 366
      };
      var NEPPrefix = class extends types_1.Assignable {
      };
      var ActionableMessagePrefix = class extends NEPPrefix {
        /** Given the NEP number, set the prefix using 2^30 as the offset **/
        constructor(prefix) {
          super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
        }
      };
      var DelegateActionPrefix = class extends ActionableMessagePrefix {
        constructor() {
          super(NEP.MetaTransactions);
        }
      };
      exports2.DelegateActionPrefix = DelegateActionPrefix;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/schema.js
  var require_schema3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/schema.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SCHEMA = exports2.SignedTransaction = exports2.Transaction = exports2.decodeSignedTransaction = exports2.decodeTransaction = exports2.encodeTransaction = exports2.encodeSignedDelegate = exports2.encodeDelegateAction = void 0;
      var types_1 = require_lib25();
      var borsh_1 = require_cjs();
      var prefix_1 = require_prefix3();
      function encodeDelegateAction(delegateAction) {
        return new Uint8Array([
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateActionPrefix, new prefix_1.DelegateActionPrefix()),
          ...(0, borsh_1.serialize)(exports2.SCHEMA.DelegateAction, delegateAction)
        ]);
      }
      exports2.encodeDelegateAction = encodeDelegateAction;
      function encodeSignedDelegate(signedDelegate) {
        return (0, borsh_1.serialize)(exports2.SCHEMA.SignedDelegate, signedDelegate);
      }
      exports2.encodeSignedDelegate = encodeSignedDelegate;
      function encodeTransaction(transaction) {
        const schema = transaction instanceof SignedTransaction ? exports2.SCHEMA.SignedTransaction : exports2.SCHEMA.Transaction;
        return (0, borsh_1.serialize)(schema, transaction);
      }
      exports2.encodeTransaction = encodeTransaction;
      function decodeTransaction(bytes) {
        return new Transaction((0, borsh_1.deserialize)(exports2.SCHEMA.Transaction, bytes));
      }
      exports2.decodeTransaction = decodeTransaction;
      function decodeSignedTransaction(bytes) {
        return new SignedTransaction((0, borsh_1.deserialize)(exports2.SCHEMA.SignedTransaction, bytes));
      }
      exports2.decodeSignedTransaction = decodeSignedTransaction;
      var Transaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeTransaction(bytes);
        }
      };
      exports2.Transaction = Transaction;
      var SignedTransaction = class extends types_1.Assignable {
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeSignedTransaction(bytes);
        }
      };
      exports2.SignedTransaction = SignedTransaction;
      exports2.SCHEMA = new class BorshSchema {
        constructor() {
          this.Signature = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 64 } }
            }
          };
          this.PublicKey = {
            struct: {
              keyType: "u8",
              data: { array: { type: "u8", len: 32 } }
            }
          };
          this.FunctionCallPermission = {
            struct: {
              allowance: { option: "u128" },
              receiverId: "string",
              methodNames: { array: { type: "string" } }
            }
          };
          this.FullAccessPermission = {
            struct: {}
          };
          this.AccessKeyPermission = {
            enum: [
              { struct: { functionCall: this.FunctionCallPermission } },
              { struct: { fullAccess: this.FullAccessPermission } }
            ]
          };
          this.AccessKey = {
            struct: {
              nonce: "u64",
              permission: this.AccessKeyPermission
            }
          };
          this.CreateAccount = {
            struct: {}
          };
          this.DeployContract = {
            struct: {
              code: { array: { type: "u8" } }
            }
          };
          this.FunctionCall = {
            struct: {
              methodName: "string",
              args: { array: { type: "u8" } },
              gas: "u64",
              deposit: "u128"
            }
          };
          this.Transfer = {
            struct: {
              deposit: "u128"
            }
          };
          this.Stake = {
            struct: {
              stake: "u128",
              publicKey: this.PublicKey
            }
          };
          this.AddKey = {
            struct: {
              publicKey: this.PublicKey,
              accessKey: this.AccessKey
            }
          };
          this.DeleteKey = {
            struct: {
              publicKey: this.PublicKey
            }
          };
          this.DeleteAccount = {
            struct: {
              beneficiaryId: "string"
            }
          };
          this.DelegateActionPrefix = {
            struct: {
              prefix: "u32"
            }
          };
          this.ClassicActions = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } }
            ]
          };
          this.DelegateAction = {
            struct: {
              senderId: "string",
              receiverId: "string",
              actions: { array: { type: this.ClassicActions } },
              nonce: "u64",
              maxBlockHeight: "u64",
              publicKey: this.PublicKey
            }
          };
          this.SignedDelegate = {
            struct: {
              delegateAction: this.DelegateAction,
              signature: this.Signature
            }
          };
          this.Action = {
            enum: [
              { struct: { createAccount: this.CreateAccount } },
              { struct: { deployContract: this.DeployContract } },
              { struct: { functionCall: this.FunctionCall } },
              { struct: { transfer: this.Transfer } },
              { struct: { stake: this.Stake } },
              { struct: { addKey: this.AddKey } },
              { struct: { deleteKey: this.DeleteKey } },
              { struct: { deleteAccount: this.DeleteAccount } },
              { struct: { signedDelegate: this.SignedDelegate } }
            ]
          };
          this.Transaction = {
            struct: {
              signerId: "string",
              publicKey: this.PublicKey,
              nonce: "u64",
              receiverId: "string",
              blockHash: { array: { type: "u8", len: 32 } },
              actions: { array: { type: this.Action } }
            }
          };
          this.SignedTransaction = {
            struct: {
              transaction: this.Transaction,
              signature: this.Signature
            }
          };
        }
      }();
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/create_transaction.js
  var require_create_transaction3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/create_transaction.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createTransaction = void 0;
      var schema_1 = require_schema3();
      function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
        return new schema_1.Transaction({
          signerId,
          publicKey,
          nonce: txNonce,
          receiverId,
          actions,
          blockHash
        });
      }
      exports2.createTransaction = createTransaction;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/delegate.js
  var require_delegate3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/delegate.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildDelegateAction = exports2.DelegateAction = void 0;
      var types_1 = require_lib25();
      var action_creators_1 = require_action_creators3();
      var { addKey, createAccount, deleteAccount, deleteKey, deployContract, functionCall, stake, transfer } = action_creators_1.actionCreators;
      var DelegateAction = class extends types_1.Assignable {
      };
      exports2.DelegateAction = DelegateAction;
      function buildDelegateAction({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
        return new DelegateAction({
          senderId,
          receiverId,
          actions: actions.map((a) => {
            if (!a.type && !a.params) {
              return a;
            }
            switch (a.type) {
              case "AddKey": {
                const { publicKey: publicKey2, accessKey } = a.params;
                return addKey(publicKey2, accessKey);
              }
              case "CreateAccount": {
                return createAccount(a.params.createAccount);
              }
              case "DeleteAccount": {
                return deleteAccount(a.params.deleteAccount);
              }
              case "DeleteKey": {
                return deleteKey(a.params.publicKey);
              }
              case "DeployContract": {
                return deployContract(a.params.code);
              }
              case "FunctionCall": {
                const { methodName, args, gas, deposit } = a.params;
                return functionCall(methodName, args, gas, deposit);
              }
              case "Stake": {
                return stake(a.params.stake, a.params.publicKey);
              }
              case "Transfer": {
                const { deposit } = a.params;
                return transfer(deposit);
              }
            }
            throw new Error("Unrecognized action");
          }),
          nonce,
          maxBlockHeight,
          publicKey
        });
      }
      exports2.buildDelegateAction = buildDelegateAction;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/hashes/_assert.js
  var require_assert10 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error(`digestInto() expects output buffer of length at least ${min7}`);
        }
      }
      exports2.output = output;
      var assert = { number, bool, bytes, hash, exists, output };
      exports2.default = assert;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/hashes/crypto.js
  var require_crypto11 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/hashes/utils.js
  var require_utils25 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto11();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        if (!isBytes(data7))
          throw new Error(`expected Uint8Array, got ${typeof data7}`);
        return data7;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/hashes/_sha2.js
  var require_sha210 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert10();
      var utils_js_1 = require_utils25();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.SHA2 = SHA2;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@noble/hashes/sha256.js
  var require_sha2564 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@noble/hashes/sha256.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha224 = exports2.sha256 = void 0;
      var _sha2_js_1 = require_sha210();
      var utils_js_1 = require_utils25();
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/signature.js
  var require_signature3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/signature.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Signature = void 0;
      var types_1 = require_lib25();
      var Signature = class extends types_1.Assignable {
      };
      exports2.Signature = Signature;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/sign.js
  var require_sign3 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/sign.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signDelegateAction = exports2.signTransaction = void 0;
      var sha256_1 = require_sha2564();
      var actions_1 = require_actions3();
      var create_transaction_1 = require_create_transaction3();
      var schema_1 = require_schema3();
      var signature_1 = require_signature3();
      function signTransactionObject(transaction, signer, accountId, networkId) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeTransaction)(transaction);
          const hash = new Uint8Array((0, sha256_1.sha256)(message));
          const signature = yield signer.signMessage(message, accountId, networkId);
          const signedTx = new schema_1.SignedTransaction({
            transaction,
            signature: new signature_1.Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })
          });
          return [hash, signedTx];
        });
      }
      function signTransaction(...args) {
        return __awaiter6(this, void 0, void 0, function* () {
          if (args[0].constructor === schema_1.Transaction) {
            const [transaction, signer, accountId, networkId] = args;
            return signTransactionObject(transaction, signer, accountId, networkId);
          } else {
            const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
            const publicKey = yield signer.getPublicKey(accountId, networkId);
            const transaction = (0, create_transaction_1.createTransaction)(accountId, publicKey, receiverId, nonce, actions, blockHash);
            return signTransactionObject(transaction, signer, accountId, networkId);
          }
        });
      }
      exports2.signTransaction = signTransaction;
      function signDelegateAction({ delegateAction, signer }) {
        return __awaiter6(this, void 0, void 0, function* () {
          const message = (0, schema_1.encodeDelegateAction)(delegateAction);
          const signature = yield signer.sign(message);
          const signedDelegateAction = new actions_1.SignedDelegate({
            delegateAction,
            signature: new signature_1.Signature({
              keyType: delegateAction.publicKey.keyType,
              data: signature
            })
          });
          return {
            hash: new Uint8Array((0, sha256_1.sha256)(message)),
            signedDelegateAction
          };
        });
      }
      exports2.signDelegateAction = signDelegateAction;
    }
  });

  // node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/index.js
  var require_lib28 = __commonJS({
    "node_modules/@near-js/wallet-account/node_modules/@near-js/transactions/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_action_creators3(), exports2);
      __exportStar(require_actions3(), exports2);
      __exportStar(require_create_transaction3(), exports2);
      __exportStar(require_delegate3(), exports2);
      __exportStar(require_schema3(), exports2);
      __exportStar(require_sign3(), exports2);
      __exportStar(require_signature3(), exports2);
    }
  });

  // node_modules/@near-js/wallet-account/lib/wallet_account.js
  var require_wallet_account = __commonJS({
    "node_modules/@near-js/wallet-account/lib/wallet_account.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConnectedWalletAccount = exports2.WalletConnection = void 0;
      var accounts_1 = require_lib24();
      var crypto_1 = require_lib27();
      var utils_1 = require_lib26();
      var transactions_1 = require_lib28();
      var borsh_1 = require_cjs();
      var LOGIN_WALLET_URL_SUFFIX = "/login/";
      var MULTISIG_HAS_METHOD = "add_request_and_confirm";
      var LOCAL_STORAGE_KEY_SUFFIX = "_wallet_auth_key";
      var PENDING_ACCESS_KEY_PREFIX = "pending_key";
      var WalletConnection2 = class {
        constructor(near, appKeyPrefix) {
          if (typeof appKeyPrefix !== "string") {
            throw new Error("Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor");
          }
          if (typeof window === "undefined") {
            return new Proxy(this, {
              get(target, property) {
                if (property === "isSignedIn") {
                  return () => false;
                }
                if (property === "getAccountId") {
                  return () => "";
                }
                if (target[property] && typeof target[property] === "function") {
                  return () => {
                    throw new Error("No window found in context, please ensure you are using WalletConnection on the browser");
                  };
                }
                return target[property];
              }
            });
          }
          this._near = near;
          const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
          const authData = JSON.parse(window.localStorage.getItem(authDataKey));
          this._networkId = near.config.networkId;
          this._walletBaseUrl = near.config.walletUrl;
          appKeyPrefix = appKeyPrefix || near.config.contractName || "default";
          this._keyStore = near.connection.signer.keyStore;
          this._authData = authData || { allKeys: [] };
          this._authDataKey = authDataKey;
          if (!this.isSignedIn()) {
            this._completeSignInPromise = this._completeSignInWithAccessKey();
          }
        }
        /**
         * Returns true, if this WalletConnection is authorized with the wallet.
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.isSignedIn();
         * ```
         */
        isSignedIn() {
          return !!this._authData.accountId;
        }
        /**
         * Returns promise of completing signing in after redirecting from wallet
         * @example
         * ```js
         * // on login callback page
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.isSignedIn(); // false
         * await wallet.isSignedInAsync(); // true
         * ```
         */
        isSignedInAsync() {
          return __awaiter6(this, void 0, void 0, function* () {
            if (!this._completeSignInPromise) {
              return this.isSignedIn();
            }
            yield this._completeSignInPromise;
            return this.isSignedIn();
          });
        }
        /**
         * Returns authorized Account ID.
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.getAccountId();
         * ```
         */
        getAccountId() {
          return this._authData.accountId || "";
        }
        /**
         * Constructs string URL to the wallet authentication page.
         * @param options An optional options object
         * @param options.contractId The NEAR account where the contract is deployed
         * @param options.successUrl URL to redirect upon success. Default: current url
         * @param options.failureUrl URL to redirect upon failure. Default: current url
         *
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * // return string URL to the NEAR Wallet
         * const url = await wallet.requestSignInUrl({ contractId: 'account-with-deploy-contract.near' });
         * ```
         */
        requestSignInUrl({ contractId, methodNames, successUrl, failureUrl }) {
          return __awaiter6(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
            newUrl.searchParams.set("success_url", successUrl || currentUrl.href);
            newUrl.searchParams.set("failure_url", failureUrl || currentUrl.href);
            if (contractId) {
              const contractAccount = yield this._near.account(contractId);
              yield contractAccount.state();
              newUrl.searchParams.set("contract_id", contractId);
              const accessKey = crypto_1.KeyPair.fromRandom("ed25519");
              newUrl.searchParams.set("public_key", accessKey.getPublicKey().toString());
              yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
            }
            if (methodNames) {
              methodNames.forEach((methodName) => {
                newUrl.searchParams.append("methodNames", methodName);
              });
            }
            return newUrl.toString();
          });
        }
        /**
         * Redirects current page to the wallet authentication page.
         * @param options An optional options object
         * @param options.contractId The NEAR account where the contract is deployed
         * @param options.successUrl URL to redirect upon success. Default: current url
         * @param options.failureUrl URL to redirect upon failure. Default: current url
         *
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * // redirects to the NEAR Wallet
         * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
         * ```
         */
        requestSignIn(options) {
          return __awaiter6(this, void 0, void 0, function* () {
            const url = yield this.requestSignInUrl(options);
            window.location.assign(url);
          });
        }
        /**
         * Constructs string URL to the wallet to sign a transaction or batch of transactions.
         *
         * @param options A required options object
         * @param options.transactions List of transactions to sign
         * @param options.callbackUrl URL to redirect upon success. Default: current url
         * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
         *
         */
        requestSignTransactionsUrl({ transactions: transactions4, meta, callbackUrl }) {
          const currentUrl = new URL(window.location.href);
          const newUrl = new URL("sign", this._walletBaseUrl);
          newUrl.searchParams.set("transactions", transactions4.map((transaction) => (0, borsh_1.serialize)(transactions_1.SCHEMA.Transaction, transaction)).map((serialized) => Buffer.from(serialized).toString("base64")).join(","));
          newUrl.searchParams.set("callbackUrl", callbackUrl || currentUrl.href);
          if (meta)
            newUrl.searchParams.set("meta", meta);
          return newUrl.toString();
        }
        /**
         * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the wallet.
         *
         * @param options A required options object
         * @param options.transactions List of transactions to sign
         * @param options.callbackUrl URL to redirect upon success. Default: current url
         * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
         *
         */
        requestSignTransactions(options) {
          const url = this.requestSignTransactionsUrl(options);
          window.location.assign(url);
        }
        /**
         * @hidden
         * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
         */
        _completeSignInWithAccessKey() {
          return __awaiter6(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const publicKey = currentUrl.searchParams.get("public_key") || "";
            const allKeys = (currentUrl.searchParams.get("all_keys") || "").split(",");
            const accountId = currentUrl.searchParams.get("account_id") || "";
            if (accountId) {
              const authData = {
                accountId,
                allKeys
              };
              window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));
              if (publicKey) {
                yield this._moveKeyFromTempToPermanent(accountId, publicKey);
              }
              this._authData = authData;
            }
            currentUrl.searchParams.delete("public_key");
            currentUrl.searchParams.delete("all_keys");
            currentUrl.searchParams.delete("account_id");
            currentUrl.searchParams.delete("meta");
            currentUrl.searchParams.delete("transactionHashes");
            window.history.replaceState({}, document.title, currentUrl.toString());
          });
        }
        /**
         * @hidden
         * @param accountId The NEAR account owning the given public key
         * @param publicKey The public key being set to the key store
         */
        _moveKeyFromTempToPermanent(accountId, publicKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
            yield this._keyStore.setKey(this._networkId, accountId, keyPair);
            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
          });
        }
        /**
         * Sign out from the current account
         * @example
         * walletConnection.signOut();
         */
        signOut() {
          this._authData = {};
          window.localStorage.removeItem(this._authDataKey);
        }
        /**
         * Returns the current connected wallet account
         */
        account() {
          if (!this._connectedAccount) {
            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
          }
          return this._connectedAccount;
        }
      };
      exports2.WalletConnection = WalletConnection2;
      var ConnectedWalletAccount = class extends accounts_1.Account {
        constructor(walletConnection, connection, accountId) {
          super(connection, accountId);
          this.walletConnection = walletConnection;
        }
        // Overriding Account methods
        /**
         * Sign a transaction by redirecting to the NEAR Wallet
         * @see {@link WalletConnection#requestSignTransactions}
         * @param options An optional options object
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions An array of transaction actions to be performed.
         * @param options.walletMeta Additional metadata to be included in the wallet signing request.
         * @param options.walletCallbackUrl URL to redirect upon completion of the wallet signing process. Default: current URL.
         */
        signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter6(this, void 0, void 0, function* () {
            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);
            if (!accessKey) {
              throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
            }
            if (localKey && localKey.toString() === accessKey.public_key) {
              try {
                return yield _super.signAndSendTransaction.call(this, { receiverId, actions });
              } catch (e) {
                if (e.type === "NotEnoughAllowance") {
                  accessKey = yield this.accessKeyForTransaction(receiverId, actions);
                } else {
                  throw e;
                }
              }
            }
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = (0, utils_1.baseDecode)(block.header.hash);
            const publicKey = crypto_1.PublicKey.from(accessKey.public_key);
            const nonce = accessKey.access_key.nonce + BigInt(1);
            const transaction = (0, transactions_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
            yield this.walletConnection.requestSignTransactions({
              transactions: [transaction],
              meta: walletMeta,
              callbackUrl: walletCallbackUrl
            });
            return new Promise((resolve5, reject5) => {
              setTimeout(() => {
                reject5(new Error("Failed to redirect to sign transaction"));
              }, 1e3);
            });
          });
        }
        /**
         * Check if given access key allows the function call or method attempted in transaction
         * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
         * @param receiverId The NEAR account attempting to have access
         * @param actions The action(s) needed to be checked for access
         */
        accessKeyMatchesTransaction(accessKey, receiverId, actions) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { access_key: { permission } } = accessKey;
            if (permission === "FullAccess") {
              return true;
            }
            if (permission.FunctionCall) {
              const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
              if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                return true;
              }
              if (allowedReceiverId === receiverId) {
                if (actions.length !== 1) {
                  return false;
                }
                const [{ functionCall }] = actions;
                return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
              }
            }
            return false;
          });
        }
        /**
         * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
         * @param receiverId The NEAR account seeking the access key for a transaction
         * @param actions The action(s) sought to gain access to
         * @param localKey A local public key provided to check for access
         */
        accessKeyForTransaction(receiverId, actions, localKey) {
          return __awaiter6(this, void 0, void 0, function* () {
            const accessKeys = yield this.getAccessKeys();
            if (localKey) {
              const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
              if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
              }
            }
            const walletKeys = this.walletConnection._authData.allKeys;
            for (const accessKey of accessKeys) {
              if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
              }
            }
            return null;
          });
        }
      };
      exports2.ConnectedWalletAccount = ConnectedWalletAccount;
    }
  });

  // node_modules/@near-js/wallet-account/lib/index.js
  var require_lib29 = __commonJS({
    "node_modules/@near-js/wallet-account/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WalletConnection = exports2.ConnectedWalletAccount = exports2.Near = void 0;
      var near_1 = require_near();
      Object.defineProperty(exports2, "Near", { enumerable: true, get: function() {
        return near_1.Near;
      } });
      var wallet_account_1 = require_wallet_account();
      Object.defineProperty(exports2, "ConnectedWalletAccount", { enumerable: true, get: function() {
        return wallet_account_1.ConnectedWalletAccount;
      } });
      Object.defineProperty(exports2, "WalletConnection", { enumerable: true, get: function() {
        return wallet_account_1.WalletConnection;
      } });
    }
  });

  // node_modules/near-api-js/lib/near.js
  var require_near2 = __commonJS({
    "node_modules/near-api-js/lib/near.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Near = void 0;
      var wallet_account_1 = require_lib29();
      Object.defineProperty(exports2, "Near", { enumerable: true, get: function() {
        return wallet_account_1.Near;
      } });
    }
  });

  // node_modules/near-api-js/lib/wallet-account.js
  var require_wallet_account2 = __commonJS({
    "node_modules/near-api-js/lib/wallet-account.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WalletConnection = exports2.ConnectedWalletAccount = void 0;
      var wallet_account_1 = require_lib29();
      Object.defineProperty(exports2, "ConnectedWalletAccount", { enumerable: true, get: function() {
        return wallet_account_1.ConnectedWalletAccount;
      } });
      Object.defineProperty(exports2, "WalletConnection", { enumerable: true, get: function() {
        return wallet_account_1.WalletConnection;
      } });
    }
  });

  // node_modules/near-api-js/lib/common-index.js
  var require_common_index = __commonJS({
    "node_modules/near-api-js/lib/common-index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WalletConnection = exports2.ConnectedWalletAccount = exports2.Near = exports2.KeyPair = exports2.Signer = exports2.InMemorySigner = exports2.Contract = exports2.Connection = exports2.Account = exports2.multisig = exports2.validators = exports2.transactions = exports2.utils = exports2.providers = exports2.accountCreator = void 0;
      var providers4 = __importStar(require_providers());
      exports2.providers = providers4;
      var utils5 = __importStar(require_utils21());
      exports2.utils = utils5;
      var transactions4 = __importStar(require_transaction());
      exports2.transactions = transactions4;
      var validators = __importStar(require_validators6());
      exports2.validators = validators;
      var account_1 = require_account2();
      Object.defineProperty(exports2, "Account", { enumerable: true, get: function() {
        return account_1.Account;
      } });
      var multisig = __importStar(require_account_multisig2());
      exports2.multisig = multisig;
      var accountCreator = __importStar(require_account_creator2());
      exports2.accountCreator = accountCreator;
      var connection_1 = require_connection2();
      Object.defineProperty(exports2, "Connection", { enumerable: true, get: function() {
        return connection_1.Connection;
      } });
      var signer_1 = require_signer2();
      Object.defineProperty(exports2, "Signer", { enumerable: true, get: function() {
        return signer_1.Signer;
      } });
      Object.defineProperty(exports2, "InMemorySigner", { enumerable: true, get: function() {
        return signer_1.InMemorySigner;
      } });
      var contract_1 = require_contract2();
      Object.defineProperty(exports2, "Contract", { enumerable: true, get: function() {
        return contract_1.Contract;
      } });
      var key_pair_1 = require_key_pair4();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var near_1 = require_near2();
      Object.defineProperty(exports2, "Near", { enumerable: true, get: function() {
        return near_1.Near;
      } });
      var wallet_account_1 = require_wallet_account2();
      Object.defineProperty(exports2, "ConnectedWalletAccount", { enumerable: true, get: function() {
        return wallet_account_1.ConnectedWalletAccount;
      } });
      Object.defineProperty(exports2, "WalletConnection", { enumerable: true, get: function() {
        return wallet_account_1.WalletConnection;
      } });
    }
  });

  // node_modules/near-api-js/lib/browser-connect.js
  var require_browser_connect = __commonJS({
    "node_modules/near-api-js/lib/browser-connect.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.connect = void 0;
      var near_1 = require_near2();
      function connect3(config4) {
        return __awaiter6(this, void 0, void 0, function* () {
          return new near_1.Near(config4);
        });
      }
      exports2.connect = connect3;
    }
  });

  // node_modules/near-api-js/lib/browser-index.js
  var require_browser_index2 = __commonJS({
    "node_modules/near-api-js/lib/browser-index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.keyStores = void 0;
      exports2.keyStores = __importStar(require_browser_index());
      __exportStar(require_common_index(), exports2);
      __exportStar(require_browser_connect(), exports2);
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function(module3, exports3) {
        "use strict";
        function assert(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base3, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base3 === "le" || base3 === "be") {
              endian = base3;
              base3 = 10;
            }
            this._init(number || 0, base3 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max7(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN.min = function min7(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN.prototype._init = function init3(number, base3, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base3, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base3, endian);
          }
          if (base3 === "hex") {
            base3 = 16;
          }
          assert(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base3 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base3, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base3, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base3, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base3, endian);
        };
        BN.prototype._initArray = function _initArray(number, base3, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off3 = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off3 & 67108863;
              this.words[j + 1] = w >>> 26 - off3 & 67108863;
              off3 += 24;
              if (off3 >= 26) {
                off3 -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off3 & 67108863;
              this.words[j + 1] = w >>> 26 - off3 & 67108863;
              off3 += 24;
              if (off3 >= 26) {
                off3 -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off3 = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off3;
              this.words[j] |= w & 67108863;
              if (off3 >= 18) {
                off3 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off3 += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off3;
              this.words[j] |= w & 67108863;
              if (off3 >= 18) {
                off3 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off3 += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base3, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base3 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base3);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow3 = 1;
            word = parseBase(number, i, number.length, base3);
            for (i = 0; i < mod; i++) {
              pow3 *= base3;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN.prototype.copy = function copy4(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
          } catch (e) {
            BN.prototype.inspect = inspect3;
          }
        } else {
          BN.prototype.inspect = inspect3;
        }
        function inspect3() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString18(base3, padding) {
          base3 = base3 || 10;
          padding = padding | 0 || 1;
          var out;
          if (base3 === 16 || base3 === "hex") {
            out = "";
            var off3 = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off3 | carry) & 16777215).toString(16);
              carry = w >>> 24 - off3 & 16777215;
              off3 += 2;
              if (off3 >= 26) {
                off3 -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
            var groupSize = groupSizes[base3];
            var groupBase = groupBases[base3];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base3);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON5() {
          return this.toString(16, 2);
        };
        if (Buffer3) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer3, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength3 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength3);
          assert(byteLength3 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix7 = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix7](res, byteLength3);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi2 = this._countBits(w);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off3 = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off3] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength3() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off3 + 1);
          if (val) {
            this.words[off3] = this.words[off3] | 1 << wbit;
          } else {
            this.words[off3] = this.words[off3] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow3(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs2() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split7(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split7(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next3 = input.words[i] | 0;
            input.words[i - 10] = (next3 & mask) << 4 | prev >>> 22;
            prev = next3;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi2 = (num.words[i] | 0) * 19 + carry;
            var lo = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i] = lo;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow3);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a, num) {
          if (num.isZero()) return new BN(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports2);
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var _Buffer = require_safe_buffer().Buffer;
      function base3(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode3(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (psz < source.length) {
            var charCode = source.charCodeAt(psz);
            if (charCode > 255) {
              return;
            }
            var carry = BASE_MAP[charCode];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      }
      module2.exports = base3;
    }
  });

  // node_modules/bs58/index.js
  var require_bs587 = __commonJS({
    "node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/text-encoding-utf-8/lib/encoding.lib.js
  var require_encoding_lib = __commonJS({
    "node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      function inRange(a, min7, max7) {
        return min7 <= a && a <= max7;
      }
      function ToDictionary(o) {
        if (o === void 0) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string) {
        var s = String(string);
        var n = s.length;
        var i = 0;
        var u = [];
        while (i < n) {
          var c = s.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            u.push(c);
          } else if (56320 <= c && c <= 57343) {
            u.push(65533);
          } else if (55296 <= c && c <= 56319) {
            if (i === n - 1) {
              u.push(65533);
            } else {
              var d = string.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1;
              } else {
                u.push(65533);
              }
            }
          }
          i += 1;
        }
        return u;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      var end_of_stream = -1;
      function Stream2(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream2.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.shift();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
         */
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.unshift(tokens.pop());
          } else {
            this.tokens.unshift(token);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
         */
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.push(tokens.shift());
          } else {
            this.tokens.push(token);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder2(encoding, options) {
        if (!(this instanceof TextDecoder2)) {
          return new TextDecoder2(encoding, options);
        }
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._BOMseen = false;
        this._decoder = null;
        this._fatal = Boolean(options["fatal"]);
        this._ignoreBOM = Boolean(options["ignoreBOM"]);
        Object.defineProperty(this, "encoding", { value: "utf-8" });
        Object.defineProperty(this, "fatal", { value: this._fatal });
        Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      TextDecoder2.prototype = {
        /**
         * @param {ArrayBufferView=} input The buffer of bytes to decode.
         * @param {Object=} options
         * @return {string} The decoded string.
         */
        decode: function decode(input, options) {
          var bytes;
          if (typeof input === "object" && input instanceof ArrayBuffer) {
            bytes = new Uint8Array(input);
          } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
            bytes = new Uint8Array(
              input.buffer,
              input.byteOffset,
              input.byteLength
            );
          } else {
            bytes = new Uint8Array(0);
          }
          options = ToDictionary(options);
          if (!this._streaming) {
            this._decoder = new UTF8Decoder({ fatal: this._fatal });
            this._BOMseen = false;
          }
          this._streaming = Boolean(options["stream"]);
          var input_stream = new Stream2(bytes);
          var code_points = [];
          var result;
          while (!input_stream.endOfStream()) {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          }
          if (!this._streaming) {
            do {
              result = this._decoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (result === null)
                continue;
              if (Array.isArray(result))
                code_points.push.apply(
                  code_points,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                code_points.push(result);
            } while (!input_stream.endOfStream());
            this._decoder = null;
          }
          if (code_points.length) {
            if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
              if (code_points[0] === 65279) {
                this._BOMseen = true;
                code_points.shift();
              } else {
                this._BOMseen = true;
              }
            }
          }
          return codePointsToString(code_points);
        }
      };
      function TextEncoder2(encoding, options) {
        if (!(this instanceof TextEncoder2))
          return new TextEncoder2(encoding, options);
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._encoder = null;
        this._options = { fatal: Boolean(options["fatal"]) };
        Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      TextEncoder2.prototype = {
        /**
         * @param {string=} opt_string The string to encode.
         * @param {Object=} options
         * @return {Uint8Array} Encoded bytes, as a Uint8Array.
         */
        encode: function encode3(opt_string, options) {
          opt_string = opt_string ? String(opt_string) : "";
          options = ToDictionary(options);
          if (!this._streaming)
            this._encoder = new UTF8Encoder(this._options);
          this._streaming = Boolean(options["stream"]);
          var bytes = [];
          var input_stream = new Stream2(stringToCodePoints(opt_string));
          var result;
          while (!input_stream.endOfStream()) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          if (!this._streaming) {
            while (true) {
              result = this._encoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (Array.isArray(result))
                bytes.push.apply(
                  bytes,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                bytes.push(result);
            }
            this._encoder = null;
          }
          return new Uint8Array(bytes);
        }
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            }
            if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite - 192;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite - 224;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240;
            } else {
              return decoderError(fatal);
            }
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_bytes_seen += 1;
          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange(code_point, 0, 127))
            return code_point;
          var count, offset;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset = 240;
          }
          var bytes = [(code_point >> 6 * count) + offset];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | temp & 63);
            count -= 1;
          }
          return bytes;
        };
      }
      exports2.TextEncoder = TextEncoder2;
      exports2.TextDecoder = TextDecoder2;
    }
  });

  // node_modules/@near-wallet-selector/core/node_modules/borsh/lib/index.js
  var require_lib30 = __commonJS({
    "node_modules/@near-wallet-selector/core/node_modules/borsh/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs587());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports2.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str) {
          this.maybeResize();
          const b = Buffer.from(str, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array) {
          this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
          this.maybeResize();
          this.writeU32(array.length);
          for (const elem of array) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports2.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports2.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize3(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports2.serialize = serialize3;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map3 = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map3.set(key, val);
            }
            return map3;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports2.deserialize = deserialize2;
      function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports2.deserializeUnchecked = deserializeUnchecked;
    }
  });

  // node_modules/js-sha256/src/sha256.js
  var require_sha2565 = __commonJS({
    "node_modules/js-sha256/src/sha256.js"(exports, module) {
      init_process();
      init_buffer();
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = globalThis;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "node_modules/react/cjs/react.production.min.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var l = Symbol.for("react.element");
      var n = Symbol.for("react.portal");
      var p = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r = Symbol.for("react.profiler");
      var t = Symbol.for("react.provider");
      var u = Symbol.for("react.context");
      var v = Symbol.for("react.forward_ref");
      var w = Symbol.for("react.suspense");
      var x = Symbol.for("react.memo");
      var y = Symbol.for("react.lazy");
      var z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K2 = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K2.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape2(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K2 };
      exports2.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      exports2.Component = E;
      exports2.Fragment = p;
      exports2.Profiler = r;
      exports2.PureComponent = G;
      exports2.StrictMode = q;
      exports2.Suspense = w;
      exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports2.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K2.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      exports2.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      exports2.createElement = M;
      exports2.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      exports2.createRef = function() {
        return { current: null };
      };
      exports2.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      exports2.isValidElement = O;
      exports2.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      exports2.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      exports2.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      exports2.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      exports2.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      exports2.useContext = function(a) {
        return U.current.useContext(a);
      };
      exports2.useDebugValue = function() {
      };
      exports2.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      exports2.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      exports2.useId = function() {
        return U.current.useId();
      };
      exports2.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      exports2.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      exports2.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      exports2.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      exports2.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      exports2.useRef = function(a) {
        return U.current.useRef(a);
      };
      exports2.useState = function(a) {
        return U.current.useState(a);
      };
      exports2.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      exports2.useTransition = function() {
        return U.current.useTransition();
      };
      exports2.version = "18.2.0";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      if (true) {
        module2.exports = require_react_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var f = require_react();
      var k = Symbol.for("react.element");
      var l = Symbol.for("react.fragment");
      var m = Object.prototype.hasOwnProperty;
      var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      exports2.Fragment = l;
      exports2.jsx = q;
      exports2.jsxs = q;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      if (true) {
        module2.exports = require_react_jsx_runtime_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.min.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports2.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports2.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K2(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports2.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K2(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports2.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports2.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K2(a, b) {
        L = D(function() {
          a(exports2.unstable_now());
        }, b);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports2.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b, c) {
        var d = exports2.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K2(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports2.unstable_shouldYield = M;
      exports2.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      if (true) {
        module2.exports = require_scheduler_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.min.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var aa = require_react();
      var ca = require_scheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb;
      var nb = (function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      })(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      var Mb;
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id7, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id7, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id7 = null;
      function Yc(a, b, c, d) {
        id7 = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id7 = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg2(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg2(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      var Mg = Uf(null);
      var Ng = null;
      var Og = null;
      var Pg = null;
      function Qg() {
        Pg = Og = Ng = null;
      }
      function Rg(a) {
        var b = Mg.current;
        E(Mg);
        a._currentValue = b;
      }
      function Sg(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function Tg(a, b) {
        Ng = a;
        Pg = Og = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
      }
      function Vg(a) {
        var b = a._currentValue;
        if (Pg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
          if (null === Ng) throw Error(p(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else Og = Og.next = a;
        return b;
      }
      var Wg = null;
      function Xg(a) {
        null === Wg ? Wg = [a] : Wg.push(a);
      }
      function Yg(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return Zg(a, d);
      }
      function Zg(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var $g = false;
      function ah(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function bh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function ch(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function dh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K2 & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return Zg(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return Zg(a, c);
      }
      function eh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function fh(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function gh(a, b, c, d) {
        var e = a.updateQueue;
        $g = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    $g = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          hh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function ih(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var jh = new aa.Component().refs;
      function kh(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var nh = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = L(), e = lh(a), f = ch(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = dh(a, f, e);
        null !== b && (mh(b, a, e, d), eh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = L(), e = lh(a), f = ch(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = dh(a, f, e);
        null !== b && (mh(b, a, e, d), eh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = L(), d = lh(a), e = ch(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = dh(a, e, d);
        null !== b && (mh(b, a, d, c), eh(b, a, d));
      } };
      function oh(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function ph(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = nh;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function qh(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && nh.enqueueReplaceState(b, b.state, null);
      }
      function rh(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = jh;
        ah(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function sh(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              b2 === jh && (b2 = e.refs = {});
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function th(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function uh(a) {
        var b = a._init;
        return b(a._payload);
      }
      function vh(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = wh(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = xh(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && uh(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = sh(a2, b2, c2), d2.return = a2, d2;
          d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = sh(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = zh2(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Ah(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = zh2(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
            th(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            th(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            th(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = sh(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Ah(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = yh(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = sh(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = zh2(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            th(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = xh(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Bh = vh(true);
      var Ch = vh(false);
      var Dh = {};
      var Eh = Uf(Dh);
      var Fh = Uf(Dh);
      var Gh = Uf(Dh);
      function Hh(a) {
        if (a === Dh) throw Error(p(174));
        return a;
      }
      function Ih(a, b) {
        G(Gh, b);
        G(Fh, a);
        G(Eh, Dh);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(Eh);
        G(Eh, b);
      }
      function Jh() {
        E(Eh);
        E(Fh);
        E(Gh);
      }
      function Kh(a) {
        Hh(Gh.current);
        var b = Hh(Eh.current);
        var c = lb(b, a.type);
        b !== c && (G(Fh, a), G(Eh, c));
      }
      function Lh(a) {
        Fh.current === a && (E(Eh), E(Fh));
      }
      var M = Uf(0);
      function Mh(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Nh = [];
      function Oh() {
        for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
        Nh.length = 0;
      }
      var Ph = ua.ReactCurrentDispatcher;
      var Qh = ua.ReactCurrentBatchConfig;
      var Rh = 0;
      var N = null;
      var O = null;
      var P = null;
      var Sh = false;
      var Th = false;
      var Uh = 0;
      var Vh = 0;
      function Q() {
        throw Error(p(321));
      }
      function Wh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Xh(a, b, c, d, e, f) {
        Rh = f;
        N = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
        a = c(d, e);
        if (Th) {
          f = 0;
          do {
            Th = false;
            Uh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            P = O = null;
            b.updateQueue = null;
            Ph.current = $h;
            a = c(d, e);
          } while (Th);
        }
        Ph.current = ai;
        b = null !== O && null !== O.next;
        Rh = 0;
        P = O = N = null;
        Sh = false;
        if (b) throw Error(p(300));
        return a;
      }
      function bi() {
        var a = 0 !== Uh;
        Uh = 0;
        return a;
      }
      function ci() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
        return P;
      }
      function di() {
        if (null === O) {
          var a = N.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = O.next;
        var b = null === P ? N.memoizedState : P.next;
        if (null !== b) P = b, O = a;
        else {
          if (null === a) throw Error(p(310));
          O = a;
          a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
          null === P ? N.memoizedState = P = a : P = P.next = a;
        }
        return P;
      }
      function ei(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function fi(a) {
        var b = di(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = O, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Rh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              N.lanes |= m;
              hh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (Ug = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, N.lanes |= f, hh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function gi(a) {
        var b = di(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (Ug = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function hi2() {
      }
      function ii(a, b) {
        var c = N, d = di(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, Ug = true);
        d = d.queue;
        ji(ki.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
          c.flags |= 2048;
          li(9, mi.bind(null, c, d, e, b), void 0, null);
          if (null === R) throw Error(p(349));
          0 !== (Rh & 30) || ni(c, b, e);
        }
        return e;
      }
      function ni(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = N.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function mi(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        oi(b) && pi(a);
      }
      function ki(a, b, c) {
        return c(function() {
          oi(b) && pi(a);
        });
      }
      function oi(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function pi(a) {
        var b = Zg(a, 1);
        null !== b && mh(b, a, 1, -1);
      }
      function qi(a) {
        var b = ci();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ri.bind(null, N, a);
        return [b.memoizedState, a];
      }
      function li(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = N.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function si() {
        return di().memoizedState;
      }
      function ti(a, b, c, d) {
        var e = ci();
        N.flags |= a;
        e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function ui(a, b, c, d) {
        var e = di();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== O) {
          var g = O.memoizedState;
          f = g.destroy;
          if (null !== d && Wh(d, g.deps)) {
            e.memoizedState = li(b, c, f, d);
            return;
          }
        }
        N.flags |= a;
        e.memoizedState = li(1 | b, c, f, d);
      }
      function vi2(a, b) {
        return ti(8390656, 8, a, b);
      }
      function ji(a, b) {
        return ui(2048, 8, a, b);
      }
      function wi(a, b) {
        return ui(4, 2, a, b);
      }
      function xi(a, b) {
        return ui(4, 4, a, b);
      }
      function yi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function zi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ui(4, 4, yi.bind(null, b, a), c);
      }
      function Ai() {
      }
      function Bi(a, b) {
        var c = di();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Wh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function Ci(a, b) {
        var c = di();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Wh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function Di(a, b, c) {
        if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
        He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
        return b;
      }
      function Ei(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Qh.transition;
        Qh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Qh.transition = d;
        }
      }
      function Fi() {
        return di().memoizedState;
      }
      function Gi(a, b, c) {
        var d = lh(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a)) Ii(b, c);
        else if (c = Yg(a, b, c, d), null !== c) {
          var e = L();
          mh(c, a, d, e);
          Ji(c, b, d);
        }
      }
      function ri(a, b, c) {
        var d = lh(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a)) Ii(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = Yg(a, b, e, d);
          null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
        }
      }
      function Hi(a) {
        var b = a.alternate;
        return a === N || null !== b && b === N;
      }
      function Ii(a, b) {
        Th = Sh = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Ji(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
      var Yh = { readContext: Vg, useCallback: function(a, b) {
        ci().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: Vg, useEffect: vi2, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ti(
          4194308,
          4,
          yi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ti(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ti(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = ci();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = ci();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = Gi.bind(null, N, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = ci();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
        return ci().memoizedState = a;
      }, useTransition: function() {
        var a = qi(false), b = a[0];
        a = Ei.bind(null, a[1]);
        ci().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = N, e = ci();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === R) throw Error(p(349));
          0 !== (Rh & 30) || ni(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        vi2(ki.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        li(9, mi.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = ci(), b = R.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Uh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false };
      var Zh = {
        readContext: Vg,
        useCallback: Bi,
        useContext: Vg,
        useEffect: ji,
        useImperativeHandle: zi,
        useInsertionEffect: wi,
        useLayoutEffect: xi,
        useMemo: Ci,
        useReducer: fi,
        useRef: si,
        useState: function() {
          return fi(ei);
        },
        useDebugValue: Ai,
        useDeferredValue: function(a) {
          var b = di();
          return Di(b, O.memoizedState, a);
        },
        useTransition: function() {
          var a = fi(ei)[0], b = di().memoizedState;
          return [a, b];
        },
        useMutableSource: hi2,
        useSyncExternalStore: ii,
        useId: Fi,
        unstable_isNewReconciler: false
      };
      var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
        return gi(ei);
      }, useDebugValue: Ai, useDeferredValue: function(a) {
        var b = di();
        return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
      }, useTransition: function() {
        var a = gi(ei)[0], b = di().memoizedState;
        return [a, b];
      }, useMutableSource: hi2, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
      function Ki(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Li(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Mi(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Ni = "function" === typeof WeakMap ? WeakMap : Map;
      function Oi(a, b, c) {
        c = ch(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Pi || (Pi = true, Qi = d);
          Mi(a, b);
        };
        return c;
      }
      function Ri(a, b, c) {
        c = ch(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Mi(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Mi(a, b);
          "function" !== typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Ni();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
      }
      function Vi(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Wi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Xi = ua.ReactCurrentOwner;
      var Ug = false;
      function Yi(a, b, c, d) {
        b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
      }
      function Zi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        Tg(b, e);
        d = Xh(a, b, c, d, f, e);
        c = bi();
        if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Yi(a, b, d, e);
        return b.child;
      }
      function aj(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
          a = yh(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
        }
        b.flags |= 1;
        a = wh(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function cj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (Ug = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = true);
          else return b.lanes = a.lanes, $i(a, b, e);
        }
        return dj(a, b, c, d, e);
      }
      function ej(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(fj, gj);
          gj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
        Yi(a, b, e, c);
        return b.child;
      }
      function hj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function dj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        Tg(b, e);
        c = Xh(a, b, c, d, f, e);
        d = bi();
        if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Yi(a, b, c, e);
        return b.child;
      }
      function ij(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        Tg(b, e);
        if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
          $g = false;
          var r = b.memoizedState;
          g.state = r;
          gh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          bh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Lg(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
          $g = false;
          r = b.memoizedState;
          g.state = r;
          gh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return kj(a, b, c, d, f, e);
      }
      function kj(a, b, c, d, e, f) {
        hj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), $i(a, b, f);
        d = b.stateNode;
        Xi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function lj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        Ih(a, b.containerInfo);
      }
      function mj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Yi(a, b, c, d);
        return b.child;
      }
      var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function oj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function pj(a, b, c) {
        var d = b.pendingProps, e = M.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(M, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = nj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = wh(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function rj(a, b) {
        b = qj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function tj(a, b, c, d) {
        null !== d && Jg(d);
        Bh(b, a.child, null, c);
        a = rj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function sj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = qj({ mode: "visible", children: d.children }, e, 0, null);
          f = Ah(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Bh(b, a.child, null, g);
          b.child.memoizedState = oj(g);
          b.memoizedState = nj;
          return f;
        }
        if (0 === (b.mode & 1)) return tj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Li(f, d, void 0);
          return tj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (Ug || h) {
          d = R;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
          }
          uj();
          d = Li(Error(p(421)));
          return tj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = rj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function wj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        Sg(a.return, b, c);
      }
      function xj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function yj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Yi(a, b, d.children, c);
        d = M.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);
            else if (19 === a.tag) wj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(M, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            xj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Mh(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            xj(b, true, c, null, f);
            break;
          case "together":
            xj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function jj(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function $i(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        hh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = wh(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function zj(a, b, c) {
        switch (b.tag) {
          case 3:
            lj(b);
            Ig();
            break;
          case 5:
            Kh(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            Ih(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Mg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
              G(M, M.current & 1);
              a = $i(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(M, M.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return yj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(M, M.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, ej(a, b, c);
        }
        return $i(a, b, c);
      }
      var Aj;
      var Bj;
      var Cj;
      var Dj;
      Aj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Bj = function() {
      };
      Cj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          Hh(Eh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Dj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Ej(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Fj(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            Jh();
            E(Wf);
            E(H);
            Oh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
            Bj(a, b);
            S(b);
            return null;
          case 5:
            Lh(b);
            var e = Hh(Gh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = Hh(Eh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                Aj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = Hh(Gh.current);
              Hh(Eh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(M);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Gj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return Rg(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(M);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Ej(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Mh(a);
                if (null !== g) {
                  b.flags |= 128;
                  Ej(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(M, M.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Mh(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Jj(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Lh(b), null;
          case 13:
            E(M);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(M), null;
          case 4:
            return Jh(), null;
          case 10:
            return Rg(b.type._context), null;
          case 22:
          case 23:
            return Ij(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Kj = false;
      var U = false;
      var Lj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Mj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Nj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Oj = false;
      function Pj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Oj;
        Oj = false;
        return n;
      }
      function Qj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Nj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Rj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Sj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Tj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Tj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Uj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Vj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      function Xj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a; ) Xj(a, b, c), a = a.sibling;
      }
      var X = null;
      var Yj = false;
      function Zj(a, b, c) {
        for (c = c.child; null !== c; ) ak(a, b, c), c = c.sibling;
      }
      function ak(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Mj(c, b);
          case 6:
            var d = X, e = Yj;
            X = null;
            Zj(a, b, c);
            X = d;
            Yj = e;
            null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Yj;
            X = c.stateNode.containerInfo;
            Yj = true;
            Zj(a, b, c);
            X = d;
            Yj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Zj(a, b, c);
            break;
          case 1:
            if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Zj(a, b, c);
            break;
          case 21:
            Zj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
            break;
          default:
            Zj(a, b, c);
        }
      }
      function bk(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Lj());
          b.forEach(function(b2) {
            var d = ck.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function dk(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Yj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Yj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Yj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            ak(f, g, e);
            X = null;
            Yj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) ek(b, a), b = b.sibling;
      }
      function ek(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            dk(b, a);
            fk(a);
            if (d & 4) {
              try {
                Qj(3, a, a.return), Rj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Qj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            dk(b, a);
            fk(a);
            d & 512 && null !== c && Mj(c, c.return);
            break;
          case 5:
            dk(b, a);
            fk(a);
            d & 512 && null !== c && Mj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            dk(b, a);
            fk(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            dk(b, a);
            fk(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            dk(b, a);
            fk(a);
            break;
          case 13:
            dk(b, a);
            fk(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
            d & 4 && bk(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
            fk(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r, r.return);
                      break;
                    case 1:
                      Mj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Mj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        hk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : hk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            dk(b, a);
            fk(a);
            d & 4 && bk(a);
            break;
          case 21:
            break;
          default:
            dk(
              b,
              a
            ), fk(a);
        }
      }
      function fk(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Uj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Vj(a);
                Xj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Vj(a);
                Wj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function ik(a, b, c) {
        V = a;
        jk(a, b, c);
      }
      function jk(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Kj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Kj;
              var l = U;
              Kj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
              for (; null !== f; ) V = f, jk(f, b, c), f = f.sibling;
              V = e;
              Kj = h;
              U = l;
            }
            lk(a, b, c);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
        }
      }
      function lk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && ih(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    ih(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Sj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function hk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Rj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Sj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Sj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var mk2 = Math.ceil;
      var nk = ua.ReactCurrentDispatcher;
      var ok = ua.ReactCurrentOwner;
      var pk = ua.ReactCurrentBatchConfig;
      var K2 = 0;
      var R = null;
      var Y = null;
      var Z = 0;
      var gj = 0;
      var fj = Uf(0);
      var T = 0;
      var qk = null;
      var hh = 0;
      var rk = 0;
      var sk = 0;
      var tk = null;
      var uk = null;
      var gk = 0;
      var Hj = Infinity;
      var vk = null;
      var Pi = false;
      var Qi = null;
      var Si = null;
      var wk = false;
      var xk = null;
      var yk = 0;
      var zk = 0;
      var Ak = null;
      var Bk = -1;
      var Ck = 0;
      function L() {
        return 0 !== (K2 & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
      }
      function lh(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K2 & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function mh(a, b, c, d) {
        if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K2 & 2) || a !== R) a === R && (0 === (K2 & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K2 && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
      }
      function Ek(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === R ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K2 & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Gk(c, Hk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Hk(a, b) {
        Bk = -1;
        Ck = 0;
        if (0 !== (K2 & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Ik() && a.callbackNode !== c) return null;
        var d = uc(a, a === R ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);
        else {
          b = d;
          var e = K2;
          K2 |= 2;
          var f = Kk();
          if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
          do
            try {
              Mk();
              break;
            } catch (h) {
              Nk(a, h);
            }
          while (1);
          Qg();
          nk.current = f;
          K2 = e;
          null !== Y ? b = 0 : (R = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
          if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
          if (6 === b) Dk(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Qk(a, uk, vk);
                break;
              case 3:
                Dk(a, d);
                if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    L();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                  break;
                }
                Qk(a, uk, vk);
                break;
              case 4:
                Dk(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk2(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                  break;
                }
                Qk(a, uk, vk);
                break;
              case 5:
                Qk(a, uk, vk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Ek(a, B());
        return a.callbackNode === c ? Hk.bind(null, a) : null;
      }
      function Ok(a, b) {
        var c = tk;
        a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
        a = Jk(a, b);
        2 !== a && (b = uk, uk = c, null !== b && Gj(b));
        return a;
      }
      function Gj(a) {
        null === uk ? uk = a : uk.push.apply(uk, a);
      }
      function Pk(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Dk(a, b) {
        b &= ~sk;
        b &= ~rk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Fk(a) {
        if (0 !== (K2 & 6)) throw Error(p(327));
        Ik();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Ek(a, B()), null;
        var c = Jk(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Ok(a, d));
        }
        if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Qk(a, uk, vk);
        Ek(a, B());
        return null;
      }
      function Rk(a, b) {
        var c = K2;
        K2 |= 1;
        try {
          return a(b);
        } finally {
          K2 = c, 0 === K2 && (Hj = B() + 500, fg && jg());
        }
      }
      function Sk(a) {
        null !== xk && 0 === xk.tag && 0 === (K2 & 6) && Ik();
        var b = K2;
        K2 |= 1;
        var c = pk.transition, d = C;
        try {
          if (pk.transition = null, C = 1, a) return a();
        } finally {
          C = d, pk.transition = c, K2 = b, 0 === (K2 & 6) && jg();
        }
      }
      function Ij() {
        gj = fj.current;
        E(fj);
      }
      function Lk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c = c.return;
        }
        R = a;
        Y = a = wh(a.current, null);
        Z = gj = b;
        T = 0;
        qk = null;
        sk = rk = hh = 0;
        uk = tk = null;
        if (null !== Wg) {
          for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          Wg = null;
        }
        return a;
      }
      function Nk(a, b) {
        do {
          var c = Y;
          try {
            Qg();
            Ph.current = ai;
            if (Sh) {
              for (var d = N.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Sh = false;
            }
            Rh = 0;
            P = O = N = null;
            Th = false;
            Uh = 0;
            ok.current = null;
            if (null === c || null === c.return) {
              T = 1;
              qk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Vi(g);
                if (null !== y) {
                  y.flags &= -257;
                  Wi(y, g, h, f, b);
                  y.mode & 1 && Ti(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Ti(f, l, b);
                    uj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Vi(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Wi(J, g, h, f, b);
                  Jg(Ki(k, h));
                  break a;
                }
              }
              f = k = Ki(k, h);
              4 !== T && (T = 2);
              null === tk ? tk = [f] : tk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Oi(f, k, b);
                    fh(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Ri(f, h, b);
                      fh(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Tk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Kk() {
        var a = nk.current;
        nk.current = ai;
        return null === a ? ai : a;
      }
      function uj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
      }
      function Jk(a, b) {
        var c = K2;
        K2 |= 2;
        var d = Kk();
        if (R !== a || Z !== b) vk = null, Lk(a, b);
        do
          try {
            Uk();
            break;
          } catch (e) {
            Nk(a, e);
          }
        while (1);
        Qg();
        K2 = c;
        nk.current = d;
        if (null !== Y) throw Error(p(261));
        R = null;
        Z = 0;
        return T;
      }
      function Uk() {
        for (; null !== Y; ) Vk(Y);
      }
      function Mk() {
        for (; null !== Y && !cc(); ) Vk(Y);
      }
      function Vk(a) {
        var b = Wk(a.alternate, a, gj);
        a.memoizedProps = a.pendingProps;
        null === b ? Tk(a) : Y = b;
        ok.current = null;
      }
      function Tk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Fj(c, b, gj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Jj(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Qk(a, b, c) {
        var d = C, e = pk.transition;
        try {
          pk.transition = null, C = 1, Xk(a, b, c, d);
        } finally {
          pk.transition = e, C = d;
        }
        return null;
      }
      function Xk(a, b, c, d) {
        do
          Ik();
        while (null !== xk);
        if (0 !== (K2 & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === R && (Y = R = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
          Ik();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = pk.transition;
          pk.transition = null;
          var g = C;
          C = 1;
          var h = K2;
          K2 |= 4;
          ok.current = null;
          Pj(a, c);
          ek(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          ik(c, a, e);
          dc();
          K2 = h;
          C = g;
          pk.transition = f;
        } else a.current = c;
        wk && (wk = false, xk = a, yk = e);
        f = a.pendingLanes;
        0 === f && (Si = null);
        mc(c.stateNode, d);
        Ek(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Pi) throw Pi = false, a = Qi, Qi = null, a;
        0 !== (yk & 1) && 0 !== a.tag && Ik();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
        jg();
        return null;
      }
      function Ik() {
        if (null !== xk) {
          var a = Dc(yk), b = pk.transition, c = C;
          try {
            pk.transition = null;
            C = 16 > a ? 16 : a;
            if (null === xk) var d = false;
            else {
              a = xk;
              xk = null;
              yk = 0;
              if (0 !== (K2 & 6)) throw Error(p(331));
              var e = K2;
              K2 |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Tj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K2 = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, pk.transition = b;
          }
        }
        return false;
      }
      function Yk(a, b, c) {
        b = Ki(c, b);
        b = Oi(a, b, 1);
        a = dh(a, b, 1);
        b = L();
        null !== a && (Ac(a, 1, b), Ek(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Yk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Yk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
              a = Ki(c, a);
              a = Ri(b, a, 1);
              b = dh(b, a, 1);
              a = L();
              null !== b && (Ac(b, 1, a), Ek(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ui(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = L();
        a.pingedLanes |= a.suspendedLanes & c;
        R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
        Ek(a, b);
      }
      function Zk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = L();
        a = Zg(a, b);
        null !== a && (Ac(a, b, c), Ek(a, c));
      }
      function vj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Zk(a, c);
      }
      function ck(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Zk(a, c);
      }
      var Wk;
      Wk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = false, zj(a, b, c);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
        else Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            jj(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            Tg(b, c);
            e = Xh(null, b, d, a, e, c);
            var f = bi();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              jj(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = $k(d);
              a = Lg(d, a);
              switch (e) {
                case 0:
                  b = dj(null, b, d, a, c);
                  break a;
                case 1:
                  b = ij(null, b, d, a, c);
                  break a;
                case 11:
                  b = Zi(null, b, d, a, c);
                  break a;
                case 14:
                  b = aj(null, b, d, Lg(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
          case 3:
            a: {
              lj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              bh(a, b);
              gh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ki(Error(p(423)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ki(Error(p(424)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = $i(a, b, c);
                  break a;
                }
                Yi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return pj(a, b, c);
          case 4:
            return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
          case 7:
            return Yi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Yi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Yi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Mg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = $i(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = ch(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      Sg(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  Sg(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Yi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
          case 15:
            return cj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a, c);
          case 19:
            return yj(a, b, c);
          case 22:
            return ej(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Gk(a, b) {
        return ac(a, b);
      }
      function al(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new al(a, b, c, d);
      }
      function bj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function $k(a) {
        if ("function" === typeof a) return bj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function wh(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function yh(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) bj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Ah(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return qj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Ah(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function qj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function xh(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function zh2(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function bl(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function cl(a, b, c, d, e, f, g, h, k) {
        a = new bl(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        ah(f);
        return a;
      }
      function dl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function el(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg2(a, c, b);
        }
        return b;
      }
      function fl(a, b, c, d, e, f, g, h, k) {
        a = cl(c, d, true, a, e, f, g, h, k);
        a.context = el(null);
        c = a.current;
        d = L();
        e = lh(c);
        f = ch(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        dh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Ek(a, d);
        return a;
      }
      function gl(a, b, c, d) {
        var e = b.current, f = L(), g = lh(e);
        c = el(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = ch(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = dh(e, b, g);
        null !== a && (mh(a, e, g, f), eh(a, e, g));
        return g;
      }
      function hl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function il(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function jl(a, b) {
        il(a, b);
        (a = a.alternate) && il(a, b);
      }
      function kl() {
        return null;
      }
      var ll = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ml(a) {
        this._internalRoot = a;
      }
      nl.prototype.render = ml.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        gl(a, b, null, null);
      };
      nl.prototype.unmount = ml.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Sk(function() {
            gl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function nl(a) {
        this._internalRoot = a;
      }
      nl.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function pl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function ql() {
      }
      function rl(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = hl(g);
              f.call(a2);
            };
          }
          var g = fl(b, d, a, 0, null, false, false, "", ql);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Sk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = hl(k);
            h.call(a2);
          };
        }
        var k = cl(a, 0, false, null, null, false, false, "", ql);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk(function() {
          gl(b, k, c, d);
        });
        return k;
      }
      function sl2(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = hl(g);
              h.call(a2);
            };
          }
          gl(b, g, a, e);
        } else g = rl(c, b, a, e, d);
        return hl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K2 & 6) && (Hj = B() + 500, jg()));
            }
            break;
          case 13:
            Sk(function() {
              var b2 = Zg(a, 1);
              if (null !== b2) {
                var c2 = L();
                mh(b2, a, 1, c2);
              }
            }), jl(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = Zg(a, 134217728);
          if (null !== b) {
            var c = L();
            mh(b, a, 134217728, c);
          }
          jl(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = lh(a), c = Zg(a, b);
          if (null !== c) {
            var d = L();
            mh(c, a, b, d);
          }
          jl(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Rk;
      Hb = Sk;
      var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
      var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
      var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wl.isDisabled && wl.supportsFiber) try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
      }
      var wl;
      exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
      exports2.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!ol(b)) throw Error(p(200));
        return dl(a, b, null, c);
      };
      exports2.createRoot = function(a, b) {
        if (!ol(a)) throw Error(p(299));
        var c = false, d = "", e = ll;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = cl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ml(b);
      };
      exports2.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports2.flushSync = function(a) {
        return Sk(a);
      };
      exports2.hydrate = function(a, b, c) {
        if (!pl(b)) throw Error(p(200));
        return sl2(null, a, b, true, c);
      };
      exports2.hydrateRoot = function(a, b, c) {
        if (!ol(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = ll;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = fl(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new nl(b);
      };
      exports2.render = function(a, b, c) {
        if (!pl(b)) throw Error(p(200));
        return sl2(null, a, b, false, c);
      };
      exports2.unmountComponentAtNode = function(a) {
        if (!pl(a)) throw Error(p(40));
        return a._reactRootContainer ? (Sk(function() {
          sl2(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      exports2.unstable_batchedUpdates = Rk;
      exports2.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!pl(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return sl2(a, b, c, false, d);
      };
      exports2.version = "18.2.0-next-9e3b772b8-20220608";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module2.exports = require_react_dom_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var m = require_react_dom();
      if (true) {
        exports2.createRoot = m.createRoot;
        exports2.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports2.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports2.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // node_modules/qrcode/lib/can-promise.js
  var require_can_promise = __commonJS({
    "node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = function() {
        return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
      };
    }
  });

  // node_modules/qrcode/lib/core/utils.js
  var require_utils26 = __commonJS({
    "node_modules/qrcode/lib/core/utils.js"(exports2) {
      init_process();
      init_buffer();
      var toSJISFunction;
      var CODEWORDS_COUNT = [
        0,
        // Not used
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      exports2.getSymbolSize = function getSymbolSize(version7) {
        if (!version7) throw new Error('"version" cannot be null or undefined');
        if (version7 < 1 || version7 > 40) throw new Error('"version" should be in range from 1 to 40');
        return version7 * 4 + 17;
      };
      exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version7) {
        return CODEWORDS_COUNT[version7];
      };
      exports2.getBCHDigit = function(data7) {
        let digit = 0;
        while (data7 !== 0) {
          digit++;
          data7 >>>= 1;
        }
        return digit;
      };
      exports2.setToSJISFunction = function setToSJISFunction(f) {
        if (typeof f !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f;
      };
      exports2.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      exports2.toSJIS = function toSJIS(kanji) {
        return toSJISFunction(kanji);
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-level.js
  var require_error_correction_level = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
      init_process();
      init_buffer();
      exports2.L = { bit: 1 };
      exports2.M = { bit: 0 };
      exports2.Q = { bit: 3 };
      exports2.H = { bit: 2 };
      function fromString3(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string.toLowerCase();
        switch (lcStr) {
          case "l":
          case "low":
            return exports2.L;
          case "m":
          case "medium":
            return exports2.M;
          case "q":
          case "quartile":
            return exports2.Q;
          case "h":
          case "high":
            return exports2.H;
          default:
            throw new Error("Unknown EC Level: " + string);
        }
      }
      exports2.isValid = function isValid(level) {
        return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
      };
      exports2.from = function from5(value, defaultValue) {
        if (exports2.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/bit-buffer.js
  var require_bit_buffer = __commonJS({
    "node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
      init_process();
      init_buffer();
      function BitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer.prototype = {
        get: function(index) {
          const bufIndex = Math.floor(index / 8);
          return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
        },
        put: function(num, length) {
          for (let i = 0; i < length; i++) {
            this.putBit((num >>> length - i - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          const bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      module2.exports = BitBuffer;
    }
  });

  // node_modules/qrcode/lib/core/bit-matrix.js
  var require_bit_matrix = __commonJS({
    "node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
      init_process();
      init_buffer();
      function BitMatrix(size) {
        if (!size || size < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size;
        this.data = new Uint8Array(size * size);
        this.reservedBit = new Uint8Array(size * size);
      }
      BitMatrix.prototype.set = function(row, col, value, reserved) {
        const index = row * this.size + col;
        this.data[index] = value;
        if (reserved) this.reservedBit[index] = true;
      };
      BitMatrix.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix.prototype.xor = function(row, col, value) {
        this.data[row * this.size + col] ^= value;
      };
      BitMatrix.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      module2.exports = BitMatrix;
    }
  });

  // node_modules/qrcode/lib/core/alignment-pattern.js
  var require_alignment_pattern = __commonJS({
    "node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
      init_process();
      init_buffer();
      var getSymbolSize = require_utils26().getSymbolSize;
      exports2.getRowColCoords = function getRowColCoords(version7) {
        if (version7 === 1) return [];
        const posCount = Math.floor(version7 / 7) + 2;
        const size = getSymbolSize(version7);
        const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
        const positions = [size - 7];
        for (let i = 1; i < posCount - 1; i++) {
          positions[i] = positions[i - 1] - intervals;
        }
        positions.push(6);
        return positions.reverse();
      };
      exports2.getPositions = function getPositions(version7) {
        const coords = [];
        const pos = exports2.getRowColCoords(version7);
        const posLength = pos.length;
        for (let i = 0; i < posLength; i++) {
          for (let j = 0; j < posLength; j++) {
            if (i === 0 && j === 0 || // top-left
            i === 0 && j === posLength - 1 || // bottom-left
            i === posLength - 1 && j === 0) {
              continue;
            }
            coords.push([pos[i], pos[j]]);
          }
        }
        return coords;
      };
    }
  });

  // node_modules/qrcode/lib/core/finder-pattern.js
  var require_finder_pattern = __commonJS({
    "node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
      init_process();
      init_buffer();
      var getSymbolSize = require_utils26().getSymbolSize;
      var FINDER_PATTERN_SIZE = 7;
      exports2.getPositions = function getPositions(version7) {
        const size = getSymbolSize(version7);
        return [
          // top-left
          [0, 0],
          // top-right
          [size - FINDER_PATTERN_SIZE, 0],
          // bottom-left
          [0, size - FINDER_PATTERN_SIZE]
        ];
      };
    }
  });

  // node_modules/qrcode/lib/core/mask-pattern.js
  var require_mask_pattern = __commonJS({
    "node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
      init_process();
      init_buffer();
      exports2.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var PenaltyScores = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
      };
      exports2.isValid = function isValid(mask) {
        return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
      };
      exports2.from = function from5(value) {
        return exports2.isValid(value) ? parseInt(value, 10) : void 0;
      };
      exports2.getPenaltyN1 = function getPenaltyN1(data7) {
        const size = data7.size;
        let points = 0;
        let sameCountCol = 0;
        let sameCountRow = 0;
        let lastCol = null;
        let lastRow = null;
        for (let row = 0; row < size; row++) {
          sameCountCol = sameCountRow = 0;
          lastCol = lastRow = null;
          for (let col = 0; col < size; col++) {
            let module3 = data7.get(row, col);
            if (module3 === lastCol) {
              sameCountCol++;
            } else {
              if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
              lastCol = module3;
              sameCountCol = 1;
            }
            module3 = data7.get(col, row);
            if (module3 === lastRow) {
              sameCountRow++;
            } else {
              if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
              lastRow = module3;
              sameCountRow = 1;
            }
          }
          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
        }
        return points;
      };
      exports2.getPenaltyN2 = function getPenaltyN2(data7) {
        const size = data7.size;
        let points = 0;
        for (let row = 0; row < size - 1; row++) {
          for (let col = 0; col < size - 1; col++) {
            const last5 = data7.get(row, col) + data7.get(row, col + 1) + data7.get(row + 1, col) + data7.get(row + 1, col + 1);
            if (last5 === 4 || last5 === 0) points++;
          }
        }
        return points * PenaltyScores.N2;
      };
      exports2.getPenaltyN3 = function getPenaltyN3(data7) {
        const size = data7.size;
        let points = 0;
        let bitsCol = 0;
        let bitsRow = 0;
        for (let row = 0; row < size; row++) {
          bitsCol = bitsRow = 0;
          for (let col = 0; col < size; col++) {
            bitsCol = bitsCol << 1 & 2047 | data7.get(row, col);
            if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
            bitsRow = bitsRow << 1 & 2047 | data7.get(col, row);
            if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
          }
        }
        return points * PenaltyScores.N3;
      };
      exports2.getPenaltyN4 = function getPenaltyN4(data7) {
        let darkCount = 0;
        const modulesCount = data7.data.length;
        for (let i = 0; i < modulesCount; i++) darkCount += data7.data[i];
        const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
        return k * PenaltyScores.N4;
      };
      function getMaskAt(maskPattern, i, j) {
        switch (maskPattern) {
          case exports2.Patterns.PATTERN000:
            return (i + j) % 2 === 0;
          case exports2.Patterns.PATTERN001:
            return i % 2 === 0;
          case exports2.Patterns.PATTERN010:
            return j % 3 === 0;
          case exports2.Patterns.PATTERN011:
            return (i + j) % 3 === 0;
          case exports2.Patterns.PATTERN100:
            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
          case exports2.Patterns.PATTERN101:
            return i * j % 2 + i * j % 3 === 0;
          case exports2.Patterns.PATTERN110:
            return (i * j % 2 + i * j % 3) % 2 === 0;
          case exports2.Patterns.PATTERN111:
            return (i * j % 3 + (i + j) % 2) % 2 === 0;
          default:
            throw new Error("bad maskPattern:" + maskPattern);
        }
      }
      exports2.applyMask = function applyMask(pattern, data7) {
        const size = data7.size;
        for (let col = 0; col < size; col++) {
          for (let row = 0; row < size; row++) {
            if (data7.isReserved(row, col)) continue;
            data7.xor(row, col, getMaskAt(pattern, row, col));
          }
        }
      };
      exports2.getBestMask = function getBestMask(data7, setupFormatFunc) {
        const numPatterns = Object.keys(exports2.Patterns).length;
        let bestPattern = 0;
        let lowerPenalty = Infinity;
        for (let p = 0; p < numPatterns; p++) {
          setupFormatFunc(p);
          exports2.applyMask(p, data7);
          const penalty = exports2.getPenaltyN1(data7) + exports2.getPenaltyN2(data7) + exports2.getPenaltyN3(data7) + exports2.getPenaltyN4(data7);
          exports2.applyMask(p, data7);
          if (penalty < lowerPenalty) {
            lowerPenalty = penalty;
            bestPattern = p;
          }
        }
        return bestPattern;
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-code.js
  var require_error_correction_code = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
      init_process();
      init_buffer();
      var ECLevel = require_error_correction_level();
      var EC_BLOCKS_TABLE = [
        // L  M  Q  H
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      var EC_CODEWORDS_TABLE = [
        // L  M  Q  H
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      exports2.getBlocksCount = function getBlocksCount(version7, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version7, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/galois-field.js
  var require_galois_field = __commonJS({
    "node_modules/qrcode/lib/core/galois-field.js"(exports2) {
      init_process();
      init_buffer();
      var EXP_TABLE = new Uint8Array(512);
      var LOG_TABLE = new Uint8Array(256);
      (function initTables() {
        let x = 1;
        for (let i = 0; i < 255; i++) {
          EXP_TABLE[i] = x;
          LOG_TABLE[x] = i;
          x <<= 1;
          if (x & 256) {
            x ^= 285;
          }
        }
        for (let i = 255; i < 512; i++) {
          EXP_TABLE[i] = EXP_TABLE[i - 255];
        }
      })();
      exports2.log = function log3(n) {
        if (n < 1) throw new Error("log(" + n + ")");
        return LOG_TABLE[n];
      };
      exports2.exp = function exp(n) {
        return EXP_TABLE[n];
      };
      exports2.mul = function mul(x, y) {
        if (x === 0 || y === 0) return 0;
        return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
      };
    }
  });

  // node_modules/qrcode/lib/core/polynomial.js
  var require_polynomial = __commonJS({
    "node_modules/qrcode/lib/core/polynomial.js"(exports2) {
      init_process();
      init_buffer();
      var GF = require_galois_field();
      exports2.mul = function mul(p1, p2) {
        const coeff = new Uint8Array(p1.length + p2.length - 1);
        for (let i = 0; i < p1.length; i++) {
          for (let j = 0; j < p2.length; j++) {
            coeff[i + j] ^= GF.mul(p1[i], p2[j]);
          }
        }
        return coeff;
      };
      exports2.mod = function mod(divident, divisor) {
        let result = new Uint8Array(divident);
        while (result.length - divisor.length >= 0) {
          const coeff = result[0];
          for (let i = 0; i < divisor.length; i++) {
            result[i] ^= GF.mul(divisor[i], coeff);
          }
          let offset = 0;
          while (offset < result.length && result[offset] === 0) offset++;
          result = result.slice(offset);
        }
        return result;
      };
      exports2.generateECPolynomial = function generateECPolynomial(degree) {
        let poly = new Uint8Array([1]);
        for (let i = 0; i < degree; i++) {
          poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
        }
        return poly;
      };
    }
  });

  // node_modules/qrcode/lib/core/reed-solomon-encoder.js
  var require_reed_solomon_encoder = __commonJS({
    "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Polynomial = require_polynomial();
      function ReedSolomonEncoder(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree) this.initialize(this.degree);
      }
      ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder.prototype.encode = function encode3(data7) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        const paddedData = new Uint8Array(data7.length + this.degree);
        paddedData.set(data7);
        const remainder = Polynomial.mod(paddedData, this.genPoly);
        const start = this.degree - remainder.length;
        if (start > 0) {
          const buff = new Uint8Array(this.degree);
          buff.set(remainder, start);
          return buff;
        }
        return remainder;
      };
      module2.exports = ReedSolomonEncoder;
    }
  });

  // node_modules/qrcode/lib/core/version-check.js
  var require_version_check = __commonJS({
    "node_modules/qrcode/lib/core/version-check.js"(exports2) {
      init_process();
      init_buffer();
      exports2.isValid = function isValid(version7) {
        return !isNaN(version7) && version7 >= 1 && version7 <= 40;
      };
    }
  });

  // node_modules/qrcode/lib/core/regex.js
  var require_regex = __commonJS({
    "node_modules/qrcode/lib/core/regex.js"(exports2) {
      init_process();
      init_buffer();
      var numeric = "[0-9]+";
      var alphanumeric = "[A-Z $%*+\\-./:]+";
      var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      exports2.KANJI = new RegExp(kanji, "g");
      exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      exports2.BYTE = new RegExp(byte, "g");
      exports2.NUMERIC = new RegExp(numeric, "g");
      exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      var TEST_KANJI = new RegExp("^" + kanji + "$");
      var TEST_NUMERIC = new RegExp("^" + numeric + "$");
      var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      exports2.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      exports2.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      exports2.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
    }
  });

  // node_modules/qrcode/lib/core/mode.js
  var require_mode = __commonJS({
    "node_modules/qrcode/lib/core/mode.js"(exports2) {
      init_process();
      init_buffer();
      var VersionCheck = require_version_check();
      var Regex = require_regex();
      exports2.NUMERIC = {
        id: "Numeric",
        bit: 1 << 0,
        ccBits: [10, 12, 14]
      };
      exports2.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 1 << 1,
        ccBits: [9, 11, 13]
      };
      exports2.BYTE = {
        id: "Byte",
        bit: 1 << 2,
        ccBits: [8, 16, 16]
      };
      exports2.KANJI = {
        id: "Kanji",
        bit: 1 << 3,
        ccBits: [8, 10, 12]
      };
      exports2.MIXED = {
        bit: -1
      };
      exports2.getCharCountIndicator = function getCharCountIndicator(mode, version7) {
        if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
        if (!VersionCheck.isValid(version7)) {
          throw new Error("Invalid version: " + version7);
        }
        if (version7 >= 1 && version7 < 10) return mode.ccBits[0];
        else if (version7 < 27) return mode.ccBits[1];
        return mode.ccBits[2];
      };
      exports2.getBestModeForData = function getBestModeForData(dataStr) {
        if (Regex.testNumeric(dataStr)) return exports2.NUMERIC;
        else if (Regex.testAlphanumeric(dataStr)) return exports2.ALPHANUMERIC;
        else if (Regex.testKanji(dataStr)) return exports2.KANJI;
        else return exports2.BYTE;
      };
      exports2.toString = function toString18(mode) {
        if (mode && mode.id) return mode.id;
        throw new Error("Invalid mode");
      };
      exports2.isValid = function isValid(mode) {
        return mode && mode.bit && mode.ccBits;
      };
      function fromString3(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string.toLowerCase();
        switch (lcStr) {
          case "numeric":
            return exports2.NUMERIC;
          case "alphanumeric":
            return exports2.ALPHANUMERIC;
          case "kanji":
            return exports2.KANJI;
          case "byte":
            return exports2.BYTE;
          default:
            throw new Error("Unknown mode: " + string);
        }
      }
      exports2.from = function from5(value, defaultValue) {
        if (exports2.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/version.js
  var require_version = __commonJS({
    "node_modules/qrcode/lib/core/version.js"(exports2) {
      init_process();
      init_buffer();
      var Utils = require_utils26();
      var ECCode = require_error_correction_code();
      var ECLevel = require_error_correction_level();
      var Mode = require_mode();
      var VersionCheck = require_version_check();
      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
      var G18_BCH = Utils.getBCHDigit(G18);
      function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      function getReservedBitsCount(mode, version7) {
        return Mode.getCharCountIndicator(mode, version7) + 4;
      }
      function getTotalBitsFromDataArray(segments, version7) {
        let totalBits = 0;
        segments.forEach(function(data7) {
          const reservedBits = getReservedBitsCount(data7.mode, version7);
          totalBits += reservedBits + data7.getBitsLength();
        });
        return totalBits;
      }
      function getBestVersionForMixedData(segments, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          const length = getTotalBitsFromDataArray(segments, currentVersion);
          if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      exports2.from = function from5(value, defaultValue) {
        if (VersionCheck.isValid(value)) {
          return parseInt(value, 10);
        }
        return defaultValue;
      };
      exports2.getCapacity = function getCapacity(version7, errorCorrectionLevel, mode) {
        if (!VersionCheck.isValid(version7)) {
          throw new Error("Invalid QR Code version");
        }
        if (typeof mode === "undefined") mode = Mode.BYTE;
        const totalCodewords = Utils.getSymbolTotalCodewords(version7);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (mode === Mode.MIXED) return dataTotalCodewordsBits;
        const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version7);
        switch (mode) {
          case Mode.NUMERIC:
            return Math.floor(usableBits / 10 * 3);
          case Mode.ALPHANUMERIC:
            return Math.floor(usableBits / 11 * 2);
          case Mode.KANJI:
            return Math.floor(usableBits / 13);
          case Mode.BYTE:
          default:
            return Math.floor(usableBits / 8);
        }
      };
      exports2.getBestVersionForData = function getBestVersionForData(data7, errorCorrectionLevel) {
        let seg;
        const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
        if (Array.isArray(data7)) {
          if (data7.length > 1) {
            return getBestVersionForMixedData(data7, ecl);
          }
          if (data7.length === 0) {
            return 1;
          }
          seg = data7[0];
        } else {
          seg = data7;
        }
        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
      };
      exports2.getEncodedBits = function getEncodedBits(version7) {
        if (!VersionCheck.isValid(version7) || version7 < 7) {
          throw new Error("Invalid QR Code version");
        }
        let d = version7 << 12;
        while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
          d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
        }
        return version7 << 12 | d;
      };
    }
  });

  // node_modules/qrcode/lib/core/format-info.js
  var require_format_info = __commonJS({
    "node_modules/qrcode/lib/core/format-info.js"(exports2) {
      init_process();
      init_buffer();
      var Utils = require_utils26();
      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      var G15_BCH = Utils.getBCHDigit(G15);
      exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
        const data7 = errorCorrectionLevel.bit << 3 | mask;
        let d = data7 << 10;
        while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
          d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
        }
        return (data7 << 10 | d) ^ G15_MASK;
      };
    }
  });

  // node_modules/qrcode/lib/core/numeric-data.js
  var require_numeric_data = __commonJS({
    "node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Mode = require_mode();
      function NumericData(data7) {
        this.mode = Mode.NUMERIC;
        this.data = data7.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length) {
        return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write4(bitBuffer) {
        let i, group, value;
        for (i = 0; i + 3 <= this.data.length; i += 3) {
          group = this.data.substr(i, 3);
          value = parseInt(group, 10);
          bitBuffer.put(value, 10);
        }
        const remainingNum = this.data.length - i;
        if (remainingNum > 0) {
          group = this.data.substr(i);
          value = parseInt(group, 10);
          bitBuffer.put(value, remainingNum * 3 + 1);
        }
      };
      module2.exports = NumericData;
    }
  });

  // node_modules/qrcode/lib/core/alphanumeric-data.js
  var require_alphanumeric_data = __commonJS({
    "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Mode = require_mode();
      var ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data7) {
        this.mode = Mode.ALPHANUMERIC;
        this.data = data7;
      }
      AlphanumericData.getBitsLength = function getBitsLength(length) {
        return 11 * Math.floor(length / 2) + 6 * (length % 2);
      };
      AlphanumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write4(bitBuffer) {
        let i;
        for (i = 0; i + 2 <= this.data.length; i += 2) {
          let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
          value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
          bitBuffer.put(value, 11);
        }
        if (this.data.length % 2) {
          bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
        }
      };
      module2.exports = AlphanumericData;
    }
  });

  // node_modules/qrcode/lib/core/byte-data.js
  var require_byte_data = __commonJS({
    "node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Mode = require_mode();
      function ByteData(data7) {
        this.mode = Mode.BYTE;
        if (typeof data7 === "string") {
          this.data = new TextEncoder().encode(data7);
        } else {
          this.data = new Uint8Array(data7);
        }
      }
      ByteData.getBitsLength = function getBitsLength(length) {
        return length * 8;
      };
      ByteData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer) {
        for (let i = 0, l = this.data.length; i < l; i++) {
          bitBuffer.put(this.data[i], 8);
        }
      };
      module2.exports = ByteData;
    }
  });

  // node_modules/qrcode/lib/core/kanji-data.js
  var require_kanji_data = __commonJS({
    "node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Mode = require_mode();
      var Utils = require_utils26();
      function KanjiData(data7) {
        this.mode = Mode.KANJI;
        this.data = data7;
      }
      KanjiData.getBitsLength = function getBitsLength(length) {
        return length * 13;
      };
      KanjiData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer) {
        let i;
        for (i = 0; i < this.data.length; i++) {
          let value = Utils.toSJIS(this.data[i]);
          if (value >= 33088 && value <= 40956) {
            value -= 33088;
          } else if (value >= 57408 && value <= 60351) {
            value -= 49472;
          } else {
            throw new Error(
              "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
            );
          }
          value = (value >>> 8 & 255) * 192 + (value & 255);
          bitBuffer.put(value, 13);
        }
      };
      module2.exports = KanjiData;
    }
  });

  // node_modules/dijkstrajs/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var dijkstra = {
        single_source_shortest_paths: function(graph, s, d) {
          var predecessors = {};
          var costs = {};
          costs[s] = 0;
          var open = dijkstra.PriorityQueue.make();
          open.push(s, 0);
          var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
          while (!open.empty()) {
            closest = open.pop();
            u = closest.value;
            cost_of_s_to_u = closest.cost;
            adjacent_nodes = graph[u] || {};
            for (v in adjacent_nodes) {
              if (adjacent_nodes.hasOwnProperty(v)) {
                cost_of_e = adjacent_nodes[v];
                cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                cost_of_s_to_v = costs[v];
                first_visit = typeof costs[v] === "undefined";
                if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                  costs[v] = cost_of_s_to_u_plus_cost_of_e;
                  open.push(v, cost_of_s_to_u_plus_cost_of_e);
                  predecessors[v] = u;
                }
              }
            }
          }
          if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
            var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
            throw new Error(msg);
          }
          return predecessors;
        },
        extract_shortest_path_from_predecessor_list: function(predecessors, d) {
          var nodes = [];
          var u = d;
          var predecessor;
          while (u) {
            nodes.push(u);
            predecessor = predecessors[u];
            u = predecessors[u];
          }
          nodes.reverse();
          return nodes;
        },
        find_path: function(graph, s, d) {
          var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
          return dijkstra.extract_shortest_path_from_predecessor_list(
            predecessors,
            d
          );
        },
        /**
         * A very naive priority queue implementation.
         */
        PriorityQueue: {
          make: function(opts) {
            var T = dijkstra.PriorityQueue, t = {}, key;
            opts = opts || {};
            for (key in T) {
              if (T.hasOwnProperty(key)) {
                t[key] = T[key];
              }
            }
            t.queue = [];
            t.sorter = opts.sorter || T.default_sorter;
            return t;
          },
          default_sorter: function(a, b) {
            return a.cost - b.cost;
          },
          /**
           * Add a new item to the queue and ensure the highest priority element
           * is at the front of the queue.
           */
          push: function(value, cost) {
            var item = { value, cost };
            this.queue.push(item);
            this.queue.sort(this.sorter);
          },
          /**
           * Return the highest priority element in the queue.
           */
          pop: function() {
            return this.queue.shift();
          },
          empty: function() {
            return this.queue.length === 0;
          }
        }
      };
      if (typeof module2 !== "undefined") {
        module2.exports = dijkstra;
      }
    }
  });

  // node_modules/qrcode/lib/core/segments.js
  var require_segments = __commonJS({
    "node_modules/qrcode/lib/core/segments.js"(exports2) {
      init_process();
      init_buffer();
      var Mode = require_mode();
      var NumericData = require_numeric_data();
      var AlphanumericData = require_alphanumeric_data();
      var ByteData = require_byte_data();
      var KanjiData = require_kanji_data();
      var Regex = require_regex();
      var Utils = require_utils26();
      var dijkstra = require_dijkstra();
      function getStringByteLength(str) {
        return unescape(encodeURIComponent(str)).length;
      }
      function getSegments(regex, mode, str) {
        const segments = [];
        let result;
        while ((result = regex.exec(str)) !== null) {
          segments.push({
            data: result[0],
            index: result.index,
            mode,
            length: result[0].length
          });
        }
        return segments;
      }
      function getSegmentsFromString(dataStr) {
        const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
        const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
        let byteSegs;
        let kanjiSegs;
        if (Utils.isKanjiModeEnabled()) {
          byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
          kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
        } else {
          byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
          kanjiSegs = [];
        }
        const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
        return segs.sort(function(s1, s2) {
          return s1.index - s2.index;
        }).map(function(obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
          };
        });
      }
      function getSegmentBitsLength(length, mode) {
        switch (mode) {
          case Mode.NUMERIC:
            return NumericData.getBitsLength(length);
          case Mode.ALPHANUMERIC:
            return AlphanumericData.getBitsLength(length);
          case Mode.KANJI:
            return KanjiData.getBitsLength(length);
          case Mode.BYTE:
            return ByteData.getBitsLength(length);
        }
      }
      function mergeSegments(segs) {
        return segs.reduce(function(acc, curr) {
          const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
          if (prevSeg && prevSeg.mode === curr.mode) {
            acc[acc.length - 1].data += curr.data;
            return acc;
          }
          acc.push(curr);
          return acc;
        }, []);
      }
      function buildNodes(segs) {
        const nodes = [];
        for (let i = 0; i < segs.length; i++) {
          const seg = segs[i];
          switch (seg.mode) {
            case Mode.NUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.ALPHANUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.KANJI:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
              break;
            case Mode.BYTE:
              nodes.push([
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
          }
        }
        return nodes;
      }
      function buildGraph(nodes, version7) {
        const table = {};
        const graph = { start: {} };
        let prevNodeIds = ["start"];
        for (let i = 0; i < nodes.length; i++) {
          const nodeGroup = nodes[i];
          const currentNodeIds = [];
          for (let j = 0; j < nodeGroup.length; j++) {
            const node5 = nodeGroup[j];
            const key = "" + i + j;
            currentNodeIds.push(key);
            table[key] = { node: node5, lastCount: 0 };
            graph[key] = {};
            for (let n = 0; n < prevNodeIds.length; n++) {
              const prevNodeId = prevNodeIds[n];
              if (table[prevNodeId] && table[prevNodeId].node.mode === node5.mode) {
                graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node5.length, node5.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node5.mode);
                table[prevNodeId].lastCount += node5.length;
              } else {
                if (table[prevNodeId]) table[prevNodeId].lastCount = node5.length;
                graph[prevNodeId][key] = getSegmentBitsLength(node5.length, node5.mode) + 4 + Mode.getCharCountIndicator(node5.mode, version7);
              }
            }
          }
          prevNodeIds = currentNodeIds;
        }
        for (let n = 0; n < prevNodeIds.length; n++) {
          graph[prevNodeIds[n]].end = 0;
        }
        return { map: graph, table };
      }
      function buildSingleSegment(data7, modesHint) {
        let mode;
        const bestMode = Mode.getBestModeForData(data7);
        mode = Mode.from(modesHint, bestMode);
        if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
          throw new Error('"' + data7 + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
        }
        if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
          mode = Mode.BYTE;
        }
        switch (mode) {
          case Mode.NUMERIC:
            return new NumericData(data7);
          case Mode.ALPHANUMERIC:
            return new AlphanumericData(data7);
          case Mode.KANJI:
            return new KanjiData(data7);
          case Mode.BYTE:
            return new ByteData(data7);
        }
      }
      exports2.fromArray = function fromArray(array) {
        return array.reduce(function(acc, seg) {
          if (typeof seg === "string") {
            acc.push(buildSingleSegment(seg, null));
          } else if (seg.data) {
            acc.push(buildSingleSegment(seg.data, seg.mode));
          }
          return acc;
        }, []);
      };
      exports2.fromString = function fromString3(data7, version7) {
        const segs = getSegmentsFromString(data7, Utils.isKanjiModeEnabled());
        const nodes = buildNodes(segs);
        const graph = buildGraph(nodes, version7);
        const path7 = dijkstra.find_path(graph.map, "start", "end");
        const optimizedSegs = [];
        for (let i = 1; i < path7.length - 1; i++) {
          optimizedSegs.push(graph.table[path7[i]].node);
        }
        return exports2.fromArray(mergeSegments(optimizedSegs));
      };
      exports2.rawSplit = function rawSplit(data7) {
        return exports2.fromArray(
          getSegmentsFromString(data7, Utils.isKanjiModeEnabled())
        );
      };
    }
  });

  // node_modules/qrcode/lib/core/qrcode.js
  var require_qrcode = __commonJS({
    "node_modules/qrcode/lib/core/qrcode.js"(exports2) {
      init_process();
      init_buffer();
      var Utils = require_utils26();
      var ECLevel = require_error_correction_level();
      var BitBuffer = require_bit_buffer();
      var BitMatrix = require_bit_matrix();
      var AlignmentPattern = require_alignment_pattern();
      var FinderPattern = require_finder_pattern();
      var MaskPattern = require_mask_pattern();
      var ECCode = require_error_correction_code();
      var ReedSolomonEncoder = require_reed_solomon_encoder();
      var Version = require_version();
      var FormatInfo = require_format_info();
      var Mode = require_mode();
      var Segments = require_segments();
      function setupFinderPattern(matrix, version7) {
        const size = matrix.size;
        const pos = FinderPattern.getPositions(version7);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r = -1; r <= 7; r++) {
            if (row + r <= -1 || size <= row + r) continue;
            for (let c = -1; c <= 7; c++) {
              if (col + c <= -1 || size <= col + c) continue;
              if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
                matrix.set(row + r, col + c, true, true);
              } else {
                matrix.set(row + r, col + c, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        const size = matrix.size;
        for (let r = 8; r < size - 8; r++) {
          const value = r % 2 === 0;
          matrix.set(r, 6, value, true);
          matrix.set(6, r, value, true);
        }
      }
      function setupAlignmentPattern(matrix, version7) {
        const pos = AlignmentPattern.getPositions(version7);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
                matrix.set(row + r, col + c, true, true);
              } else {
                matrix.set(row + r, col + c, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version7) {
        const size = matrix.size;
        const bits = Version.getEncodedBits(version7);
        let row, col, mod;
        for (let i = 0; i < 18; i++) {
          row = Math.floor(i / 3);
          col = i % 3 + size - 8 - 3;
          mod = (bits >> i & 1) === 1;
          matrix.set(row, col, mod, true);
          matrix.set(col, row, mod, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
        const size = matrix.size;
        const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
        let i, mod;
        for (i = 0; i < 15; i++) {
          mod = (bits >> i & 1) === 1;
          if (i < 6) {
            matrix.set(i, 8, mod, true);
          } else if (i < 8) {
            matrix.set(i + 1, 8, mod, true);
          } else {
            matrix.set(size - 15 + i, 8, mod, true);
          }
          if (i < 8) {
            matrix.set(8, size - i - 1, mod, true);
          } else if (i < 9) {
            matrix.set(8, 15 - i - 1 + 1, mod, true);
          } else {
            matrix.set(8, 15 - i - 1, mod, true);
          }
        }
        matrix.set(size - 8, 8, 1, true);
      }
      function setupData(matrix, data7) {
        const size = matrix.size;
        let inc = -1;
        let row = size - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = size - 1; col > 0; col -= 2) {
          if (col === 6) col--;
          while (true) {
            for (let c = 0; c < 2; c++) {
              if (!matrix.isReserved(row, col - c)) {
                let dark = false;
                if (byteIndex < data7.length) {
                  dark = (data7[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version7, errorCorrectionLevel, segments) {
        const buffer = new BitBuffer();
        segments.forEach(function(data7) {
          buffer.put(data7.mode.bit, 4);
          buffer.put(data7.getLength(), Mode.getCharCountIndicator(data7.mode, version7));
          data7.write(buffer);
        });
        const totalCodewords = Utils.getSymbolTotalCodewords(version7);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 !== 0) {
          buffer.putBit(0);
        }
        const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
        for (let i = 0; i < remainingByte; i++) {
          buffer.put(i % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer, version7, errorCorrectionLevel);
      }
      function createCodewords(bitBuffer, version7, errorCorrectionLevel) {
        const totalCodewords = Utils.getSymbolTotalCodewords(version7);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
        const dataTotalCodewords = totalCodewords - ecTotalCodewords;
        const ecTotalBlocks = ECCode.getBlocksCount(version7, errorCorrectionLevel);
        const blocksInGroup2 = totalCodewords % ecTotalBlocks;
        const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        const rs = new ReedSolomonEncoder(ecCount);
        let offset = 0;
        const dcData = new Array(ecTotalBlocks);
        const ecData = new Array(ecTotalBlocks);
        let maxDataSize = 0;
        const buffer = new Uint8Array(bitBuffer.buffer);
        for (let b = 0; b < ecTotalBlocks; b++) {
          const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b] = buffer.slice(offset, offset + dataSize);
          ecData[b] = rs.encode(dcData[b]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        const data7 = new Uint8Array(totalCodewords);
        let index = 0;
        let i, r;
        for (i = 0; i < maxDataSize; i++) {
          for (r = 0; r < ecTotalBlocks; r++) {
            if (i < dcData[r].length) {
              data7[index++] = dcData[r][i];
            }
          }
        }
        for (i = 0; i < ecCount; i++) {
          for (r = 0; r < ecTotalBlocks; r++) {
            data7[index++] = ecData[r][i];
          }
        }
        return data7;
      }
      function createSymbol(data7, version7, errorCorrectionLevel, maskPattern) {
        let segments;
        if (Array.isArray(data7)) {
          segments = Segments.fromArray(data7);
        } else if (typeof data7 === "string") {
          let estimatedVersion = version7;
          if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data7);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
          }
          segments = Segments.fromString(data7, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version7) {
          version7 = bestVersion;
        } else if (version7 < bestVersion) {
          throw new Error(
            "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
          );
        }
        const dataBits = createData(version7, errorCorrectionLevel, segments);
        const moduleCount = Utils.getSymbolSize(version7);
        const modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version7);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version7);
        setupFormatInfo(modules, errorCorrectionLevel, 0);
        if (version7 >= 7) {
          setupVersionInfo(modules, version7);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern)) {
          maskPattern = MaskPattern.getBestMask(
            modules,
            setupFormatInfo.bind(null, modules, errorCorrectionLevel)
          );
        }
        MaskPattern.applyMask(maskPattern, modules);
        setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
        return {
          modules,
          version: version7,
          errorCorrectionLevel,
          maskPattern,
          segments
        };
      }
      exports2.create = function create9(data7, options) {
        if (typeof data7 === "undefined" || data7 === "") {
          throw new Error("No input text");
        }
        let errorCorrectionLevel = ECLevel.M;
        let version7;
        let mask;
        if (typeof options !== "undefined") {
          errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
          version7 = Version.from(options.version);
          mask = MaskPattern.from(options.maskPattern);
          if (options.toSJISFunc) {
            Utils.setToSJISFunction(options.toSJISFunc);
          }
        }
        return createSymbol(data7, version7, errorCorrectionLevel, mask);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/utils.js
  var require_utils27 = __commonJS({
    "node_modules/qrcode/lib/renderer/utils.js"(exports2) {
      init_process();
      init_buffer();
      function hex2rgba(hex) {
        if (typeof hex === "number") {
          hex = hex.toString();
        }
        if (typeof hex !== "string") {
          throw new Error("Color should be defined as hex string");
        }
        let hexCode = hex.slice().replace("#", "").split("");
        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
          throw new Error("Invalid hex color: " + hex);
        }
        if (hexCode.length === 3 || hexCode.length === 4) {
          hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
            return [c, c];
          }));
        }
        if (hexCode.length === 6) hexCode.push("F", "F");
        const hexValue = parseInt(hexCode.join(""), 16);
        return {
          r: hexValue >> 24 & 255,
          g: hexValue >> 16 & 255,
          b: hexValue >> 8 & 255,
          a: hexValue & 255,
          hex: "#" + hexCode.slice(0, 6).join("")
        };
      }
      exports2.getOptions = function getOptions(options) {
        if (!options) options = {};
        if (!options.color) options.color = {};
        const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
        const width = options.width && options.width >= 21 ? options.width : void 0;
        const scale = options.scale || 4;
        return {
          width,
          scale: width ? 4 : scale,
          margin,
          color: {
            dark: hex2rgba(options.color.dark || "#000000ff"),
            light: hex2rgba(options.color.light || "#ffffffff")
          },
          type: options.type,
          rendererOpts: options.rendererOpts || {}
        };
      };
      exports2.getScale = function getScale(qrSize, opts) {
        return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
      };
      exports2.getImageWidth = function getImageWidth(qrSize, opts) {
        const scale = exports2.getScale(qrSize, opts);
        return Math.floor((qrSize + opts.margin * 2) * scale);
      };
      exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
        const size = qr.modules.size;
        const data7 = qr.modules.data;
        const scale = exports2.getScale(size, opts);
        const symbolSize = Math.floor((size + opts.margin * 2) * scale);
        const scaledMargin = opts.margin * scale;
        const palette = [opts.color.light, opts.color.dark];
        for (let i = 0; i < symbolSize; i++) {
          for (let j = 0; j < symbolSize; j++) {
            let posDst = (i * symbolSize + j) * 4;
            let pxColor = opts.color.light;
            if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
              const iSrc = Math.floor((i - scaledMargin) / scale);
              const jSrc = Math.floor((j - scaledMargin) / scale);
              pxColor = palette[data7[iSrc * size + jSrc] ? 1 : 0];
            }
            imgData[posDst++] = pxColor.r;
            imgData[posDst++] = pxColor.g;
            imgData[posDst++] = pxColor.b;
            imgData[posDst] = pxColor.a;
          }
        }
      };
    }
  });

  // node_modules/qrcode/lib/renderer/canvas.js
  var require_canvas = __commonJS({
    "node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
      init_process();
      init_buffer();
      var Utils = require_utils27();
      function clearCanvas(ctx, canvas, size) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!canvas.style) canvas.style = {};
        canvas.height = size;
        canvas.width = size;
        canvas.style.height = size + "px";
        canvas.style.width = size + "px";
      }
      function getCanvasElement() {
        try {
          return document.createElement("canvas");
        } catch (e) {
          throw new Error("You need to specify a canvas element");
        }
      }
      exports2.render = function render(qrData, canvas, options) {
        let opts = options;
        let canvasEl = canvas;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!canvas) {
          canvasEl = getCanvasElement();
        }
        opts = Utils.getOptions(opts);
        const size = Utils.getImageWidth(qrData.modules.size, opts);
        const ctx = canvasEl.getContext("2d");
        const image = ctx.createImageData(size, size);
        Utils.qrToImageData(image.data, qrData, opts);
        clearCanvas(ctx, canvasEl, size);
        ctx.putImageData(image, 0, 0);
        return canvasEl;
      };
      exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
        let opts = options;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!opts) opts = {};
        const canvasEl = exports2.render(qrData, canvas, opts);
        const type = opts.type || "image/png";
        const rendererOpts = opts.rendererOpts || {};
        return canvasEl.toDataURL(type, rendererOpts.quality);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/svg-tag.js
  var require_svg_tag = __commonJS({
    "node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
      init_process();
      init_buffer();
      var Utils = require_utils27();
      function getColorAttrib(color, attrib) {
        const alpha = color.a / 255;
        const str = attrib + '="' + color.hex + '"';
        return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
      }
      function svgCmd(cmd, x, y) {
        let str = cmd + x;
        if (typeof y !== "undefined") str += " " + y;
        return str;
      }
      function qrToPath(data7, size, margin) {
        let path7 = "";
        let moveBy = 0;
        let newRow = false;
        let lineLength = 0;
        for (let i = 0; i < data7.length; i++) {
          const col = Math.floor(i % size);
          const row = Math.floor(i / size);
          if (!col && !newRow) newRow = true;
          if (data7[i]) {
            lineLength++;
            if (!(i > 0 && col > 0 && data7[i - 1])) {
              path7 += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
              moveBy = 0;
              newRow = false;
            }
            if (!(col + 1 < size && data7[i + 1])) {
              path7 += svgCmd("h", lineLength);
              lineLength = 0;
            }
          } else {
            moveBy++;
          }
        }
        return path7;
      }
      exports2.render = function render(qrData, options, cb) {
        const opts = Utils.getOptions(options);
        const size = qrData.modules.size;
        const data7 = qrData.modules.data;
        const qrcodesize = size + opts.margin * 2;
        const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
        const path7 = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data7, size, opts.margin) + '"/>';
        const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
        const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
        const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg2 + path7 + "</svg>\n";
        if (typeof cb === "function") {
          cb(null, svgTag);
        }
        return svgTag;
      };
    }
  });

  // node_modules/qrcode/lib/browser.js
  var require_browser5 = __commonJS({
    "node_modules/qrcode/lib/browser.js"(exports2) {
      init_process();
      init_buffer();
      var canPromise = require_can_promise();
      var QRCode2 = require_qrcode();
      var CanvasRenderer = require_canvas();
      var SvgRenderer = require_svg_tag();
      function renderCanvas(renderFunc, canvas, text, opts, cb) {
        const args = [].slice.call(arguments, 1);
        const argsNum = args.length;
        const isLastArgCb = typeof args[argsNum - 1] === "function";
        if (!isLastArgCb && !canPromise()) {
          throw new Error("Callback required as last argument");
        }
        if (isLastArgCb) {
          if (argsNum < 2) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 2) {
            cb = text;
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 3) {
            if (canvas.getContext && typeof cb === "undefined") {
              cb = opts;
              opts = void 0;
            } else {
              cb = opts;
              opts = text;
              text = canvas;
              canvas = void 0;
            }
          }
        } else {
          if (argsNum < 1) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 1) {
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 2 && !canvas.getContext) {
            opts = text;
            text = canvas;
            canvas = void 0;
          }
          return new Promise(function(resolve5, reject5) {
            try {
              const data7 = QRCode2.create(text, opts);
              resolve5(renderFunc(data7, canvas, opts));
            } catch (e) {
              reject5(e);
            }
          });
        }
        try {
          const data7 = QRCode2.create(text, opts);
          cb(null, renderFunc(data7, canvas, opts));
        } catch (e) {
          cb(e);
        }
      }
      exports2.create = QRCode2.create;
      exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
      exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
      exports2.toString = renderCanvas.bind(null, function(data7, _, opts) {
        return SvgRenderer.render(data7, opts);
      });
    }
  });

  // node_modules/toggle-selection/index.js
  var require_toggle_selection = __commonJS({
    "node_modules/toggle-selection/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = function() {
        var selection = document.getSelection();
        if (!selection.rangeCount) {
          return function() {
          };
        }
        var active = document.activeElement;
        var ranges = [];
        for (var i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
        switch (active.tagName.toUpperCase()) {
          // .toUpperCase handles XHTML
          case "INPUT":
          case "TEXTAREA":
            active.blur();
            break;
          default:
            active = null;
            break;
        }
        selection.removeAllRanges();
        return function() {
          selection.type === "Caret" && selection.removeAllRanges();
          if (!selection.rangeCount) {
            ranges.forEach(function(range) {
              selection.addRange(range);
            });
          }
          active && active.focus();
        };
      };
    }
  });

  // node_modules/copy-to-clipboard/index.js
  var require_copy_to_clipboard = __commonJS({
    "node_modules/copy-to-clipboard/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var deselectCurrent = require_toggle_selection();
      var clipboardToIE11Formatting = {
        "text/plain": "Text",
        "text/html": "Url",
        "default": "Text"
      };
      var defaultMessage = "Copy to clipboard: #{key}, Enter";
      function format3(message) {
        var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
        return message.replace(/#{\s*key\s*}/g, copyKey);
      }
      function copy4(text, options) {
        var debug2, message, reselectPrevious, range, selection, mark, success = false;
        if (!options) {
          options = {};
        }
        debug2 = options.debug || false;
        try {
          reselectPrevious = deselectCurrent();
          range = document.createRange();
          selection = document.getSelection();
          mark = document.createElement("span");
          mark.textContent = text;
          mark.ariaHidden = "true";
          mark.style.all = "unset";
          mark.style.position = "fixed";
          mark.style.top = 0;
          mark.style.clip = "rect(0, 0, 0, 0)";
          mark.style.whiteSpace = "pre";
          mark.style.webkitUserSelect = "text";
          mark.style.MozUserSelect = "text";
          mark.style.msUserSelect = "text";
          mark.style.userSelect = "text";
          mark.addEventListener("copy", function(e) {
            e.stopPropagation();
            if (options.format) {
              e.preventDefault();
              if (typeof e.clipboardData === "undefined") {
                debug2 && console.warn("unable to use e.clipboardData");
                debug2 && console.warn("trying IE specific stuff");
                window.clipboardData.clearData();
                var format4 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                window.clipboardData.setData(format4, text);
              } else {
                e.clipboardData.clearData();
                e.clipboardData.setData(options.format, text);
              }
            }
            if (options.onCopy) {
              e.preventDefault();
              options.onCopy(e.clipboardData);
            }
          });
          document.body.appendChild(mark);
          range.selectNodeContents(mark);
          selection.addRange(range);
          var successful = document.execCommand("copy");
          if (!successful) {
            throw new Error("copy command was unsuccessful");
          }
          success = true;
        } catch (err) {
          debug2 && console.error("unable to copy using execCommand: ", err);
          debug2 && console.warn("trying IE specific stuff");
          try {
            window.clipboardData.setData(options.format || "text", text);
            options.onCopy && options.onCopy(window.clipboardData);
            success = true;
          } catch (err2) {
            debug2 && console.error("unable to copy using clipboardData: ", err2);
            debug2 && console.error("falling back to prompt");
            message = format3("message" in options ? options.message : defaultMessage);
            window.prompt(message, text);
          }
        } finally {
          if (selection) {
            if (typeof selection.removeRange == "function") {
              selection.removeRange(range);
            } else {
              selection.removeAllRanges();
            }
          }
          if (mark) {
            document.body.removeChild(mark);
          }
          reselectPrevious();
        }
        return success;
      }
      module2.exports = copy4;
    }
  });

  // node_modules/@near-js/types/lib/commonjs/accounts.cjs
  var require_accounts = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/accounts.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var accounts_exports = {};
      module2.exports = __toCommonJS2(accounts_exports);
    }
  });

  // node_modules/@near-js/types/lib/commonjs/assignable.cjs
  var require_assignable7 = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/assignable.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var assignable_exports = {};
      __export2(assignable_exports, {
        Assignable: () => Assignable
      });
      module2.exports = __toCommonJS2(assignable_exports);
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
    }
  });

  // node_modules/@near-js/types/lib/commonjs/enum.cjs
  var require_enum = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/enum.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var enum_exports = {};
      __export2(enum_exports, {
        Enum: () => Enum
      });
      module2.exports = __toCommonJS2(enum_exports);
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
    }
  });

  // node_modules/@near-js/types/lib/commonjs/errors.cjs
  var require_errors21 = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/errors.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var errors_exports = {};
      __export2(errors_exports, {
        ArgumentTypeError: () => ArgumentTypeError,
        ErrorContext: () => ErrorContext,
        PositionalArgsError: () => PositionalArgsError,
        TypedError: () => TypedError
      });
      module2.exports = __toCommonJS2(errors_exports);
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      var TypedError = class extends Error {
        type;
        context;
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      var ErrorContext = class {
        transactionHash;
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
    }
  });

  // node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs
  var require_light_client7 = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var light_client_exports = {};
      __export2(light_client_exports, {
        IdType: () => IdType2
      });
      module2.exports = __toCommonJS2(light_client_exports);
      var IdType2 = /* @__PURE__ */ ((IdType22) => {
        IdType22["Transaction"] = "transaction";
        IdType22["Receipt"] = "receipt";
        return IdType22;
      })(IdType2 || {});
    }
  });

  // node_modules/@near-js/types/lib/commonjs/provider/response.cjs
  var require_response7 = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/provider/response.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var response_exports = {};
      __export2(response_exports, {
        ExecutionStatusBasic: () => ExecutionStatusBasic2,
        FinalExecutionStatusBasic: () => FinalExecutionStatusBasic2
      });
      module2.exports = __toCommonJS2(response_exports);
      var ExecutionStatusBasic2 = /* @__PURE__ */ ((ExecutionStatusBasic22) => {
        ExecutionStatusBasic22["Unknown"] = "Unknown";
        ExecutionStatusBasic22["Pending"] = "Pending";
        ExecutionStatusBasic22["Failure"] = "Failure";
        return ExecutionStatusBasic22;
      })(ExecutionStatusBasic2 || {});
      var FinalExecutionStatusBasic2 = /* @__PURE__ */ ((FinalExecutionStatusBasic22) => {
        FinalExecutionStatusBasic22["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic22["Started"] = "Started";
        FinalExecutionStatusBasic22["Failure"] = "Failure";
        return FinalExecutionStatusBasic22;
      })(FinalExecutionStatusBasic2 || {});
    }
  });

  // node_modules/@near-js/types/lib/commonjs/provider/index.cjs
  var require_provider16 = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/provider/index.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var provider_exports = {};
      __export2(provider_exports, {
        ExecutionStatusBasic: () => import_response2.ExecutionStatusBasic,
        FinalExecutionStatusBasic: () => import_response2.FinalExecutionStatusBasic,
        IdType: () => import_light_client.IdType
      });
      module2.exports = __toCommonJS2(provider_exports);
      var import_light_client = require_light_client7();
      var import_response2 = require_response7();
    }
  });

  // node_modules/@near-js/types/lib/commonjs/index.cjs
  var require_commonjs = __commonJS({
    "node_modules/@near-js/types/lib/commonjs/index.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var index_exports = {};
      module2.exports = __toCommonJS2(index_exports);
      __reExport(index_exports, require_accounts(), module2.exports);
      __reExport(index_exports, require_assignable7(), module2.exports);
      __reExport(index_exports, require_enum(), module2.exports);
      __reExport(index_exports, require_errors21(), module2.exports);
      __reExport(index_exports, require_provider16(), module2.exports);
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/actions.cjs
  var require_actions4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/actions.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var actions_exports = {};
      __export2(actions_exports, {
        AccessKey: () => AccessKey,
        AccessKeyPermission: () => AccessKeyPermission,
        Action: () => Action,
        AddKey: () => AddKey,
        CreateAccount: () => CreateAccount,
        DeleteAccount: () => DeleteAccount,
        DeleteKey: () => DeleteKey,
        DeployContract: () => DeployContract,
        DeployGlobalContract: () => DeployGlobalContract,
        FullAccessPermission: () => FullAccessPermission,
        FunctionCall: () => FunctionCall,
        FunctionCallPermission: () => FunctionCallPermission,
        GlobalContractDeployMode: () => GlobalContractDeployMode,
        GlobalContractIdentifier: () => GlobalContractIdentifier,
        SignedDelegate: () => SignedDelegate,
        Stake: () => Stake,
        Transfer: () => Transfer,
        UseGlobalContract: () => UseGlobalContract
      });
      module2.exports = __toCommonJS2(actions_exports);
      var import_types = require_commonjs();
      var FunctionCallPermission = class {
        allowance;
        receiverId;
        methodNames;
        constructor({ allowance, receiverId, methodNames }) {
          this.allowance = allowance;
          this.receiverId = receiverId;
          this.methodNames = methodNames;
        }
      };
      var FullAccessPermission = class {
      };
      var AccessKeyPermission = class extends import_types.Enum {
        enum;
        functionCall;
        fullAccess;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
      var AccessKey = class {
        nonce;
        permission;
        constructor({ nonce, permission }) {
          this.nonce = nonce;
          this.permission = permission;
        }
      };
      var CreateAccount = class {
      };
      var DeployContract = class {
        code;
        constructor({ code }) {
          this.code = code;
        }
      };
      var FunctionCall = class {
        methodName;
        args;
        gas;
        deposit;
        constructor({ methodName, args, gas, deposit }) {
          this.methodName = methodName;
          this.args = args;
          this.gas = gas;
          this.deposit = deposit;
        }
      };
      var GlobalContractDeployMode = class extends import_types.Enum {
        enum;
        CodeHash;
        AccountId;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
      var GlobalContractIdentifier = class extends import_types.Enum {
        enum;
        CodeHash;
        AccountId;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
      var DeployGlobalContract = class {
        code;
        deployMode;
        constructor({ code, deployMode }) {
          this.code = code;
          this.deployMode = deployMode;
        }
      };
      var UseGlobalContract = class {
        contractIdentifier;
        constructor({ contractIdentifier }) {
          this.contractIdentifier = contractIdentifier;
        }
      };
      var Transfer = class {
        deposit;
        constructor({ deposit }) {
          this.deposit = deposit;
        }
      };
      var Stake = class {
        stake;
        publicKey;
        constructor({ stake, publicKey }) {
          this.stake = stake;
          this.publicKey = publicKey;
        }
      };
      var AddKey = class {
        publicKey;
        accessKey;
        constructor({ publicKey, accessKey }) {
          this.publicKey = publicKey;
          this.accessKey = accessKey;
        }
      };
      var DeleteKey = class {
        publicKey;
        constructor({ publicKey }) {
          this.publicKey = publicKey;
        }
      };
      var DeleteAccount = class {
        beneficiaryId;
        constructor({ beneficiaryId }) {
          this.beneficiaryId = beneficiaryId;
        }
      };
      var SignedDelegate = class {
        delegateAction;
        signature;
        constructor({ delegateAction, signature }) {
          this.delegateAction = delegateAction;
          this.signature = signature;
        }
      };
      var Action = class extends import_types.Enum {
        enum;
        createAccount;
        deployContract;
        functionCall;
        transfer;
        stake;
        addKey;
        deleteKey;
        deleteAccount;
        signedDelegate;
        deployGlobalContract;
        useGlobalContract;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs
  var require_action_creators4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var action_creators_exports = {};
      __export2(action_creators_exports, {
        actionCreators: () => actionCreators,
        stringifyJsonOrBytes: () => stringifyJsonOrBytes
      });
      module2.exports = __toCommonJS2(action_creators_exports);
      var import_actions = require_actions4();
      function fullAccessKey() {
        return new import_actions.AccessKey({
          nonce: 0n,
          permission: new import_actions.AccessKeyPermission({
            fullAccess: new import_actions.FullAccessPermission()
          })
        });
      }
      function functionCallAccessKey(receiverId, methodNames, allowance) {
        return new import_actions.AccessKey({
          nonce: 0n,
          permission: new import_actions.AccessKeyPermission({
            functionCall: new import_actions.FunctionCallPermission({
              receiverId,
              allowance,
              methodNames
            })
          })
        });
      }
      function createAccount() {
        return new import_actions.Action({ createAccount: new import_actions.CreateAccount() });
      }
      function deployContract(code) {
        return new import_actions.Action({ deployContract: new import_actions.DeployContract({ code }) });
      }
      function stringifyJsonOrBytes(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        return isUint8Array ? args : Buffer.from(JSON.stringify(args));
      }
      function functionCall(methodName, args, gas = 0n, deposit = 0n, stringify2 = stringifyJsonOrBytes) {
        return new import_actions.Action({
          functionCall: new import_actions.FunctionCall({
            methodName,
            args: stringify2(args),
            gas,
            deposit
          })
        });
      }
      function transfer(deposit = 0n) {
        return new import_actions.Action({ transfer: new import_actions.Transfer({ deposit }) });
      }
      function stake(stake2 = 0n, publicKey) {
        return new import_actions.Action({ stake: new import_actions.Stake({ stake: stake2, publicKey }) });
      }
      function addKey(publicKey, accessKey) {
        return new import_actions.Action({ addKey: new import_actions.AddKey({ publicKey, accessKey }) });
      }
      function deleteKey(publicKey) {
        return new import_actions.Action({ deleteKey: new import_actions.DeleteKey({ publicKey }) });
      }
      function deleteAccount(beneficiaryId) {
        return new import_actions.Action({ deleteAccount: new import_actions.DeleteAccount({ beneficiaryId }) });
      }
      function signedDelegate({
        delegateAction,
        signature
      }) {
        return new import_actions.Action({
          signedDelegate: new import_actions.SignedDelegate({ delegateAction, signature })
        });
      }
      function deployGlobalContract(code, deployMode) {
        return new import_actions.Action({ deployGlobalContract: new import_actions.DeployGlobalContract({ code, deployMode }) });
      }
      function useGlobalContract(contractIdentifier) {
        return new import_actions.Action({ useGlobalContract: new import_actions.UseGlobalContract({ contractIdentifier }) });
      }
      var actionCreators = {
        addKey,
        createAccount,
        deleteAccount,
        deleteKey,
        deployContract,
        fullAccessKey,
        functionCall,
        functionCallAccessKey,
        signedDelegate,
        stake,
        transfer,
        deployGlobalContract,
        useGlobalContract
      };
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/prefix.cjs
  var require_prefix4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/prefix.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var prefix_exports = {};
      __export2(prefix_exports, {
        DelegateActionPrefix: () => DelegateActionPrefix
      });
      module2.exports = __toCommonJS2(prefix_exports);
      var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
      var NEP = {
        MetaTransactions: 366
      };
      var NEPPrefix = class {
        prefix;
        constructor({ prefix }) {
          this.prefix = prefix;
        }
      };
      var ActionableMessagePrefix = class extends NEPPrefix {
        /** Given the NEP number, set the prefix using 2^30 as the offset **/
        constructor(prefix) {
          super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
        }
      };
      var DelegateActionPrefix = class extends ActionableMessagePrefix {
        constructor() {
          super(NEP.MetaTransactions);
        }
      };
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/schema.cjs
  var require_schema4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/schema.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var schema_exports = {};
      __export2(schema_exports, {
        SCHEMA: () => SCHEMA,
        SignedTransaction: () => SignedTransaction,
        Transaction: () => Transaction,
        decodeSignedTransaction: () => decodeSignedTransaction,
        decodeTransaction: () => decodeTransaction,
        encodeDelegateAction: () => encodeDelegateAction,
        encodeSignedDelegate: () => encodeSignedDelegate,
        encodeTransaction: () => encodeTransaction
      });
      module2.exports = __toCommonJS2(schema_exports);
      var import_borsh2 = require_cjs();
      var import_prefix = require_prefix4();
      function encodeDelegateAction(delegateAction) {
        return new Uint8Array([
          ...(0, import_borsh2.serialize)(SCHEMA.DelegateActionPrefix, new import_prefix.DelegateActionPrefix()),
          ...(0, import_borsh2.serialize)(SCHEMA.DelegateAction, delegateAction)
        ]);
      }
      function encodeSignedDelegate(signedDelegate) {
        return (0, import_borsh2.serialize)(SCHEMA.SignedDelegate, signedDelegate);
      }
      function encodeTransaction(transaction) {
        const schema = "signature" in transaction ? SCHEMA.SignedTransaction : SCHEMA.Transaction;
        return (0, import_borsh2.serialize)(schema, transaction);
      }
      function decodeTransaction(bytes) {
        return new Transaction((0, import_borsh2.deserialize)(SCHEMA.Transaction, bytes));
      }
      function decodeSignedTransaction(bytes) {
        return new SignedTransaction((0, import_borsh2.deserialize)(SCHEMA.SignedTransaction, bytes));
      }
      var Transaction = class {
        signerId;
        publicKey;
        nonce;
        receiverId;
        actions;
        blockHash;
        constructor({ signerId, publicKey, nonce, receiverId, actions, blockHash }) {
          this.signerId = signerId;
          this.publicKey = publicKey;
          this.nonce = nonce;
          this.receiverId = receiverId;
          this.actions = actions;
          this.blockHash = blockHash;
        }
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeTransaction(bytes);
        }
      };
      var SignedTransaction = class {
        transaction;
        signature;
        constructor({ transaction, signature }) {
          this.transaction = transaction;
          this.signature = signature;
        }
        encode() {
          return encodeTransaction(this);
        }
        static decode(bytes) {
          return decodeSignedTransaction(bytes);
        }
      };
      var SCHEMA = new class BorshSchema {
        Ed25519Signature = {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        };
        Secp256k1Signature = {
          struct: {
            data: { array: { type: "u8", len: 65 } }
          }
        };
        Signature = {
          enum: [
            { struct: { ed25519Signature: this.Ed25519Signature } },
            { struct: { secp256k1Signature: this.Secp256k1Signature } }
          ]
        };
        Ed25519Data = {
          struct: {
            data: { array: { type: "u8", len: 32 } }
          }
        };
        Secp256k1Data = {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        };
        PublicKey = {
          enum: [
            { struct: { ed25519Key: this.Ed25519Data } },
            { struct: { secp256k1Key: this.Secp256k1Data } }
          ]
        };
        FunctionCallPermission = {
          struct: {
            allowance: { option: "u128" },
            receiverId: "string",
            methodNames: { array: { type: "string" } }
          }
        };
        FullAccessPermission = {
          struct: {}
        };
        AccessKeyPermission = {
          enum: [
            { struct: { functionCall: this.FunctionCallPermission } },
            { struct: { fullAccess: this.FullAccessPermission } }
          ]
        };
        AccessKey = {
          struct: {
            nonce: "u64",
            permission: this.AccessKeyPermission
          }
        };
        CreateAccount = {
          struct: {}
        };
        DeployContract = {
          struct: {
            code: { array: { type: "u8" } }
          }
        };
        FunctionCall = {
          struct: {
            methodName: "string",
            args: { array: { type: "u8" } },
            gas: "u64",
            deposit: "u128"
          }
        };
        Transfer = {
          struct: {
            deposit: "u128"
          }
        };
        Stake = {
          struct: {
            stake: "u128",
            publicKey: this.PublicKey
          }
        };
        AddKey = {
          struct: {
            publicKey: this.PublicKey,
            accessKey: this.AccessKey
          }
        };
        DeleteKey = {
          struct: {
            publicKey: this.PublicKey
          }
        };
        DeleteAccount = {
          struct: {
            beneficiaryId: "string"
          }
        };
        GlobalContractDeployMode = {
          enum: [
            { struct: { CodeHash: { struct: {} } } },
            { struct: { AccountId: { struct: {} } } }
          ]
        };
        GlobalContractIdentifier = {
          enum: [
            { struct: { CodeHash: { array: { type: "u8", len: 32 } } } },
            { struct: { AccountId: "string" } }
          ]
        };
        DeployGlobalContract = {
          struct: {
            code: { array: { type: "u8" } },
            deployMode: this.GlobalContractDeployMode
          }
        };
        UseGlobalContract = {
          struct: {
            contractIdentifier: this.GlobalContractIdentifier
          }
        };
        DelegateActionPrefix = {
          struct: {
            prefix: "u32"
          }
        };
        /** @todo: get rid of "ClassicActions" and keep only "Action" schema to be consistent with "nearcore" */
        ClassicActions = {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } },
            { struct: { signedDelegate: "string" } },
            // placeholder to keep the right enum order, should not be used 
            { struct: { deployGlobalContract: this.DeployGlobalContract } },
            { struct: { useGlobalContract: this.UseGlobalContract } }
          ]
        };
        DelegateAction = {
          struct: {
            senderId: "string",
            receiverId: "string",
            actions: { array: { type: this.ClassicActions } },
            nonce: "u64",
            maxBlockHeight: "u64",
            publicKey: this.PublicKey
          }
        };
        SignedDelegate = {
          struct: {
            delegateAction: this.DelegateAction,
            signature: this.Signature
          }
        };
        Action = {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } },
            { struct: { signedDelegate: this.SignedDelegate } },
            { struct: { deployGlobalContract: this.DeployGlobalContract } },
            { struct: { useGlobalContract: this.UseGlobalContract } }
          ]
        };
        Transaction = {
          struct: {
            signerId: "string",
            publicKey: this.PublicKey,
            nonce: "u64",
            receiverId: "string",
            blockHash: { array: { type: "u8", len: 32 } },
            actions: { array: { type: this.Action } }
          }
        };
        SignedTransaction = {
          struct: {
            transaction: this.Transaction,
            signature: this.Signature
          }
        };
      }();
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs
  var require_create_transaction4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var create_transaction_exports = {};
      __export2(create_transaction_exports, {
        createTransaction: () => createTransaction
      });
      module2.exports = __toCommonJS2(create_transaction_exports);
      var import_schema = require_schema4();
      function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
        return new import_schema.Transaction({
          signerId,
          publicKey,
          nonce: txNonce,
          receiverId,
          actions,
          blockHash
        });
      }
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/delegate.cjs
  var require_delegate4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/delegate.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var delegate_exports = {};
      __export2(delegate_exports, {
        DelegateAction: () => DelegateAction,
        buildDelegateAction: () => buildDelegateAction
      });
      module2.exports = __toCommonJS2(delegate_exports);
      var import_action_creators = require_action_creators4();
      var import_actions = require_actions4();
      var {
        addKey,
        createAccount,
        deleteAccount,
        deleteKey,
        deployContract,
        functionCall,
        stake,
        transfer,
        deployGlobalContract,
        useGlobalContract
      } = import_action_creators.actionCreators;
      var DelegateAction = class {
        senderId;
        receiverId;
        actions;
        nonce;
        maxBlockHeight;
        publicKey;
        constructor({ senderId, receiverId, actions, nonce, maxBlockHeight, publicKey }) {
          this.senderId = senderId;
          this.receiverId = receiverId;
          this.actions = actions;
          this.nonce = nonce;
          this.maxBlockHeight = maxBlockHeight;
          this.publicKey = publicKey;
        }
      };
      function buildDelegateAction({
        actions,
        maxBlockHeight,
        nonce,
        publicKey,
        receiverId,
        senderId
      }) {
        return new DelegateAction({
          senderId,
          receiverId,
          actions: actions.map((a) => {
            if (!a.type && !a.params) {
              return a;
            }
            switch (a.type) {
              case "AddKey": {
                const { publicKey: publicKey2, accessKey } = a.params;
                return addKey(publicKey2, accessKey);
              }
              case "CreateAccount": {
                return createAccount(a.params.createAccount);
              }
              case "DeleteAccount": {
                return deleteAccount(a.params.deleteAccount);
              }
              case "DeleteKey": {
                return deleteKey(a.params.publicKey);
              }
              case "DeployContract": {
                return deployContract(a.params.code);
              }
              case "FunctionCall": {
                const { methodName, args, gas, deposit } = a.params;
                return functionCall(methodName, args, gas, deposit);
              }
              case "Stake": {
                return stake(a.params.stake, a.params.publicKey);
              }
              case "Transfer": {
                const { deposit } = a.params;
                return transfer(deposit);
              }
              case "DeployGlobalContract": {
                const { code, deployMode } = a.params;
                const modeInstance = deployMode instanceof import_actions.GlobalContractDeployMode ? deployMode : new import_actions.GlobalContractDeployMode(deployMode);
                return deployGlobalContract(code, modeInstance);
              }
              case "UseGlobalContract": {
                const { identifier } = a.params;
                const idInstance = identifier instanceof import_actions.GlobalContractIdentifier ? identifier : new import_actions.GlobalContractIdentifier(identifier);
                return useGlobalContract(idInstance);
              }
            }
            throw new Error("Unrecognized action");
          }),
          nonce,
          maxBlockHeight,
          publicKey
        });
      }
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/constants.cjs
  var require_constants14 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/constants.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var KeyType = /* @__PURE__ */ ((KeyType2) => {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
        KeyType2[KeyType2["SECP256K1"] = 1] = "SECP256K1";
        return KeyType2;
      })(KeyType || {});
      var KeySize = {
        SECRET_KEY: 32,
        ED25519_PUBLIC_KEY: 32,
        SECP256k1_PUBLIC_KEY: 64
      };
      exports2.KeySize = KeySize;
      exports2.KeyType = KeyType;
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs
  var require_key_pair_base7 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@scure/base/lib/index.js
  var require_lib31 = __commonJS({
    "node_modules/@scure/base/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.bytes = exports2.stringToBytes = exports2.str = exports2.bytesToString = exports2.hex = exports2.utf8 = exports2.bech32m = exports2.bech32 = exports2.base58check = exports2.createBase58check = exports2.base58xmr = exports2.base58xrp = exports2.base58flickr = exports2.base58 = exports2.base64urlnopad = exports2.base64url = exports2.base64nopad = exports2.base64 = exports2.base32crockford = exports2.base32hexnopad = exports2.base32hex = exports2.base32nopad = exports2.base32 = exports2.base16 = exports2.utils = void 0;
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function abytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }
      function isArrayOf(isString2, arr) {
        if (!Array.isArray(arr))
          return false;
        if (arr.length === 0)
          return true;
        if (isString2) {
          return arr.every((item) => typeof item === "string");
        } else {
          return arr.every((item) => Number.isSafeInteger(item));
        }
      }
      function afn(input) {
        if (typeof input !== "function")
          throw new Error("function expected");
        return true;
      }
      function astr(label, input) {
        if (typeof input !== "string")
          throw new Error(`${label}: string expected`);
        return true;
      }
      function anumber(n) {
        if (!Number.isSafeInteger(n))
          throw new Error(`invalid integer: ${n}`);
      }
      function aArr(input) {
        if (!Array.isArray(input))
          throw new Error("array expected");
      }
      function astrArr(label, input) {
        if (!isArrayOf(true, input))
          throw new Error(`${label}: array of strings expected`);
      }
      function anumArr(label, input) {
        if (!isArrayOf(false, input))
          throw new Error(`${label}: array of numbers expected`);
      }
      // @__NO_SIDE_EFFECTS__
      function chain(...args) {
        const id7 = (a) => a;
        const wrap = (a, b) => (c) => a(b(c));
        const encode3 = args.map((x) => x.encode).reduceRight(wrap, id7);
        const decode = args.map((x) => x.decode).reduce(wrap, id7);
        return { encode: encode3, decode };
      }
      // @__NO_SIDE_EFFECTS__
      function alphabet(letters) {
        const lettersA = typeof letters === "string" ? letters.split("") : letters;
        const len = lettersA.length;
        astrArr("alphabet", lettersA);
        const indexes = new Map(lettersA.map((l, i) => [l, i]));
        return {
          encode: (digits) => {
            aArr(digits);
            return digits.map((i) => {
              if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
              return lettersA[i];
            });
          },
          decode: (input) => {
            aArr(input);
            return input.map((letter) => {
              astr("alphabet.decode", letter);
              const i = indexes.get(letter);
              if (i === void 0)
                throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
              return i;
            });
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function join(separator = "") {
        astr("join", separator);
        return {
          encode: (from5) => {
            astrArr("join.decode", from5);
            return from5.join(separator);
          },
          decode: (to) => {
            astr("join.decode", to);
            return to.split(separator);
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function padding(bits, chr = "=") {
        anumber(bits);
        astr("padding", chr);
        return {
          encode(data7) {
            astrArr("padding.encode", data7);
            while (data7.length * bits % 8)
              data7.push(chr);
            return data7;
          },
          decode(input) {
            astrArr("padding.decode", input);
            let end = input.length;
            if (end * bits % 8)
              throw new Error("padding: invalid, string should have whole number of bytes");
            for (; end > 0 && input[end - 1] === chr; end--) {
              const last5 = end - 1;
              const byte = last5 * bits;
              if (byte % 8 === 0)
                throw new Error("padding: invalid, string has too much padding");
            }
            return input.slice(0, end);
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function normalize7(fn) {
        afn(fn);
        return { encode: (from5) => from5, decode: (to) => fn(to) };
      }
      function convertRadix(data7, from5, to) {
        if (from5 < 2)
          throw new Error(`convertRadix: invalid from=${from5}, base cannot be less than 2`);
        if (to < 2)
          throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
        aArr(data7);
        if (!data7.length)
          return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data7, (d) => {
          anumber(d);
          if (d < 0 || d >= from5)
            throw new Error(`invalid integer: ${d}`);
          return d;
        });
        const dlen = digits.length;
        while (true) {
          let carry = 0;
          let done2 = true;
          for (let i = pos; i < dlen; i++) {
            const digit = digits[i];
            const fromCarry = from5 * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from5 !== carry || digitBase - digit !== fromCarry) {
              throw new Error("convertRadix: carry overflow");
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
              throw new Error("convertRadix: carry overflow");
            if (!done2)
              continue;
            else if (!rounded)
              pos = i;
            else
              done2 = false;
          }
          res.push(carry);
          if (done2)
            break;
        }
        for (let i = 0; i < data7.length - 1 && data7[i] === 0; i++)
          res.push(0);
        return res.reverse();
      }
      var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
      var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from5, to) => from5 + (to - gcd(from5, to));
      var powers = /* @__PURE__ */ (() => {
        let res = [];
        for (let i = 0; i < 40; i++)
          res.push(2 ** i);
        return res;
      })();
      function convertRadix2(data7, from5, to, padding2) {
        aArr(data7);
        if (from5 <= 0 || from5 > 32)
          throw new Error(`convertRadix2: wrong from=${from5}`);
        if (to <= 0 || to > 32)
          throw new Error(`convertRadix2: wrong to=${to}`);
        if (/* @__PURE__ */ radix2carry(from5, to) > 32) {
          throw new Error(`convertRadix2: carry overflow from=${from5} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from5, to)}`);
        }
        let carry = 0;
        let pos = 0;
        const max7 = powers[from5];
        const mask = powers[to] - 1;
        const res = [];
        for (const n of data7) {
          anumber(n);
          if (n >= max7)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from5}`);
          carry = carry << from5 | n;
          if (pos + from5 > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from5}`);
          pos += from5;
          for (; pos >= to; pos -= to)
            res.push((carry >> pos - to & mask) >>> 0);
          const pow3 = powers[pos];
          if (pow3 === void 0)
            throw new Error("invalid carry");
          carry &= pow3 - 1;
        }
        carry = carry << to - pos & mask;
        if (!padding2 && pos >= from5)
          throw new Error("Excess padding");
        if (!padding2 && carry > 0)
          throw new Error(`Non-zero padding: ${carry}`);
        if (padding2 && pos > 0)
          res.push(carry >>> 0);
        return res;
      }
      // @__NO_SIDE_EFFECTS__
      function radix(num) {
        anumber(num);
        const _256 = 2 ** 8;
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix.encode input should be Uint8Array");
            return convertRadix(Array.from(bytes), _256, num);
          },
          decode: (digits) => {
            anumArr("radix.decode", digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function radix2(bits, revPadding = false) {
        anumber(bits);
        if (bits <= 0 || bits > 32)
          throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
          },
          decode: (digits) => {
            anumArr("radix2.decode", digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
          }
        };
      }
      function unsafeWrapper(fn) {
        afn(fn);
        return function(...args) {
          try {
            return fn.apply(null, args);
          } catch (e) {
          }
        };
      }
      function checksum(len, fn) {
        anumber(len);
        afn(fn);
        return {
          encode(data7) {
            if (!isBytes(data7))
              throw new Error("checksum.encode: input should be Uint8Array");
            const sum = fn(data7).slice(0, len);
            const res = new Uint8Array(data7.length + len);
            res.set(data7);
            res.set(sum, data7.length);
            return res;
          },
          decode(data7) {
            if (!isBytes(data7))
              throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data7.slice(0, -len);
            const oldChecksum = data7.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for (let i = 0; i < len; i++)
              if (newChecksum[i] !== oldChecksum[i])
                throw new Error("Invalid checksum");
            return payload;
          }
        };
      }
      exports2.utils = {
        alphabet,
        chain,
        checksum,
        convertRadix,
        convertRadix2,
        radix,
        radix2,
        join,
        padding
      };
      exports2.base16 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789ABCDEF"), /* @__PURE__ */ join(""));
      exports2.base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
      exports2.base32nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ join(""));
      exports2.base32hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
      exports2.base32hexnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ join(""));
      exports2.base32crockford = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize7((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
      var hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
      var decodeBase64Builtin = (s, isUrl) => {
        astr("base64", s);
        const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
        const alphabet2 = isUrl ? "base64url" : "base64";
        if (s.length > 0 && !re.test(s))
          throw new Error("invalid base64");
        return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
      };
      exports2.base64 = hasBase64Builtin ? {
        encode(b) {
          abytes(b);
          return b.toBase64();
        },
        decode(s) {
          return decodeBase64Builtin(s, false);
        }
      } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
      exports2.base64nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ join(""));
      exports2.base64url = hasBase64Builtin ? {
        encode(b) {
          abytes(b);
          return b.toBase64({ alphabet: "base64url" });
        },
        decode(s) {
          return decodeBase64Builtin(s, true);
        }
      } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
      exports2.base64urlnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ join(""));
      var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
      exports2.base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports2.base58flickr = /* @__PURE__ */ genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
      exports2.base58xrp = /* @__PURE__ */ genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
      var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
      exports2.base58xmr = {
        encode(data7) {
          let res = "";
          for (let i = 0; i < data7.length; i += 8) {
            const block = data7.subarray(i, i + 8);
            res += exports2.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
          }
          return res;
        },
        decode(str) {
          let res = [];
          for (let i = 0; i < str.length; i += 11) {
            const slice4 = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice4.length);
            const block = exports2.base58.decode(slice4);
            for (let j = 0; j < block.length - blockLen; j++) {
              if (block[j] !== 0)
                throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
          }
          return Uint8Array.from(res);
        }
      };
      var createBase58check = (sha2562) => /* @__PURE__ */ chain(checksum(4, (data7) => sha2562(sha2562(data7))), exports2.base58);
      exports2.createBase58check = createBase58check;
      exports2.base58check = exports2.createBase58check;
      var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
      var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function bech32Polymod(pre) {
        const b = pre >> 25;
        let chk = (pre & 33554431) << 5;
        for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
          if ((b >> i & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
        }
        return chk;
      }
      function bechChecksum(prefix, words, encodingConst = 1) {
        const len = prefix.length;
        let chk = 1;
        for (let i = 0; i < len; i++) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
          chk = bech32Polymod(chk) ^ c >> 5;
        }
        chk = bech32Polymod(chk);
        for (let i = 0; i < len; i++)
          chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
        for (let v of words)
          chk = bech32Polymod(chk) ^ v;
        for (let i = 0; i < 6; i++)
          chk = bech32Polymod(chk);
        chk ^= encodingConst;
        return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
      }
      // @__NO_SIDE_EFFECTS__
      function genBech32(encoding) {
        const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
        const _words = /* @__PURE__ */ radix2(5);
        const fromWords = _words.decode;
        const toWords = _words.encode;
        const fromWordsUnsafe = unsafeWrapper(fromWords);
        function encode3(prefix, words, limit = 90) {
          astr("bech32.encode prefix", prefix);
          if (isBytes(words))
            words = Array.from(words);
          anumArr("bech32.encode", words);
          const plen = prefix.length;
          if (plen === 0)
            throw new TypeError(`Invalid prefix length ${plen}`);
          const actualLength = plen + 7 + words.length;
          if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
          const lowered = prefix.toLowerCase();
          const sum = bechChecksum(lowered, words, ENCODING_CONST);
          return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
        }
        function decode(str, limit = 90) {
          astr("bech32.decode input", str);
          const slen = str.length;
          if (slen < 8 || limit !== false && slen > limit)
            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
          const lowered = str.toLowerCase();
          if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
          const sepIndex = lowered.lastIndexOf("1");
          if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
          const prefix = lowered.slice(0, sepIndex);
          const data7 = lowered.slice(sepIndex + 1);
          if (data7.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const words = BECH_ALPHABET.decode(data7).slice(0, -6);
          const sum = bechChecksum(prefix, words, ENCODING_CONST);
          if (!data7.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
          return { prefix, words };
        }
        const decodeUnsafe = unsafeWrapper(decode);
        function decodeToBytes(str) {
          const { prefix, words } = decode(str, false);
          return { prefix, words, bytes: fromWords(words) };
        }
        function encodeFromBytes(prefix, bytes) {
          return encode3(prefix, toWords(bytes));
        }
        return {
          encode: encode3,
          decode,
          encodeFromBytes,
          decodeToBytes,
          decodeUnsafe,
          fromWords,
          fromWordsUnsafe,
          toWords
        };
      }
      exports2.bech32 = /* @__PURE__ */ genBech32("bech32");
      exports2.bech32m = /* @__PURE__ */ genBech32("bech32m");
      exports2.utf8 = {
        encode: (data7) => new TextDecoder().decode(data7),
        decode: (str) => new TextEncoder().encode(str)
      };
      var hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
      var hexBuiltin = {
        encode(data7) {
          abytes(data7);
          return data7.toHex();
        },
        decode(s) {
          astr("hex", s);
          return Uint8Array.fromHex(s);
        }
      };
      exports2.hex = hasHexBuiltin ? hexBuiltin : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789abcdef"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize7((s) => {
        if (typeof s !== "string" || s.length % 2 !== 0)
          throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
      }));
      var CODERS = {
        utf8: exports2.utf8,
        hex: exports2.hex,
        base16: exports2.base16,
        base32: exports2.base32,
        base64: exports2.base64,
        base64url: exports2.base64url,
        base58: exports2.base58,
        base58xmr: exports2.base58xmr
      };
      var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
      var bytesToString = (type, bytes) => {
        if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (!isBytes(bytes))
          throw new TypeError("bytesToString() expects Uint8Array");
        return CODERS[type].encode(bytes);
      };
      exports2.bytesToString = bytesToString;
      exports2.str = exports2.bytesToString;
      var stringToBytes = (type, str) => {
        if (!CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (typeof str !== "string")
          throw new TypeError("stringToBytes() expects string");
        return CODERS[type].decode(str);
      };
      exports2.stringToBytes = stringToBytes;
      exports2.bytes = exports2.stringToBytes;
    }
  });

  // node_modules/@near-js/utils/lib/commonjs/index.cjs
  var require_commonjs2 = __commonJS({
    "node_modules/@near-js/utils/lib/commonjs/index.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var index_exports = {};
      __export2(index_exports, {
        ConsoleLogger: () => ConsoleLogger,
        DEFAULT_FUNCTION_CALL_GAS: () => DEFAULT_FUNCTION_CALL_GAS,
        ErrorMessages: () => ErrorMessages,
        Logger: () => Logger2,
        NEAR_NOMINATION: () => NEAR_NOMINATION,
        NEAR_NOMINATION_EXP: () => NEAR_NOMINATION_EXP,
        ServerError: () => ServerError,
        baseDecode: () => baseDecode,
        baseEncode: () => baseEncode,
        diffEpochValidators: () => diffEpochValidators,
        findSeatPrice: () => findSeatPrice,
        formatError: () => formatError2,
        formatNearAmount: () => formatNearAmount,
        getErrorTypeFromErrorMessage: () => getErrorTypeFromErrorMessage,
        getTransactionLastResult: () => getTransactionLastResult,
        parseNearAmount: () => parseNearAmount,
        parseResultError: () => parseResultError,
        parseRpcError: () => parseRpcError,
        printTxOutcomeLogs: () => printTxOutcomeLogs,
        printTxOutcomeLogsAndFailures: () => printTxOutcomeLogsAndFailures,
        sortBigIntAsc: () => sortBigIntAsc
      });
      module2.exports = __toCommonJS2(index_exports);
      var DEFAULT_FUNCTION_CALL_GAS = 30000000000000n;
      var error_messages_default = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed",
        ShardCongested: "Shard {{shard_id}} rejected the transaction due to congestion level {{congestion_level}}, try again later",
        ShardStuck: "Shard {{shard_id}} rejected the transaction because it missed {{missed_chunks}} chunks and needs to recover before accepting new transactions, try again later"
      };
      var ErrorMessages = error_messages_default;
      var import_types = require_commonjs();
      var import_mustache = __toESM2(require_mustache(), 1);
      var import_base = require_lib31();
      var NEAR_NOMINATION_EXP = 24;
      var NEAR_NOMINATION = 10n ** BigInt(NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = 10n;
      for (let i = 0, offset = 5n; i < NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== NEAR_NOMINATION_EXP) {
          const roundingExp = NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - NEAR_NOMINATION_EXP).padStart(NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(
          wholePart + fracPart.padEnd(NEAR_NOMINATION_EXP, "0")
        );
      }
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return import_base.base58.encode(value);
      }
      function baseDecode(value) {
        return import_base.base58.decode(value);
      }
      var rpc_error_schema_default = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              forwarded_buffered_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_buffered_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded",
              "StorageError",
              "ShardCongested",
              "ShardStuck"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptSizeExceeded: {
            name: "ReceiptSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation",
              "ReceiptSizeExceeded"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          ShardCongested: {
            name: "ShardCongested",
            subtypes: [],
            props: {
              congestion_level: "",
              shard_id: ""
            }
          },
          ShardStuck: {
            name: "ShardStuck",
            subtypes: [],
            props: {
              missed_chunks: "",
              shard_id: ""
            }
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
      var mustacheHelpers = {
        formatNear: () => (n, render) => formatNearAmount(render(n))
      };
      var ServerError = class extends import_types.TypedError {
      };
      var ServerTransactionError = class extends ServerError {
        transaction_outcome;
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      function formatError2(errorClassName, errorData) {
        if (typeof ErrorMessages[errorClassName] === "string") {
          return import_mustache.default.render(ErrorMessages[errorClassName], {
            ...errorData,
            ...mustacheHelpers
          });
        }
        return JSON.stringify(errorData);
      }
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
        }
        isLevelEnabled = (level) => {
          return this.logLevels.includes(level);
        };
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose")) return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug")) return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log")) return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn")) return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error")) return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal")) return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = new ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static instanceRef = DEFAULT_LOGGER;
        /** @deprecated Will be removed in the next major release */
        static overrideLogger = (logger2) => {
          this.instanceRef = logger2;
        };
        static error(message, ...optionalParams) {
          this.instanceRef?.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          this.instanceRef?.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          this.instanceRef?.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          this.instanceRef?.debug?.(message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          this.instanceRef?.verbose?.(message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          this.instanceRef?.fatal?.(message, ...optionalParams);
        }
      };
      function printTxOutcomeLogsAndFailures({
        contractId,
        outcome
      }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? parseRpcError(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          Logger2.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            Logger2.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      function printTxOutcomeLogs({
        contractId,
        logs,
        prefix = ""
      }) {
        for (const log3 of logs) {
          Logger2.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      var import_depd = __toESM2(require_browser(), 1);
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, import_depd.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = 1n, right = stakesSum + 1n;
        while (left !== right - 1n) {
          const mid = (left + right) / 2n;
          let found = false;
          let currentSum = 0n;
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + 1n;
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
  var require_assert11 = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.anumber = anumber;
      exports2.abytes = abytes;
      exports2.ahash = ahash;
      exports2.aexists = aexists;
      exports2.aoutput = aoutput;
      function anumber(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error("positive integer expected, got " + n);
      }
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function abytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }
      function ahash(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        anumber(h.outputLen);
        anumber(h.blockLen);
      }
      function aexists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function aoutput(out, instance) {
        abytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error("digestInto() expects output buffer of length at least " + min7);
        }
      }
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
  var require_crypto12 = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
  var require_utils28 = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Hash = exports2.nextTick = exports2.byteSwapIfBE = exports2.isLE = void 0;
      exports2.isBytes = isBytes;
      exports2.u8 = u8;
      exports2.u32 = u32;
      exports2.createView = createView;
      exports2.rotr = rotr;
      exports2.rotl = rotl;
      exports2.byteSwap = byteSwap;
      exports2.byteSwap32 = byteSwap32;
      exports2.bytesToHex = bytesToHex;
      exports2.hexToBytes = hexToBytes;
      exports2.asyncLoop = asyncLoop;
      exports2.utf8ToBytes = utf8ToBytes3;
      exports2.toBytes = toBytes;
      exports2.concatBytes = concatBytes;
      exports2.checkOpts = checkOpts;
      exports2.wrapConstructor = wrapConstructor;
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      exports2.randomBytes = randomBytes;
      var crypto_1 = require_crypto12();
      var _assert_js_1 = require_assert11();
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function u8(arr) {
        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function u32(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      }
      function createView(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function rotr(word, shift) {
        return word << 32 - shift | word >>> shift;
      }
      function rotl(word, shift) {
        return word << shift | word >>> 32 - shift >>> 0;
      }
      exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      function byteSwap(word) {
        return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      }
      exports2.byteSwapIfBE = exports2.isLE ? (n) => n : (n) => byteSwap(n);
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = byteSwap(arr[i]);
        }
      }
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        (0, _assert_js_1.abytes)(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error("utf8ToBytes expected string, got " + typeof str);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        (0, _assert_js_1.abytes)(data7);
        return data7;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          (0, _assert_js_1.abytes)(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return crypto_1.crypto.randomBytes(bytesLength);
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/_md.js
  var require_md = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/_md.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HashMD = void 0;
      exports2.setBigUint64 = setBigUint64;
      exports2.Chi = Chi;
      exports2.Maj = Maj;
      var _assert_js_1 = require_assert11();
      var utils_js_1 = require_utils28();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      function Chi(a, b, c) {
        return a & b ^ ~a & c;
      }
      function Maj(a, b, c) {
        return a & b ^ a & c ^ b & c;
      }
      var HashMD = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data7) {
          (0, _assert_js_1.aexists)(this);
          const { view, buffer, blockLen } = this;
          data7 = (0, utils_js_1.toBytes)(data7);
          const len = data7.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data7);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data7.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data7.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.aexists)(this);
          (0, _assert_js_1.aoutput)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports2.HashMD = HashMD;
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js
  var require_u647 = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = void 0;
      exports2.fromBig = fromBig;
      exports2.split = split7;
      exports2.add = add;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      function split7(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports2.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports2.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports2.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports2.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports2.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports2.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports2.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports2.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports2.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports2.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports2.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports2.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports2.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports2.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports2.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports2.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports2.add5H = add5H;
      var u64 = {
        fromBig,
        split: split7,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js
  var require_sha5127 = __commonJS({
    "node_modules/@noble/curves/node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA384 = exports2.SHA512_256 = exports2.SHA512_224 = exports2.SHA512 = void 0;
      var _md_js_1 = require_md();
      var _u64_js_1 = require_u647();
      var utils_js_1 = require_utils28();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _md_js_1.HashMD {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      exports2.SHA512_224 = SHA512_224;
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      exports2.SHA512_256 = SHA512_256;
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.SHA384 = SHA384;
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/@noble/curves/abstract/utils.js
  var require_utils29 = __commonJS({
    "node_modules/@noble/curves/abstract/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.notImplemented = exports2.bitMask = void 0;
      exports2.isBytes = isBytes;
      exports2.abytes = abytes;
      exports2.abool = abool;
      exports2.bytesToHex = bytesToHex;
      exports2.numberToHexUnpadded = numberToHexUnpadded;
      exports2.hexToNumber = hexToNumber;
      exports2.hexToBytes = hexToBytes;
      exports2.bytesToNumberBE = bytesToNumberBE;
      exports2.bytesToNumberLE = bytesToNumberLE;
      exports2.numberToBytesBE = numberToBytesBE;
      exports2.numberToBytesLE = numberToBytesLE;
      exports2.numberToVarBytesBE = numberToVarBytesBE;
      exports2.ensureBytes = ensureBytes;
      exports2.concatBytes = concatBytes;
      exports2.equalBytes = equalBytes;
      exports2.utf8ToBytes = utf8ToBytes3;
      exports2.inRange = inRange;
      exports2.aInRange = aInRange;
      exports2.bitLen = bitLen;
      exports2.bitGet = bitGet;
      exports2.bitSet = bitSet;
      exports2.createHmacDrbg = createHmacDrbg;
      exports2.validateObject = validateObject;
      exports2.memoized = memoized;
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function abytes(item) {
        if (!isBytes(item))
          throw new Error("Uint8Array expected");
      }
      function abool(title3, value) {
        if (typeof value !== "boolean")
          throw new Error(title3 + " boolean expected, got " + value);
      }
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        abytes(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? "0" + hex : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return hex === "" ? _0n : BigInt("0x" + hex);
      }
      var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      function bytesToNumberLE(bytes) {
        abytes(bytes);
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      function ensureBytes(title3, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(title3 + " must be hex string or Uint8Array, cause: " + e);
          }
        } else if (isBytes(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(title3 + " must be hex string or Uint8Array");
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(title3 + " of length " + expectedLength + " expected, got " + len);
        return res;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      function equalBytes(a, b) {
        if (a.length !== b.length)
          return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
        return diff === 0;
      }
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str));
      }
      var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
      function inRange(n, min7, max7) {
        return isPosBig(n) && isPosBig(min7) && isPosBig(max7) && min7 <= n && n < max7;
      }
      function aInRange(title3, n, min7, max7) {
        if (!inRange(n, min7, max7))
          throw new Error("expected valid " + title3 + ": " + min7 + " <= n < " + max7 + ", got " + n);
      }
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      function bitSet(n, pos, value) {
        return n | (value ? _1n : _0n) << BigInt(pos);
      }
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports2.bitMask = bitMask;
      var u8n = (data7) => new Uint8Array(data7);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl2 = v.slice();
            out.push(sl2);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error("invalid validator function");
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      var notImplemented = () => {
        throw new Error("not implemented");
      };
      exports2.notImplemented = notImplemented;
      function memoized(fn) {
        const map3 = /* @__PURE__ */ new WeakMap();
        return (arg, ...args) => {
          const val = map3.get(arg);
          if (val !== void 0)
            return val;
          const computed = fn(arg, ...args);
          map3.set(arg, computed);
          return computed;
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/modular.js
  var require_modular7 = __commonJS({
    "node_modules/@noble/curves/abstract/modular.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isNegativeLE = void 0;
      exports2.mod = mod;
      exports2.pow = pow3;
      exports2.pow2 = pow22;
      exports2.invert = invert;
      exports2.tonelliShanks = tonelliShanks;
      exports2.FpSqrt = FpSqrt;
      exports2.validateField = validateField;
      exports2.FpPow = FpPow;
      exports2.FpInvertBatch = FpInvertBatch;
      exports2.FpDiv = FpDiv;
      exports2.FpLegendre = FpLegendre;
      exports2.FpIsSquare = FpIsSquare;
      exports2.nLength = nLength;
      exports2.Field = Field;
      exports2.FpSqrtOdd = FpSqrtOdd;
      exports2.FpSqrtEven = FpSqrtEven;
      exports2.hashToPrivateScalar = hashToPrivateScalar;
      exports2.getFieldBytesLength = getFieldBytesLength;
      exports2.getMinHashLength = getMinHashLength;
      exports2.mapHashToField = mapHashToField;
      var utils_js_1 = require_utils29();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      var _3n = /* @__PURE__ */ BigInt(3);
      var _4n = /* @__PURE__ */ BigInt(4);
      var _5n = /* @__PURE__ */ BigInt(5);
      var _8n = /* @__PURE__ */ BigInt(8);
      var _9n = /* @__PURE__ */ BigInt(9);
      var _16n = /* @__PURE__ */ BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      function pow3(num, power, modulo) {
        if (power < _0n)
          throw new Error("invalid exponent, negatives unsupported");
        if (modulo <= _0n)
          throw new Error("invalid modulus");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n;
        }
        return res;
      }
      function pow22(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      function invert(number, modulo) {
        if (number === _0n)
          throw new Error("invert: expected non-zero number");
        if (modulo <= _0n)
          throw new Error("invert: expected positive modulus, got " + modulo);
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow3(Z, legendreC, P) !== P - _1n; Z++) {
          if (Z > 1e3)
            throw new Error("Cannot find square root: likely non-prime P");
        }
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root3 = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root3 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root3), n))
              throw new Error("Cannot find square root");
            return root3;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports2.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map3, val) => {
          map3[val] = "function";
          return map3;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      function FpPow(f, num, power) {
        if (power < _0n)
          throw new Error("invalid exponent, negatives unsupported");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      function FpLegendre(order) {
        const legendreConst = (order - _1n) / _2n;
        return (f, x) => f.pow(x, legendreConst);
      }
      function FpIsSquare(f) {
        const legendre = FpLegendre(f.ORDER);
        return (x) => {
          const p = legendre(f, x);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("invalid field: expected ORDER of <= 2048 bytes");
        let sqrtP;
        const f = Object.freeze({
          ORDER,
          isLE,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error("invalid field element: expected bigint, got " + typeof num);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => {
            if (!sqrtP)
              sqrtP = FpSqrt(ORDER);
            return sqrtP(f, n);
          }),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? root3 : Fp.neg(root3);
      }
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root3 = Fp.sqrt(elm);
        return Fp.isOdd(root3) ? Fp.neg(root3) : root3;
      }
      function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
        const num = isLE ? (0, utils_js_1.bytesToNumberLE)(key) : (0, utils_js_1.bytesToNumberBE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
    }
  });

  // node_modules/@noble/curves/abstract/curve.js
  var require_curve7 = __commonJS({
    "node_modules/@noble/curves/abstract/curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wNAF = wNAF;
      exports2.pippenger = pippenger;
      exports2.precomputeMSMUnsafe = precomputeMSMUnsafe;
      exports2.validateBasic = validateBasic;
      var modular_js_1 = require_modular7();
      var utils_js_1 = require_utils29();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function constTimeNegate(condition, item) {
        const neg = item.negate();
        return condition ? neg : item;
      }
      function validateW(W, bits) {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
          throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
      }
      function calcWOpts(W, bits) {
        validateW(W, bits);
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      }
      function validateMSMPoints(points, c) {
        if (!Array.isArray(points))
          throw new Error("array expected");
        points.forEach((p, i) => {
          if (!(p instanceof c))
            throw new Error("invalid point at index " + i);
        });
      }
      function validateMSMScalars(scalars, field) {
        if (!Array.isArray(scalars))
          throw new Error("array of scalars expected");
        scalars.forEach((s, i) => {
          if (!field.isValid(s))
            throw new Error("invalid scalar at index " + i);
        });
      }
      var pointPrecomputes = /* @__PURE__ */ new WeakMap();
      var pointWindowSizes = /* @__PURE__ */ new WeakMap();
      function getW(P) {
        return pointWindowSizes.get(P) || 1;
      }
      function wNAF(c, bits) {
        return {
          constTimeNegate,
          hasPrecomputes(elm) {
            return getW(elm) !== 1;
          },
          // non-const time multiplication ladder
          unsafeLadder(elm, n, p = c.ZERO) {
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @param elm Point instance
           * @param W window size
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = calcWOpts(W, bits);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = calcWOpts(W, bits);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          /**
           * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @param acc accumulator point to add result of multiplication
           * @returns point
           */
          wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
            const { windows, windowSize } = calcWOpts(W, bits);
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              if (n === _0n)
                break;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              if (wbits === 0)
                continue;
              let curr = precomputes[offset + Math.abs(wbits) - 1];
              if (wbits < 0)
                curr = curr.negate();
              acc = acc.add(curr);
            }
            return acc;
          },
          getPrecomputes(W, P, transform) {
            let comp = pointPrecomputes.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1)
                pointPrecomputes.set(P, transform(comp));
            }
            return comp;
          },
          wNAFCached(P, n, transform) {
            const W = getW(P);
            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
          },
          wNAFCachedUnsafe(P, n, transform, prev) {
            const W = getW(P);
            if (W === 1)
              return this.unsafeLadder(P, n, prev);
            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
          },
          // We calculate precomputes for elliptic curve point multiplication
          // using windowed method. This specifies window size and
          // stores precomputed values. Usually only base point would be precomputed.
          setWindowSize(P, W) {
            validateW(W, bits);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
          }
        };
      }
      function pippenger(c, fieldN, points, scalars) {
        validateMSMPoints(points, c);
        validateMSMScalars(scalars, fieldN);
        if (points.length !== scalars.length)
          throw new Error("arrays of points and scalars must have equal length");
        const zero = c.ZERO;
        const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));
        const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
        const MASK = (1 << windowSize) - 1;
        const buckets = new Array(MASK + 1).fill(zero);
        const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
        let sum = zero;
        for (let i = lastBits; i >= 0; i -= windowSize) {
          buckets.fill(zero);
          for (let j = 0; j < scalars.length; j++) {
            const scalar = scalars[j];
            const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
            buckets[wbits2] = buckets[wbits2].add(points[j]);
          }
          let resI = zero;
          for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
          }
          sum = sum.add(resI);
          if (i !== 0)
            for (let j = 0; j < windowSize; j++)
              sum = sum.double();
        }
        return sum;
      }
      function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
        validateW(windowSize, fieldN.BITS);
        validateMSMPoints(points, c);
        const zero = c.ZERO;
        const tableSize = 2 ** windowSize - 1;
        const chunks = Math.ceil(fieldN.BITS / windowSize);
        const MASK = BigInt((1 << windowSize) - 1);
        const tables = points.map((p) => {
          const res = [];
          for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
          }
          return res;
        });
        return (scalars) => {
          validateMSMScalars(scalars, fieldN);
          if (scalars.length > points.length)
            throw new Error("array of scalars must be smaller than array of points");
          let res = zero;
          for (let i = 0; i < chunks; i++) {
            if (res !== zero)
              for (let j = 0; j < windowSize; j++)
                res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
              const n = scalars[j];
              const curr = Number(n >> shiftBy & MASK);
              if (!curr)
                continue;
              res = res.add(tables[j][curr - 1]);
            }
          }
          return res;
        };
      }
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
    }
  });

  // node_modules/@noble/curves/abstract/edwards.js
  var require_edwards7 = __commonJS({
    "node_modules/@noble/curves/abstract/edwards.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.twistedEdwards = twistedEdwards;
      var curve_js_1 = require_curve7();
      var modular_js_1 = require_modular7();
      var ut = require_utils29();
      var utils_js_1 = require_utils29();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      var VERIFY_DEFAULT = { zip215: true };
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n << BigInt(nByteLength * 8) - _1n;
        const modP = Fp.create;
        const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);
        const uvRatio = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const domain2 = CURVE.domain || ((data7, ctx, phflag) => {
          (0, utils_js_1.abool)("phflag", phflag);
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data7;
        });
        function aCoordinate(title3, n) {
          ut.aInRange("coordinate " + title3, n, _0n, MASK);
        }
        function assertPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
          const { ex: x, ey: y, ez: z } = p;
          const is0 = p.is0();
          if (iz == null)
            iz = is0 ? _8n : Fp.inv(z);
          const ax = modP(x * iz);
          const ay = modP(y * iz);
          const zz = modP(z * iz);
          if (is0)
            return { x: _0n, y: _1n };
          if (zz !== _1n)
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        });
        const assertValidMemo = (0, utils_js_1.memoized)((p) => {
          const { a, d } = CURVE;
          if (p.is0())
            throw new Error("bad point: ZERO");
          const { ex: X, ey: Y, ez: Z, et: T } = p;
          const X2 = modP(X * X);
          const Y2 = modP(Y * Y);
          const Z2 = modP(Z * Z);
          const Z4 = modP(Z2 * Z2);
          const aX2 = modP(X2 * a);
          const left = modP(Z2 * modP(aX2 + Y2));
          const right = modP(Z4 + modP(d * modP(X2 * Y2)));
          if (left !== right)
            throw new Error("bad point: equation left != right (1)");
          const XY = modP(X * Y);
          const ZT = modP(Z * T);
          if (XY !== ZT)
            throw new Error("bad point: equation left != right (2)");
          return true;
        });
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            aCoordinate("x", ex);
            aCoordinate("y", ey);
            aCoordinate("z", ez);
            aCoordinate("t", et);
            Object.freeze(this);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            aCoordinate("x", x);
            aCoordinate("y", y);
            return new Point(x, y, _1n, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // Multiscalar Multiplication
          static msm(points, scalars) {
            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            assertValidMemo(this);
          }
          // Compare one point to another.
          equals(other) {
            assertPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            assertPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n)
                return this.double();
              const C2 = modP(Z1 * _2n * T2);
              const D2 = modP(T1 * _2n * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const n = scalar;
            ut.aInRange("scalar", n, _1n, CURVE_ORDER);
            const { p, f } = this.wNAF(n);
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          // Accepts optional accumulator to merge with multiply (important for sparse scalars)
          multiplyUnsafe(scalar, acc = Point.ZERO) {
            const n = scalar;
            ut.aInRange("scalar", n, _0n, CURVE_ORDER);
            if (n === _0n)
              return I;
            if (this.is0() || n === _1n)
              return this;
            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            return toAffineMemo(this, iz);
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            (0, utils_js_1.abool)("zip215", zip215);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            const max7 = zip215 ? MASK : Fp.ORDER;
            ut.aInRange("pointHex.y", y, _0n, max7);
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = Fp.BYTES;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head5 = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head5);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head: head5, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain2(msg, (0, utils_js_1.ensureBytes)("context", context2), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          ut.aInRange("signature.s", s, _0n, CURVE_ORDER);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, Fp.BYTES * 2);
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context: context2, zip215 } = options;
          const len = Fp.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey, len);
          if (zip215 !== void 0)
            (0, utils_js_1.abool)("zip215", zip215);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error2) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context2, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils5 = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes(Fp.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils: utils5
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve7 = __commonJS({
    "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.expand_message_xmd = expand_message_xmd;
      exports2.expand_message_xof = expand_message_xof;
      exports2.hash_to_field = hash_to_field;
      exports2.isogenyMap = isogenyMap;
      exports2.createHasher = createHasher;
      var modular_js_1 = require_modular7();
      var utils_js_1 = require_utils29();
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        anum(value);
        anum(length);
        if (value < 0 || value >= 1 << 8 * length)
          throw new Error("invalid I2OSP input: " + value);
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function anum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        (0, utils_js_1.abytes)(msg);
        (0, utils_js_1.abytes)(DST);
        anum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (lenInBytes > 65535 || ell > 255)
          throw new Error("expand_message_xmd: invalid lenInBytes");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        (0, utils_js_1.abytes)(msg);
        (0, utils_js_1.abytes)(DST);
        anum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        (0, utils_js_1.abytes)(msg);
        anum(count);
        const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      function isogenyMap(field, map3) {
        const COEFF = map3.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Same as encodeToCurve, but without hash
          mapToCurve(scalars) {
            if (!Array.isArray(scalars))
              throw new Error("mapToCurve: expected array of bigints");
            for (const i of scalars)
              if (typeof i !== "bigint")
                throw new Error("mapToCurve: expected array of bigints");
            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery7 = __commonJS({
    "node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.montgomery = montgomery;
      var modular_js_1 = require_modular7();
      var utils_js_1 = require_utils29();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function validateOpts(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap3, x_2, x_3) {
          const dummy = modP(swap3 * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(u, scalar) {
          (0, utils_js_1.aInRange)("u", u, _0n, P);
          (0, utils_js_1.aInRange)("scalar", scalar, _0n, P);
          const k = scalar;
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap3 = _0n;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap3 ^= k_t;
            sw = cswap(swap3, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap3, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap3 = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap3, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap3, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === 32)
            u[31] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
          const len = bytes.length;
          if (len !== montgomeryBytes && len !== fieldLen) {
            let valid = "" + montgomeryBytes + " or " + fieldLen;
            throw new Error("invalid scalar, expected " + valid + " bytes, got " + len);
          }
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n)
            throw new Error("invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
    }
  });

  // node_modules/@noble/curves/ed25519.js
  var require_ed255197 = __commonJS({
    "node_modules/@noble/curves/ed25519.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255 = exports2.RistrettoPoint = exports2.encodeToCurve = exports2.hashToCurve = exports2.edwardsToMontgomery = exports2.x25519 = exports2.ed25519ph = exports2.ed25519ctx = exports2.ed25519 = exports2.ED25519_TORSION_SUBGROUP = void 0;
      exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var sha512_1 = require_sha5127();
      var utils_1 = require_utils28();
      var curve_js_1 = require_curve7();
      var edwards_js_1 = require_edwards7();
      var hash_to_curve_js_1 = require_hash_to_curve7();
      var modular_js_1 = require_modular7();
      var montgomery_js_1 = require_montgomery7();
      var utils_js_1 = require_utils29();
      var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      function ed25519_pow_2_252_3(x) {
        const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
        const P = ED25519_P;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow3, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root22 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root22;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports2.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp = /* @__PURE__ */ (() => (0, modular_js_1.Field)(ED25519_P, void 0, true))();
      var ed25519Defaults = /* @__PURE__ */ (() => ({
        // Param: a
        a: BigInt(-1),
        // Fp.create(-1) is proper; our way still works and is faster
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: _8n,
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      }))();
      exports2.ed25519 = (() => (0, edwards_js_1.twistedEdwards)(ed25519Defaults))();
      function ed25519_domain(data7, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data7);
      }
      exports2.ed25519ctx = (() => (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      }))();
      exports2.ed25519ph = (() => (0, edwards_js_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
        domain: ed25519_domain,
        prehash: sha512_1.sha512
      })))();
      exports2.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        // n is 253 bits
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports2.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n2 = BigInt(1);
        return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
      }
      exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
      }
      var ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)();
      var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
      var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
      function map_to_curve_elligator2_curve25519(u) {
        const ELL2_C4 = (Fp.ORDER - _5n) / _8n;
        const ELL2_J = BigInt(486662);
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const inv = Fp.invertBatch([xd, yd]);
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports2.hashToCurve = (() => htf.hashToCurve)();
      exports2.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio(_1n, number);
      var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports2.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports2.ed25519.CURVE;
        const P = exports2.ed25519.CURVE.Fp.ORDER;
        const mod = exports2.ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports2.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports2.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports2.ed25519.CURVE;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
          return new _RistPoint(new exports2.ed25519.ExtendedPoint(x, y, _1n, t));
        }
        static msm(points, scalars) {
          const Fn = (0, modular_js_1.Field)(exports2.ed25519.CURVE.n, exports2.ed25519.CURVE.nBitLength);
          return (0, curve_js_1.pippenger)(_RistPoint, Fn, points, scalars);
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports2.ed25519.CURVE.Fp.ORDER;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const u1 = mod(mod(z + y) * mod(z - y));
          const u2 = mod(x * y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y);
          let s = mod((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod = exports2.ed25519.CURVE.Fp.create;
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
        double() {
          return new _RistPoint(this.ep.double());
        }
        negate() {
          return new _RistPoint(this.ep.negate());
        }
      };
      exports2.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports2.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports2.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports2.hashToRistretto255 = hashToRistretto255;
      exports2.hash_to_ristretto255 = exports2.hashToRistretto255;
    }
  });

  // node_modules/@noble/hashes/crypto.js
  var require_crypto13 = __commonJS({
    "node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/utils.js
  var require_utils30 = __commonJS({
    "node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
      exports2.isBytes = isBytes;
      exports2.anumber = anumber;
      exports2.abytes = abytes;
      exports2.ahash = ahash;
      exports2.aexists = aexists;
      exports2.aoutput = aoutput;
      exports2.u8 = u8;
      exports2.u32 = u32;
      exports2.clean = clean;
      exports2.createView = createView;
      exports2.rotr = rotr;
      exports2.rotl = rotl;
      exports2.byteSwap = byteSwap;
      exports2.byteSwap32 = byteSwap32;
      exports2.bytesToHex = bytesToHex;
      exports2.hexToBytes = hexToBytes;
      exports2.asyncLoop = asyncLoop;
      exports2.utf8ToBytes = utf8ToBytes3;
      exports2.bytesToUtf8 = bytesToUtf8;
      exports2.toBytes = toBytes;
      exports2.kdfInputToBytes = kdfInputToBytes;
      exports2.concatBytes = concatBytes;
      exports2.checkOpts = checkOpts;
      exports2.createHasher = createHasher;
      exports2.createOptHasher = createOptHasher;
      exports2.createXOFer = createXOFer;
      exports2.randomBytes = randomBytes;
      var crypto_1 = require_crypto13();
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function anumber(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error("positive integer expected, got " + n);
      }
      function abytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }
      function ahash(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.createHasher");
        anumber(h.outputLen);
        anumber(h.blockLen);
      }
      function aexists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function aoutput(out, instance) {
        abytes(out);
        const min7 = instance.outputLen;
        if (out.length < min7) {
          throw new Error("digestInto() expects output buffer of length at least " + min7);
        }
      }
      function u8(arr) {
        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function u32(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      }
      function clean(...arrays) {
        for (let i = 0; i < arrays.length; i++) {
          arrays[i].fill(0);
        }
      }
      function createView(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function rotr(word, shift) {
        return word << 32 - shift | word >>> shift;
      }
      function rotl(word, shift) {
        return word << shift | word >>> 32 - shift >>> 0;
      }
      exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      function byteSwap(word) {
        return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      }
      exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap(n);
      exports2.byteSwapIfBE = exports2.swap8IfBE;
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = byteSwap(arr[i]);
        }
        return arr;
      }
      exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap32;
      var hasHexBuiltin = /* @__PURE__ */ (() => (
        // @ts-ignore
        typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
      ))();
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        abytes(bytes);
        if (hasHexBuiltin)
          return bytes.toHex();
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        if (hasHexBuiltin)
          return Uint8Array.fromHex(hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi2));
          const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi2] + hex[hi2 + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      var nextTick3 = async () => {
      };
      exports2.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function bytesToUtf8(bytes) {
        return new TextDecoder().decode(bytes);
      }
      function toBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        abytes(data7);
        return data7;
      }
      function kdfInputToBytes(data7) {
        if (typeof data7 === "string")
          data7 = utf8ToBytes3(data7);
        abytes(data7);
        return data7;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad2 = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad2);
          pad2 += a.length;
        }
        return res;
      }
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
          throw new Error("options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      var Hash = class {
      };
      exports2.Hash = Hash;
      function createHasher(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function createOptHasher(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function createXOFer(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructor = createHasher;
      exports2.wrapConstructorWithOpts = createOptHasher;
      exports2.wrapXOFConstructorWithOpts = createXOFer;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // node_modules/secp256k1/lib/index.js
  var require_lib32 = __commonJS({
    "node_modules/secp256k1/lib/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var errors2 = {
        IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
        TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
        TWEAK_MUL: "The tweak was out of range or equal to zero",
        CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
        SECKEY_INVALID: "Private Key is invalid",
        PUBKEY_PARSE: "Public Key could not be parsed",
        PUBKEY_SERIALIZE: "Public Key serialization error",
        PUBKEY_COMBINE: "The sum of the public keys is not valid",
        SIG_PARSE: "Signature could not be parsed",
        SIGN: "The nonce generation function failed, or the private key was invalid",
        RECOVER: "Public key could not be recover",
        ECDH: "Scalar was invalid (zero or overflow)"
      };
      function assert(cond, msg) {
        if (!cond) throw new Error(msg);
      }
      function isUint8Array(name, value, length) {
        assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
        if (length !== void 0) {
          if (Array.isArray(length)) {
            const numbers = length.join(", ");
            const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
            assert(length.includes(value.length), msg);
          } else {
            const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
            assert(value.length === length, msg);
          }
        }
      }
      function isCompressed(value) {
        assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
      }
      function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
        if (typeof output === "function") output = output(length);
        isUint8Array("output", output, length);
        return output;
      }
      function toTypeString(value) {
        return Object.prototype.toString.call(value).slice(8, -1);
      }
      module2.exports = (secp256k1) => {
        return {
          contextRandomize(seed) {
            assert(
              seed === null || seed instanceof Uint8Array,
              "Expected seed to be an Uint8Array or null"
            );
            if (seed !== null) isUint8Array("seed", seed, 32);
            switch (secp256k1.contextRandomize(seed)) {
              case 1:
                throw new Error(errors2.CONTEXT_RANDOMIZE_UNKNOW);
            }
          },
          privateKeyVerify(seckey) {
            isUint8Array("private key", seckey, 32);
            return secp256k1.privateKeyVerify(seckey) === 0;
          },
          privateKeyNegate(seckey) {
            isUint8Array("private key", seckey, 32);
            switch (secp256k1.privateKeyNegate(seckey)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors2.IMPOSSIBLE_CASE);
            }
          },
          privateKeyTweakAdd(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors2.TWEAK_ADD);
            }
          },
          privateKeyTweakMul(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors2.TWEAK_MUL);
            }
          },
          publicKeyVerify(pubkey) {
            isUint8Array("public key", pubkey, [33, 65]);
            return secp256k1.publicKeyVerify(pubkey) === 0;
          },
          publicKeyCreate(seckey, compressed = true, output) {
            isUint8Array("private key", seckey, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyCreate(output, seckey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.SECKEY_INVALID);
              case 2:
                throw new Error(errors2.PUBKEY_SERIALIZE);
            }
          },
          publicKeyConvert(pubkey, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyConvert(output, pubkey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.PUBKEY_SERIALIZE);
            }
          },
          publicKeyNegate(pubkey, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyNegate(output, pubkey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.IMPOSSIBLE_CASE);
              case 3:
                throw new Error(errors2.PUBKEY_SERIALIZE);
            }
          },
          publicKeyCombine(pubkeys, compressed = true, output) {
            assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
            assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
            for (const pubkey of pubkeys) {
              isUint8Array("public key", pubkey, [33, 65]);
            }
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyCombine(output, pubkeys)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.PUBKEY_COMBINE);
              case 3:
                throw new Error(errors2.PUBKEY_SERIALIZE);
            }
          },
          publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.TWEAK_ADD);
            }
          },
          publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.TWEAK_MUL);
            }
          },
          signatureNormalize(sig) {
            isUint8Array("signature", sig, 64);
            switch (secp256k1.signatureNormalize(sig)) {
              case 0:
                return sig;
              case 1:
                throw new Error(errors2.SIG_PARSE);
            }
          },
          signatureExport(sig, output) {
            isUint8Array("signature", sig, 64);
            output = getAssertedOutput(output, 72);
            const obj = { output, outputlen: 72 };
            switch (secp256k1.signatureExport(obj, sig)) {
              case 0:
                return output.slice(0, obj.outputlen);
              case 1:
                throw new Error(errors2.SIG_PARSE);
              case 2:
                throw new Error(errors2.IMPOSSIBLE_CASE);
            }
          },
          signatureImport(sig, output) {
            isUint8Array("signature", sig);
            output = getAssertedOutput(output, 64);
            switch (secp256k1.signatureImport(output, sig)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.SIG_PARSE);
              case 2:
                throw new Error(errors2.IMPOSSIBLE_CASE);
            }
          },
          ecdsaSign(msg32, seckey, options = {}, output) {
            isUint8Array("message", msg32, 32);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0) isUint8Array("options.data", options.data);
            if (options.noncefn !== void 0) assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
            output = getAssertedOutput(output, 64);
            const obj = { signature: output, recid: null };
            switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
              case 0:
                return obj;
              case 1:
                throw new Error(errors2.SIGN);
              case 2:
                throw new Error(errors2.IMPOSSIBLE_CASE);
            }
          },
          ecdsaVerify(sig, msg32, pubkey) {
            isUint8Array("signature", sig, 64);
            isUint8Array("message", msg32, 32);
            isUint8Array("public key", pubkey, [33, 65]);
            switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
              case 0:
                return true;
              case 3:
                return false;
              case 1:
                throw new Error(errors2.SIG_PARSE);
              case 2:
                throw new Error(errors2.PUBKEY_PARSE);
            }
          },
          ecdsaRecover(sig, recid, msg32, compressed = true, output) {
            isUint8Array("signature", sig, 64);
            assert(
              toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
              "Expected recovery id to be a Number within interval [0, 3]"
            );
            isUint8Array("message", msg32, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.SIG_PARSE);
              case 2:
                throw new Error(errors2.RECOVER);
              case 3:
                throw new Error(errors2.IMPOSSIBLE_CASE);
            }
          },
          ecdh(pubkey, seckey, options = {}, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0) isUint8Array("options.data", options.data);
            if (options.hashfn !== void 0) {
              assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
              if (options.xbuf !== void 0) isUint8Array("options.xbuf", options.xbuf, 32);
              if (options.ybuf !== void 0) isUint8Array("options.ybuf", options.ybuf, 32);
              isUint8Array("output", output);
            } else {
              output = getAssertedOutput(output, 32);
            }
            switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors2.PUBKEY_PARSE);
              case 2:
                throw new Error(errors2.ECDH);
            }
          }
        };
      };
    }
  });

  // node_modules/elliptic/package.json
  var require_package = __commonJS({
    "node_modules/elliptic/package.json"(exports2, module2) {
      module2.exports = {
        name: "elliptic",
        version: "6.6.1",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // node_modules/elliptic/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function(module3, exports3) {
        "use strict";
        function assert(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base3, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base3 === "le" || base3 === "be") {
              endian = base3;
              base3 = 10;
            }
            this._init(number || 0, base3 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max7(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN.min = function min7(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN.prototype._init = function init3(number, base3, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base3, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base3, endian);
          }
          if (base3 === "hex") {
            base3 = 16;
          }
          assert(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base3 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base3, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base3, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base3, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base3, endian);
        };
        BN.prototype._initArray = function _initArray(number, base3, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off3 = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off3 & 67108863;
              this.words[j + 1] = w >>> 26 - off3 & 67108863;
              off3 += 24;
              if (off3 >= 26) {
                off3 -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off3 & 67108863;
              this.words[j + 1] = w >>> 26 - off3 & 67108863;
              off3 += 24;
              if (off3 >= 26) {
                off3 -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off3 = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off3;
              this.words[j] |= w & 67108863;
              if (off3 >= 18) {
                off3 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off3 += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off3;
              this.words[j] |= w & 67108863;
              if (off3 >= 18) {
                off3 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off3 += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base3, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base3 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base3);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow3 = 1;
            word = parseBase(number, i, number.length, base3);
            for (i = 0; i < mod; i++) {
              pow3 *= base3;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy4(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect3() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString18(base3, padding) {
          base3 = base3 || 10;
          padding = padding | 0 || 1;
          var out;
          if (base3 === 16 || base3 === "hex") {
            out = "";
            var off3 = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off3 | carry) & 16777215).toString(16);
              carry = w >>> 24 - off3 & 16777215;
              off3 += 2;
              if (off3 >= 26) {
                off3 -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
            var groupSize = groupSizes[base3];
            var groupBase = groupBases[base3];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base3);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON5() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer3 !== "undefined");
          return this.toArrayLike(Buffer3, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength3 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength3);
          assert(byteLength3 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength3; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi2 = this._countBits(w);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off3 = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength3() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off3 + 1);
          if (val) {
            this.words[off3] = this.words[off3] | 1 << wbit;
          } else {
            this.words[off3] = this.words[off3] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          this.length = num === 0 ? 1 : this.length;
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow3(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs2() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split7(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split7(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next3 = input.words[i] | 0;
            input.words[i - 10] = (next3 & mask) << 4 | prev >>> 22;
            prev = next3;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi2 = (num.words[i] | 0) * 19 + carry;
            var lo = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i] = lo;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow3);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a, num) {
          if (num.isZero()) return new BN(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports2);
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }
  });

  // node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils31 = __commonJS({
    "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi2 = c >> 8;
            var lo = c & 255;
            if (hi2)
              res.push(hi2, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils5.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils5.zero2 = zero2;
      function toHex3(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils5.toHex = toHex3;
      utils5.encode = function encode3(arr, enc) {
        if (enc === "hex")
          return toHex3(arr);
        else
          return arr;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/utils.js
  var require_utils32 = __commonJS({
    "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = exports2;
      var BN = require_bn2();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils31();
      utils5.assert = minAssert;
      utils5.toArray = minUtils.toArray;
      utils5.zero2 = minUtils.zero2;
      utils5.toHex = minUtils.toHex;
      utils5.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        var i;
        for (i = 0; i < naf.length; i += 1) {
          naf[i] = 0;
        }
        var ws = 1 << w + 1;
        var k = num.clone();
        for (i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils5.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils5.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils5.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils5.toArray(bytes, "hex") : bytes;
      }
      utils5.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils5.intFromLE = intFromLE;
    }
  });

  // node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "node_modules/brorand/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var r;
      module2.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto2 = require_crypto9();
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
      var crypto2;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var utils5 = require_utils32();
      var getNAF = utils5.getNAF;
      var getJSF = utils5.getJSF;
      var assert = utils5.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max7 = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max7 = Math.max(naf[a].length, max7);
            max7 = Math.max(naf[b].length, max7);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max7 = Math.max(jsf[0].length, max7);
          naf[a] = new Array(max7);
          naf[b] = new Array(max7);
          for (j = 0; j < max7; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max7; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils5.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(
            bytes.slice(1, 1 + len),
            bytes.slice(1 + len, 1 + 2 * len)
          );
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode3(enc, compact) {
        return utils5.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max7 = (1 << wnd) - 1;
        var dbl = max7 === 1 ? null : this.dbl();
        for (var i = 1; i < max7; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }
  });

  // node_modules/elliptic/node_modules/inherits/inherits_browser.js
  var require_inherits_browser2 = __commonJS({
    "node_modules/elliptic/node_modules/inherits/inherits_browser.js"(exports2, module2) {
      init_process();
      init_buffer();
      if (typeof Object.create === "function") {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils32();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser2();
      var Base = require_base();
      var assert = utils5.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits2(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b2 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split7 = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split7.k1.negative) {
            split7.k1.ineg();
            p = p.neg(true);
          }
          if (split7.k2.negative) {
            split7.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split7.k1;
          ncoeffs[i * 2 + 1] = split7.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits2(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON5() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect3() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits2(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow3) {
        if (pow3 === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow3)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow3; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow3; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow3)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect3() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser2();
      var Base = require_base();
      var utils5 = require_utils32();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits2(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits2(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils5.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect3() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize7() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards8 = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils32();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser2();
      var Base = require_base();
      var assert = utils5.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits2(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits2(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect3() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h = this.z.redSqr();
            j = f.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize7() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(
          this.x.redNeg(),
          this.y,
          this.z,
          this.t && this.t.redNeg()
        );
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve8 = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var curve = exports2;
      curve.base = require_base();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards8();
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils33 = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var assert = require_minimalistic_assert();
      var inherits2 = require_inherits_browser();
      exports2.inherits = inherits2;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports2.toArray = toArray;
      function toHex3(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports2.toHex = toHex3;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports2.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports2.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports2.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports2.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports2.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports2.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi2 = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi2 >>> 0;
        buf[pos + 1] = lo;
      }
      exports2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi2 = (lo < al ? 1 : 0) + ah + bh;
        return hi2 >>> 0;
      }
      exports2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi2 = ah + bh + ch + dh + carry;
        return hi2 >>> 0;
      }
      exports2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi2 = ah + bh + ch + dh + eh + carry;
        return hi2 >>> 0;
      }
      exports2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var assert = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils5.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils5.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad2() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var rotr32 = utils5.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports2.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports2.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports2.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports2.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports2.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports2.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports2.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports2.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils5.rotl32;
      var sum32 = utils5.sum32;
      var sum32_5 = utils5.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils5.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h, "big");
        else
          return utils5.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var common = require_common();
      var shaCommon = require_common2();
      var assert = require_minimalistic_assert();
      var sum32 = utils5.sum32;
      var sum32_4 = utils5.sum32_4;
      var sum32_5 = utils5.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils5.inherits(SHA256, BlockHash);
      module2.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h, "big");
        else
          return utils5.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var SHA256 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils5.inherits(SHA224, SHA256);
      module2.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h.slice(0, 7), "big");
        else
          return utils5.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var common = require_common();
      var assert = require_minimalistic_assert();
      var rotr64_hi = utils5.rotr64_hi;
      var rotr64_lo = utils5.rotr64_lo;
      var shr64_hi = utils5.shr64_hi;
      var shr64_lo = utils5.shr64_lo;
      var sum64 = utils5.sum64;
      var sum64_hi = utils5.sum64_hi;
      var sum64_lo = utils5.sum64_lo;
      var sum64_4_hi = utils5.sum64_4_hi;
      var sum64_4_lo = utils5.sum64_4_lo;
      var sum64_5_hi = utils5.sum64_5_hi;
      var sum64_5_lo = utils5.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils5.inherits(SHA512, BlockHash);
      module2.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W[i + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h, "big");
        else
          return utils5.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh2) {
        var r = xh & yh ^ ~xh & zh2;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh2, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh2) {
        var r = xh & yh ^ xh & zh2 ^ yh & zh2;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh2, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils5.inherits(SHA384, SHA512);
      module2.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h.slice(0, 12), "big");
        else
          return utils5.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      exports2.sha1 = require__();
      exports2.sha224 = require__3();
      exports2.sha256 = require__2();
      exports2.sha384 = require__5();
      exports2.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var common = require_common();
      var rotl32 = utils5.rotl32;
      var sum32 = utils5.sum32;
      var sum32_3 = utils5.sum32_3;
      var sum32_4 = utils5.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils5.inherits(RIPEMD160, BlockHash);
      exports2.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(
            rotl32(
              sum32_4(A, f(j, B, C, D), msg[r[j] + start], K2(j)),
              s[j]
            ),
            E
          );
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(
            rotl32(
              sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
              sh[j]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils5.toHex32(this.h, "little");
        else
          return utils5.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K2(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils33();
      var assert = require_minimalistic_assert();
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils5.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init3(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports2) {
      init_process();
      init_buffer();
      var hash = exports2;
      hash.utils = require_utils33();
      hash.common = require_common();
      hash.sha = require_sha();
      hash.ripemd = require_ripemd();
      hash.hmac = require_hmac();
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }
  });

  // node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var curves = exports2;
      var hash = require_hash();
      var curve = require_curve8();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var hash = require_hash();
      var utils5 = require_utils31();
      var assert = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils5.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils5.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils5.toArray(options.pers, options.persEnc || "hex");
        assert(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init3(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils5.toArray(entropy, entropyEnc);
        add = utils5.toArray(add, addEnc);
        assert(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils5.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils5.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature, options) {
        return this.ec.verify(msg, signature, this, void 0, options);
      };
      KeyPair.prototype.inspect = function inspect3() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature4 = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        if (buf[p.place] === 0) {
          return false;
        }
        var val = 0;
        for (var i = 0, off3 = p.place; i < octetLen; i++, off3++) {
          val <<= 8;
          val |= buf[off3];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off3;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data7, enc) {
        data7 = utils5.toArray(data7, enc);
        var p = new Position();
        if (data7[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data7, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data7.length) {
          return false;
        }
        if (data7[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data7, p);
        if (rlen === false) {
          return false;
        }
        if ((data7[p.place] & 128) !== 0) {
          return false;
        }
        var r = data7.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data7[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data7, p);
        if (slen === false) {
          return false;
        }
        if (data7.length !== slen + p.place) {
          return false;
        }
        if ((data7[p.place] & 128) !== 0) {
          return false;
        }
        var s = data7.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils5.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var HmacDRBG = require_hmac_drbg();
      var utils5 = require_utils32();
      var curves = require_curves();
      var rand = require_brorand();
      var assert = utils5.assert;
      var KeyPair = require_key();
      var Signature = require_signature4();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(
            Object.prototype.hasOwnProperty.call(curves, options),
            "Unknown curve " + options
          );
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
        var byteLength3;
        if (BN.isBN(msg) || typeof msg === "number") {
          msg = new BN(msg, 16);
          byteLength3 = msg.byteLength();
        } else if (typeof msg === "object") {
          byteLength3 = msg.length;
          msg = new BN(msg, 16);
        } else {
          var str = msg.toString();
          byteLength3 = str.length + 1 >>> 1;
          msg = new BN(str, 16);
        }
        if (typeof bitLength !== "number") {
          bitLength = byteLength3 * 8;
        }
        var delta = bitLength - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
          assert(
            typeof msg === "object" && msg && typeof msg.length === "number",
            "Expected message to be an array-like, a hex string, or a BN instance"
          );
          assert(msg.length >>> 0 === msg.length);
          for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
        }
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(msg, false, options.msgBitLength);
        assert(!msg.isNeg(), "Can not sign a negative message");
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        assert(new BN(nonce).eq(msg), "Can not sign message");
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc, options) {
        if (!options)
          options = {};
        msg = this._truncateToN(msg, false, options.msgBitLength);
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      var parseBytes = utils5.parseBytes;
      var cachedProperty = utils5.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils5.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils5.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature5 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var BN = require_bn2();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      var cachedProperty = utils5.cachedProperty;
      var parseBytes = utils5.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex3() {
        return utils5.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var hash = require_hash();
      var curves = require_curves();
      var utils5 = require_utils32();
      var assert = utils5.assert;
      var parseBytes = utils5.parseBytes;
      var KeyPair = require_key2();
      var Signature = require_signature5();
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
          return false;
        }
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash2.update(arguments[i]);
        return utils5.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils5.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils5.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils5.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "node_modules/elliptic/lib/elliptic.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var elliptic = exports2;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils32();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve8();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    }
  });

  // node_modules/secp256k1/lib/elliptic.js
  var require_elliptic2 = __commonJS({
    "node_modules/secp256k1/lib/elliptic.js"(exports2, module2) {
      init_process();
      init_buffer();
      var EC = require_elliptic().ec;
      var ec = new EC("secp256k1");
      var ecparams = ec.curve;
      var BN = ecparams.n.constructor;
      function loadCompressedPublicKey(first, xbuf) {
        let x = new BN(xbuf);
        if (x.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
        if (first === 3 !== y.isOdd()) y = y.redNeg();
        const x3 = x.redSqr().redIMul(x);
        if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
        return ec.keyPair({ pub: { x, y } });
      }
      function loadUncompressedPublicKey(first, xbuf, ybuf) {
        let x = new BN(xbuf);
        let y = new BN(ybuf);
        if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        y = y.toRed(ecparams.red);
        if ((first === 6 || first === 7) && y.isOdd() !== (first === 7)) return null;
        const x3 = x.redSqr().redIMul(x);
        if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
        return ec.keyPair({ pub: { x, y } });
      }
      function loadPublicKey(pubkey) {
        const first = pubkey[0];
        switch (first) {
          case 2:
          case 3:
            if (pubkey.length !== 33) return null;
            return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
          case 4:
          case 6:
          case 7:
            if (pubkey.length !== 65) return null;
            return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
          default:
            return null;
        }
      }
      function savePublicKey(output, point) {
        const pubkey = point.encode(null, output.length === 33);
        for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];
      }
      module2.exports = {
        contextRandomize() {
          return 0;
        },
        privateKeyVerify(seckey) {
          const bn = new BN(seckey);
          return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
        },
        privateKeyNegate(seckey) {
          const bn = new BN(seckey);
          const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
          seckey.set(negate);
          return 0;
        },
        privateKeyTweakAdd(seckey, tweak) {
          const bn = new BN(tweak);
          if (bn.cmp(ecparams.n) >= 0) return 1;
          bn.iadd(new BN(seckey));
          if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
          if (bn.isZero()) return 1;
          const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
          seckey.set(tweaked);
          return 0;
        },
        privateKeyTweakMul(seckey, tweak) {
          let bn = new BN(tweak);
          if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
          bn.imul(new BN(seckey));
          if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
          const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
          seckey.set(tweaked);
          return 0;
        },
        publicKeyVerify(pubkey) {
          const pair = loadPublicKey(pubkey);
          return pair === null ? 1 : 0;
        },
        publicKeyCreate(output, seckey) {
          const bn = new BN(seckey);
          if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
          const point = ec.keyFromPrivate(seckey).getPublic();
          savePublicKey(output, point);
          return 0;
        },
        publicKeyConvert(output, pubkey) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const point = pair.getPublic();
          savePublicKey(output, point);
          return 0;
        },
        publicKeyNegate(output, pubkey) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const point = pair.getPublic();
          point.y = point.y.redNeg();
          savePublicKey(output, point);
          return 0;
        },
        publicKeyCombine(output, pubkeys) {
          const pairs = new Array(pubkeys.length);
          for (let i = 0; i < pubkeys.length; ++i) {
            pairs[i] = loadPublicKey(pubkeys[i]);
            if (pairs[i] === null) return 1;
          }
          let point = pairs[0].getPublic();
          for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
          if (point.isInfinity()) return 2;
          savePublicKey(output, point);
          return 0;
        },
        publicKeyTweakAdd(output, pubkey, tweak) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          tweak = new BN(tweak);
          if (tweak.cmp(ecparams.n) >= 0) return 2;
          const point = pair.getPublic().add(ecparams.g.mul(tweak));
          if (point.isInfinity()) return 2;
          savePublicKey(output, point);
          return 0;
        },
        publicKeyTweakMul(output, pubkey, tweak) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          tweak = new BN(tweak);
          if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
          const point = pair.getPublic().mul(tweak);
          savePublicKey(output, point);
          return 0;
        },
        signatureNormalize(sig) {
          const r = new BN(sig.subarray(0, 32));
          const s = new BN(sig.subarray(32, 64));
          if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;
          if (s.cmp(ec.nh) === 1) {
            sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
          }
          return 0;
        },
        // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
        // Adapted for Uint8Array instead Buffer
        signatureExport(obj, sig) {
          const sigR = sig.subarray(0, 32);
          const sigS = sig.subarray(32, 64);
          if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
          if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
          const { output } = obj;
          let r = output.subarray(4, 4 + 33);
          r[0] = 0;
          r.set(sigR, 1);
          let lenR = 33;
          let posR = 0;
          for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR) ;
          r = r.subarray(posR);
          if (r[0] & 128) return 1;
          if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) return 1;
          let s = output.subarray(6 + 33, 6 + 33 + 33);
          s[0] = 0;
          s.set(sigS, 1);
          let lenS = 33;
          let posS = 0;
          for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS) ;
          s = s.subarray(posS);
          if (s[0] & 128) return 1;
          if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
          obj.outputlen = 6 + lenR + lenS;
          output[0] = 48;
          output[1] = obj.outputlen - 2;
          output[2] = 2;
          output[3] = r.length;
          output.set(r, 4);
          output[4 + lenR] = 2;
          output[5 + lenR] = s.length;
          output.set(s, 6 + lenR);
          return 0;
        },
        // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
        // Adapted for Uint8Array instead Buffer
        signatureImport(output, sig) {
          if (sig.length < 8) return 1;
          if (sig.length > 72) return 1;
          if (sig[0] !== 48) return 1;
          if (sig[1] !== sig.length - 2) return 1;
          if (sig[2] !== 2) return 1;
          const lenR = sig[3];
          if (lenR === 0) return 1;
          if (5 + lenR >= sig.length) return 1;
          if (sig[4 + lenR] !== 2) return 1;
          const lenS = sig[5 + lenR];
          if (lenS === 0) return 1;
          if (6 + lenR + lenS !== sig.length) return 1;
          if (sig[4] & 128) return 1;
          if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128)) return 1;
          if (sig[lenR + 6] & 128) return 1;
          if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128)) return 1;
          let sigR = sig.subarray(4, 4 + lenR);
          if (sigR.length === 33 && sigR[0] === 0) sigR = sigR.subarray(1);
          if (sigR.length > 32) return 1;
          let sigS = sig.subarray(6 + lenR);
          if (sigS.length === 33 && sigS[0] === 0) sigS = sigS.slice(1);
          if (sigS.length > 32) throw new Error("S length is too long");
          let r = new BN(sigR);
          if (r.cmp(ecparams.n) >= 0) r = new BN(0);
          let s = new BN(sig.subarray(6 + lenR));
          if (s.cmp(ecparams.n) >= 0) s = new BN(0);
          output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
          output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
          return 0;
        },
        ecdsaSign(obj, message, seckey, data7, noncefn) {
          if (noncefn) {
            const _noncefn = noncefn;
            noncefn = (counter5) => {
              const nonce = _noncefn(message, seckey, null, data7, counter5);
              const isValid = nonce instanceof Uint8Array && nonce.length === 32;
              if (!isValid) throw new Error("This is the way");
              return new BN(nonce);
            };
          }
          const d = new BN(seckey);
          if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
          let sig;
          try {
            sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data7 });
          } catch (err) {
            return 1;
          }
          obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
          obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
          obj.recid = sig.recoveryParam;
          return 0;
        },
        ecdsaVerify(sig, msg32, pubkey) {
          const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
          const sigr = new BN(sigObj.r);
          const sigs = new BN(sigObj.s);
          if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
          if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 2;
          const point = pair.getPublic();
          const isValid = ec.verify(msg32, sigObj, point);
          return isValid ? 0 : 3;
        },
        ecdsaRecover(output, sig, recid, msg32) {
          const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
          const sigr = new BN(sigObj.r);
          const sigs = new BN(sigObj.s);
          if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
          if (sigr.isZero() || sigs.isZero()) return 2;
          let point;
          try {
            point = ec.recoverPubKey(msg32, sigObj, recid);
          } catch (err) {
            return 2;
          }
          savePublicKey(output, point);
          return 0;
        },
        ecdh(output, pubkey, seckey, data7, hashfn, xbuf, ybuf) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const scalar = new BN(seckey);
          if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
          const point = pair.getPublic().mul(scalar);
          if (hashfn === void 0) {
            const data8 = point.encode(null, true);
            const sha2562 = ec.hash().update(data8).digest();
            for (let i = 0; i < 32; ++i) output[i] = sha2562[i];
          } else {
            if (!xbuf) xbuf = new Uint8Array(32);
            const x = point.getX().toArray("be", 32);
            for (let i = 0; i < 32; ++i) xbuf[i] = x[i];
            if (!ybuf) ybuf = new Uint8Array(32);
            const y = point.getY().toArray("be", 32);
            for (let i = 0; i < 32; ++i) ybuf[i] = y[i];
            const hash = hashfn(xbuf, ybuf, data7);
            const isValid = hash instanceof Uint8Array && hash.length === output.length;
            if (!isValid) return 2;
            output.set(hash);
          }
          return 0;
        }
      };
    }
  });

  // node_modules/secp256k1/elliptic.js
  var require_elliptic3 = __commonJS({
    "node_modules/secp256k1/elliptic.js"(exports2, module2) {
      init_process();
      init_buffer();
      module2.exports = require_lib32()(require_elliptic2());
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/public_key.cjs
  var require_public_key7 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/public_key.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _utils = require_commonjs2();
      var _ed25519 = require_ed255197();
      var _secp256k1 = require_elliptic3();
      var _secp256k12 = _interopRequireDefault(_secp256k1);
      var _constantscjs = require_constants14();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case _constantscjs.KeyType.ED25519:
            return "ed25519";
          case _constantscjs.KeyType.SECP256K1:
            return "secp256k1";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return _constantscjs.KeyType.ED25519;
          case "secp256k1":
            return _constantscjs.KeyType.SECP256K1;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function resolveEnumKeyName(keyType) {
        switch (keyType) {
          case _constantscjs.KeyType.ED25519: {
            return "ed25519Key";
          }
          case _constantscjs.KeyType.SECP256K1: {
            return "secp256k1Key";
          }
          default: {
            throw Error(`unknown type ${keyType}`);
          }
        }
      }
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      var PublicKey = class _PublicKey extends Enum {
        constructor(publicKey) {
          const keyName = resolveEnumKeyName(publicKey.keyType);
          super({ [keyName]: publicKey });
          this[keyName] = publicKey;
          this.enum = keyName;
        }
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = _utils.baseDecode.call(void 0, publicKey);
          if (!keyType) {
            keyType = decodedPublicKey.length === _constantscjs.KeySize.SECP256k1_PUBLIC_KEY ? _constantscjs.KeyType.SECP256K1 : _constantscjs.KeyType.ED25519;
          }
          const keySize = keyType === _constantscjs.KeyType.ED25519 ? _constantscjs.KeySize.ED25519_PUBLIC_KEY : _constantscjs.KeySize.SECP256k1_PUBLIC_KEY;
          if (decodedPublicKey.length !== keySize) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${keySize}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          const encodedKey = _utils.baseEncode.call(void 0, this.data);
          return `${key_type_to_str(this.keyType)}:${encodedKey}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          const keyType = this.keyType;
          const data7 = this.data;
          switch (keyType) {
            case _constantscjs.KeyType.ED25519:
              return _ed25519.ed25519.verify(signature, message, data7);
            case _constantscjs.KeyType.SECP256K1:
              return _secp256k12.default.ecdsaVerify(signature.subarray(0, 64), message, new Uint8Array([4, ...data7]));
            default:
              throw new Error(`Unknown key type: ${keyType}`);
          }
        }
        get keyPair() {
          return this.ed25519Key || this.secp256k1Key;
        }
        get keyType() {
          return this.keyPair.keyType;
        }
        get data() {
          return this.keyPair.data;
        }
      };
      function keyToImplicitAddress(publicKey) {
        const pk = PublicKey.from(publicKey);
        const publicKeyWithoutPrefix = pk.toString().replace(/^ed25519:/, "");
        const decoded = _utils.baseDecode.call(void 0, publicKeyWithoutPrefix);
        let result = "";
        for (let i = 0; i < decoded.length; i++) {
          const hex = decoded[i].toString(16);
          result += hex.length === 1 ? "0" + hex : hex;
        }
        return result;
      }
      exports2.PublicKey = PublicKey;
      exports2.keyToImplicitAddress = keyToImplicitAddress;
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs
  var require_key_pair_ed255197 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _utils = require_commonjs2();
      var _ed25519 = require_ed255197();
      var _utils3 = require_utils30();
      var _constantscjs = require_constants14();
      var _key_pair_basecjs = require_key_pair_base7();
      var _public_keycjs = require_public_key7();
      var KeyPairEd25519 = class _KeyPairEd25519 extends _key_pair_basecjs.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = _utils.baseDecode.call(void 0, extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, _constantscjs.KeySize.SECRET_KEY));
          const publicKey = _ed25519.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new (0, _public_keycjs.PublicKey)({ keyType: _constantscjs.KeyType.ED25519, data: publicKey });
          this.secretKey = _utils.baseEncode.call(void 0, secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = _utils3.randomBytes.call(void 0, _constantscjs.KeySize.SECRET_KEY);
          const publicKey = _ed25519.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519(_utils.baseEncode.call(void 0, extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = _ed25519.ed25519.sign(message, _utils.baseDecode.call(void 0, this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs
  var require_key_pair_secp256k1 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _utils = require_commonjs2();
      var _utils3 = require_utils30();
      var _secp256k1 = require_elliptic3();
      var _secp256k12 = _interopRequireDefault(_secp256k1);
      var _constantscjs = require_constants14();
      var _key_pair_basecjs = require_key_pair_base7();
      var _public_keycjs = require_public_key7();
      var KeyPairSecp256k1 = class _KeyPairSecp256k1 extends _key_pair_basecjs.KeyPairBase {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param {string} extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = _utils.baseDecode.call(void 0, extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, _constantscjs.KeySize.SECRET_KEY));
          const withHeader = _secp256k12.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const data7 = withHeader.subarray(1, withHeader.length);
          this.publicKey = new (0, _public_keycjs.PublicKey)({
            keyType: _constantscjs.KeyType.SECP256K1,
            data: data7
          });
          this.secretKey = _utils.baseEncode.call(void 0, secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = _utils3.randomBytes.call(void 0, _constantscjs.KeySize.SECRET_KEY);
          const withHeader = _secp256k12.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const publicKey = withHeader.subarray(1, withHeader.length);
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairSecp256k1(_utils.baseEncode.call(void 0, extendedSecretKey));
        }
        sign(message) {
          const { signature, recid } = _secp256k12.default.ecdsaSign(message, _utils.baseDecode.call(void 0, this.secretKey));
          return { signature: new Uint8Array([...signature, recid]), publicKey: this.publicKey };
        }
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        toString() {
          return `secp256k1:${this.extendedSecretKey}`;
        }
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairSecp256k1 = KeyPairSecp256k1;
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs
  var require_key_pair8 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _key_pair_basecjs = require_key_pair_base7();
      var _key_pair_ed25519cjs = require_key_pair_ed255197();
      var _key_pair_secp256k1cjs = require_key_pair_secp256k1();
      var KeyPair = class extends _key_pair_basecjs.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return _key_pair_ed25519cjs.KeyPairEd25519.fromRandom();
            case "SECP256K1":
              return _key_pair_secp256k1cjs.KeyPairSecp256k1.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new (0, _key_pair_ed25519cjs.KeyPairEd25519)(parts[1]);
              case "SECP256K1":
                return new (0, _key_pair_secp256k1cjs.KeyPairSecp256k1)(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-js/crypto/lib/commonjs/index.cjs
  var require_commonjs3 = __commonJS({
    "node_modules/@near-js/crypto/lib/commonjs/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _constantscjs = require_constants14();
      var _key_paircjs = require_key_pair8();
      var _key_pair_ed25519cjs = require_key_pair_ed255197();
      var _key_pair_secp256k1cjs = require_key_pair_secp256k1();
      var _public_keycjs = require_public_key7();
      exports2.KeyPair = _key_paircjs.KeyPair;
      exports2.KeyPairEd25519 = _key_pair_ed25519cjs.KeyPairEd25519;
      exports2.KeyPairSecp256k1 = _key_pair_secp256k1cjs.KeyPairSecp256k1;
      exports2.KeyType = _constantscjs.KeyType;
      exports2.PublicKey = _public_keycjs.PublicKey;
      exports2.keyToImplicitAddress = _public_keycjs.keyToImplicitAddress;
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/signature.cjs
  var require_signature6 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/signature.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var signature_exports = {};
      __export2(signature_exports, {
        Signature: () => Signature
      });
      module2.exports = __toCommonJS2(signature_exports);
      var import_crypto = require_commonjs3();
      var import_types = require_commonjs();
      function resolveEnumKeyName(keyType) {
        switch (keyType) {
          case import_crypto.KeyType.ED25519: {
            return "ed25519Signature";
          }
          case import_crypto.KeyType.SECP256K1: {
            return "secp256k1Signature";
          }
          default: {
            throw Error(`unknown type ${keyType}`);
          }
        }
      }
      var Signature = class extends import_types.Enum {
        enum;
        ed25519Signature;
        secp256k1Signature;
        constructor(signature) {
          const keyName = resolveEnumKeyName(signature.keyType);
          super({ [keyName]: signature });
          this[keyName] = signature;
          this.enum = keyName;
        }
        get signature() {
          return this.ed25519Signature || this.secp256k1Signature;
        }
        get signatureType() {
          return this.signature.keyType;
        }
        get data() {
          return this.signature.data;
        }
      };
    }
  });

  // node_modules/@near-js/transactions/lib/commonjs/index.cjs
  var require_commonjs4 = __commonJS({
    "node_modules/@near-js/transactions/lib/commonjs/index.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var index_exports = {};
      module2.exports = __toCommonJS2(index_exports);
      __reExport(index_exports, require_action_creators4(), module2.exports);
      __reExport(index_exports, require_actions4(), module2.exports);
      __reExport(index_exports, require_create_transaction4(), module2.exports);
      __reExport(index_exports, require_delegate4(), module2.exports);
      __reExport(index_exports, require_schema4(), module2.exports);
      __reExport(index_exports, require_signature6(), module2.exports);
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_feature/dapp_connect/error_handling_dappConnect.js
  var require_error_handling_dappConnect = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_feature/dapp_connect/error_handling_dappConnect.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getExternalActionErrorMessageForEndTag = exports2.EDappActionErrorTag = void 0;
      var EDappActionErrorTag;
      (function(EDappActionErrorTag2) {
        EDappActionErrorTag2["NEW_ACTION_STARTED"] = "NEW_ACTION_STARTED";
        EDappActionErrorTag2["INCOMPLETE_ACTION"] = "INCOMPLETE_ACTION";
        EDappActionErrorTag2["NO_ACCOUNTS"] = "NO_ACCOUNTS";
        EDappActionErrorTag2["WINDOW_CLOSED"] = "WINDOW_CLOSED";
        EDappActionErrorTag2["USER_CANCELLED"] = "USER_CANCELLED";
        EDappActionErrorTag2["POPUP_WINDOW_REFUSED"] = "POPUP_WINDOW_REFUSED";
        EDappActionErrorTag2["POPUP_WINDOW_OPEN_FAILED"] = "POPUP_WINDOW_OPEN_FAILED";
      })(EDappActionErrorTag = exports2.EDappActionErrorTag || (exports2.EDappActionErrorTag = {}));
      var en2 = {
        [EDappActionErrorTag.WINDOW_CLOSED]: "User closed the window",
        [EDappActionErrorTag.INCOMPLETE_ACTION]: "User didn't complete the action",
        [EDappActionErrorTag.NEW_ACTION_STARTED]: "A new action was started by the user, old action failed",
        [EDappActionErrorTag.POPUP_WINDOW_OPEN_FAILED]: "Popup window failed to open",
        [EDappActionErrorTag.POPUP_WINDOW_REFUSED]: "User refused to allow the popup window to open",
        [EDappActionErrorTag.USER_CANCELLED]: "User cancelled the action",
        [EDappActionErrorTag.NO_ACCOUNTS]: "No Meteor account found- try again after creating one"
      };
      function getExternalActionErrorMessageForEndTag(tag) {
        return en2[tag] ?? "An unknown error occurred";
      }
      exports2.getExternalActionErrorMessageForEndTag = getExternalActionErrorMessageForEndTag;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_feature/dapp_connect/types_dappConnect.js
  var require_types_dappConnect = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_feature/dapp_connect/types_dappConnect.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EDappActionConnectionStatus = exports2.EDappActionSource = exports2.EMeteorInjectedFeature = exports2.EMeteorExtensionDirectActionType = exports2.EWalletExternalActionStatus = exports2.EWalletExternalAction_SignIn_AccessType = exports2.EMeteorWalletSignInType = exports2.EExternalActionType = exports2.MeteorActionError = void 0;
      var error_handling_dappConnect_1 = require_error_handling_dappConnect();
      var MeteorActionError = class extends Error {
        constructor(reason, previousError) {
          super();
          if (reason.message == null) {
            reason.message = (0, error_handling_dappConnect_1.getExternalActionErrorMessageForEndTag)(reason.endTags?.[reason.endTags.length - 1] ?? "unknown");
          }
          this._reason = reason;
          this.message = reason.message;
          this.name = "MeteorActionError";
          this.cause = previousError;
        }
      };
      exports2.MeteorActionError = MeteorActionError;
      var EExternalActionType;
      (function(EExternalActionType2) {
        EExternalActionType2["login"] = "login";
        EExternalActionType2["sign"] = "sign";
        EExternalActionType2["logout"] = "logout";
        EExternalActionType2["verify_owner"] = "verify_owner";
        EExternalActionType2["keypom_claim"] = "keypom_claim";
        EExternalActionType2["sign_message"] = "sign_message";
      })(EExternalActionType = exports2.EExternalActionType || (exports2.EExternalActionType = {}));
      var EMeteorWalletSignInType2;
      (function(EMeteorWalletSignInType3) {
        EMeteorWalletSignInType3["ALL_METHODS"] = "ALL_METHODS";
        EMeteorWalletSignInType3["SELECTED_METHODS"] = "SELECTED_METHODS";
        EMeteorWalletSignInType3["FULL_ACCESS"] = "FULL_ACCESS";
      })(EMeteorWalletSignInType2 = exports2.EMeteorWalletSignInType || (exports2.EMeteorWalletSignInType = {}));
      var EWalletExternalAction_SignIn_AccessType;
      (function(EWalletExternalAction_SignIn_AccessType2) {
        EWalletExternalAction_SignIn_AccessType2["FULL_ACCESS"] = "fullAccess";
        EWalletExternalAction_SignIn_AccessType2["LIMITED_ACCESS"] = "limitedAccess";
      })(EWalletExternalAction_SignIn_AccessType = exports2.EWalletExternalAction_SignIn_AccessType || (exports2.EWalletExternalAction_SignIn_AccessType = {}));
      var EWalletExternalActionStatus;
      (function(EWalletExternalActionStatus2) {
        EWalletExternalActionStatus2["UNCONFIRMED"] = "UNCONFIRMED";
        EWalletExternalActionStatus2["PENDING"] = "PENDING";
        EWalletExternalActionStatus2["SUCCESS"] = "SUCCESS";
        EWalletExternalActionStatus2["FAILURE"] = "FAILURE";
      })(EWalletExternalActionStatus = exports2.EWalletExternalActionStatus || (exports2.EWalletExternalActionStatus = {}));
      var EMeteorExtensionDirectActionType;
      (function(EMeteorExtensionDirectActionType2) {
        EMeteorExtensionDirectActionType2["check_sync_status"] = "check_sync_status";
        EMeteorExtensionDirectActionType2["sync_accounts"] = "sync_accounts";
        EMeteorExtensionDirectActionType2["open_page"] = "open_page";
      })(EMeteorExtensionDirectActionType = exports2.EMeteorExtensionDirectActionType || (exports2.EMeteorExtensionDirectActionType = {}));
      var EMeteorInjectedFeature;
      (function(EMeteorInjectedFeature2) {
        EMeteorInjectedFeature2["open_page"] = "open_page";
        EMeteorInjectedFeature2["batch_import"] = "batch_import";
        EMeteorInjectedFeature2["sync_check"] = "sync_check";
        EMeteorInjectedFeature2["account_sync"] = "account_sync";
      })(EMeteorInjectedFeature = exports2.EMeteorInjectedFeature || (exports2.EMeteorInjectedFeature = {}));
      var EDappActionSource;
      (function(EDappActionSource2) {
        EDappActionSource2["website_callback"] = "wcb";
        EDappActionSource2["website_post_message"] = "wpm";
        EDappActionSource2["website_visit"] = "wv";
        EDappActionSource2["extension_injected"] = "ext";
      })(EDappActionSource = exports2.EDappActionSource || (exports2.EDappActionSource = {}));
      var EDappActionConnectionStatus;
      (function(EDappActionConnectionStatus2) {
        EDappActionConnectionStatus2["initializing"] = "initializing";
        EDappActionConnectionStatus2["connected"] = "connected";
        EDappActionConnectionStatus2["attempting_reconnect"] = "attempting_reconnect";
        EDappActionConnectionStatus2["disconnected"] = "disconnected";
        EDappActionConnectionStatus2["closed_success"] = "closed_success";
        EDappActionConnectionStatus2["closed_fail"] = "closed_fail";
        EDappActionConnectionStatus2["closed_window"] = "closed_window";
      })(EDappActionConnectionStatus = exports2.EDappActionConnectionStatus || (exports2.EDappActionConnectionStatus = {}));
    }
  });

  // node_modules/@meteorwallet/sdk/node_modules/borsh/lib/index.js
  var require_lib33 = __commonJS({
    "node_modules/@meteorwallet/sdk/node_modules/borsh/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs587());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports2.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str) {
          this.maybeResize();
          const b = Buffer.from(str, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array) {
          this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
          this.maybeResize();
          this.writeU32(array.length);
          for (const elem of array) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports2.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports2.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize3(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports2.serialize = serialize3;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map3 = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map3.set(key, val);
            }
            return map3;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports2.deserialize = deserialize2;
      function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports2.deserializeUnchecked = deserializeUnchecked;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_utility/data_type_utils/StringUtils.js
  var require_StringUtils = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_utility/data_type_utils/StringUtils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.StringUtils = exports2.stringToConstantStyledString = exports2.convertToSlug = exports2.pad = exports2.createPadder = exports2.BetterStringArray = exports2.safeAppend = exports2.firstNotNullEmpty = exports2.nullEmpty = exports2.notNullEmpty = exports2.StringRegex = void 0;
      exports2.StringRegex = {
        digitsRegex: /\b\d+\b/gi
      };
      var notNullEmpty = (str) => {
        return str != null && str.length > 0;
      };
      exports2.notNullEmpty = notNullEmpty;
      var nullEmpty = (str) => {
        return !(0, exports2.notNullEmpty)(str);
      };
      exports2.nullEmpty = nullEmpty;
      var firstNotNullEmpty = (...strItems) => {
        for (const item of strItems) {
          if ((0, exports2.notNullEmpty)(item)) {
            return item;
          }
        }
        return void 0;
      };
      exports2.firstNotNullEmpty = firstNotNullEmpty;
      var anyNullEmpty = (strs) => {
        for (const str of strs) {
          if ((0, exports2.nullEmpty)(str)) {
            return true;
          }
        }
        return false;
      };
      var safeAppend = (str, value, ifEmptyValue = null) => {
        return (0, exports2.notNullEmpty)(str) ? str + value : ifEmptyValue != null ? ifEmptyValue : value;
      };
      exports2.safeAppend = safeAppend;
      var BetterStringArray = class extends Array {
        pushIfNotNullEmpty(str) {
          if ((0, exports2.notNullEmpty)(str)) {
            this.push(str);
          }
        }
      };
      exports2.BetterStringArray = BetterStringArray;
      function createPadder(padCharacter, desiredTotalLength, padFromRight = false) {
        return (input) => {
          return pad2(input, padCharacter, desiredTotalLength, padFromRight);
        };
      }
      exports2.createPadder = createPadder;
      function pad2(input, padCharacter, desiredTotalLength, padFromRight = false) {
        const difference = desiredTotalLength - `${input}`.length;
        if (difference > 0) {
          const padding = new Array(difference).fill(padCharacter);
          if (padFromRight) {
            return `${input}${padding.join("")}`;
          }
          return `${padding.join("")}${input}`;
        }
        return `${input}`;
      }
      exports2.pad = pad2;
      var regexAllSpaces = new RegExp("\\s+", "g");
      var regexDoubleDashes = new RegExp("--+", "g");
      var regexFirstDash = new RegExp("^-+", "g");
      var regexLastDash = new RegExp("-+$", "g");
      var regexSingleDash = new RegExp("-", "g");
      var regexRemoveNonWord = new RegExp("[^\\w\\-]+", "g");
      var regexAllUnderscores = new RegExp("_", "g");
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      var convertToSlug = (text, { slugDivider = "-", letterCase = "LOWER", normalize: normalize7 = true, excludeCharacters = [] } = {}) => {
        if (!text || text.length === 0) {
          return "";
        }
        let resp = text.toString();
        if (normalize7) {
          resp = resp.normalize("NFD");
        }
        if (letterCase === "LOWER") {
          resp = resp.toLowerCase();
        } else if (letterCase === "UPPER") {
          resp = resp.toUpperCase();
        }
        return resp.replace(regexAllSpaces, "-").replace(excludeCharacters.length > 0 ? new RegExp(`[^\\w\\-${excludeCharacters.map((c) => escapeRegExp(c)).join("")}]+`, "g") : regexRemoveNonWord, "").replace(excludeCharacters.includes("_") ? regexAllSpaces : regexAllUnderscores, "-").replace(regexDoubleDashes, "-").replace(regexFirstDash, "").replace(regexLastDash, "").replace(regexSingleDash, slugDivider);
      };
      exports2.convertToSlug = convertToSlug;
      var stringToConstantStyledString = (input) => {
        return (0, exports2.convertToSlug)(input, {
          normalize: true,
          slugDivider: "_",
          letterCase: "UPPER"
        });
      };
      exports2.stringToConstantStyledString = stringToConstantStyledString;
      var reverse = (input) => {
        let r = ``;
        for (const char of input) {
          r = `${char}${r}`;
        }
        return r;
      };
      function isUriEncoded(uri) {
        uri = uri || "";
        return uri !== decodeURIComponent(uri);
      }
      var decodeUriFully = (uri) => {
        let failSafe = 0;
        while (isUriEncoded(uri)) {
          failSafe += 1;
          uri = decodeURIComponent(uri);
          if (failSafe > 20) {
            throw new Error(`String Utils: Decode URI Fully: Enacted while loop too many times with attempt to decode fully.`);
          }
        }
        return uri;
      };
      var removeAndTrim = (input, removeText, { spaceAware = true, insideWords = false } = {}) => {
        let text = `${input}`;
        for (const rem of removeText) {
          if (spaceAware) {
            if (!insideWords) {
              if (text.indexOf(` ${rem} `) >= 0) {
                text = text.replace(` ${rem} `, " ");
              } else {
                if (text.startsWith(`${rem} `)) {
                  text = text.substring(rem.length + 1);
                }
                if (text.endsWith(` ${rem}`)) {
                  text = text.substring(0, text.length - (rem.length + 1));
                }
              }
            } else {
              const checkNew = [
                new RegExp(`\\s${rem}\\s`, "g"),
                new RegExp(`\\s${rem}`, "g"),
                new RegExp(`${rem}\\s`, "g")
              ];
              for (const remNew of checkNew) {
                if (remNew.test(text)) {
                  console.log(`Replacing "${remNew}" in "${text}"`);
                  text = text.replace(remNew, " ");
                  console.log(`Text after: "${text}"`);
                }
              }
            }
          } else {
            if (text.indexOf(rem) >= 0) {
              text = text.replace(rem, "");
            }
          }
        }
        return text.trim();
      };
      function sortCompareStrings(a, b) {
        const aa = a.toLowerCase();
        const bb = b.toLowerCase();
        if (aa < bb)
          return -1;
        if (aa > bb)
          return 1;
        return 0;
      }
      function comparePure(a, b) {
        if (a > b) {
          return 1;
        }
        if (a < b) {
          return -1;
        }
        return 0;
      }
      function onlyNotNullEmpty(strArray) {
        let notNullEmptyArray = [];
        for (const str of strArray) {
          if ((0, exports2.notNullEmpty)(str)) {
            notNullEmptyArray.push(str);
          }
        }
        return notNullEmptyArray;
      }
      var joinIntoUrl = (...routes) => {
        return routes.filter((v) => v).map((v, i, arr) => {
          const isNotFirst = i !== 0;
          const isNotLast = i !== arr.length - 1;
          if (isNotFirst) {
            v = v.startsWith("/") ? v.slice(1) : v;
          }
          if (isNotLast) {
            v = v.endsWith("/") ? v.slice(0, -1) : v;
          }
          return v;
        }).join("/");
      };
      var getUrlWithBaseUrl = (baseUrl, route) => {
        const isRouteCompleted = route.startsWith("http://") || route.startsWith("https://");
        if (isRouteCompleted) {
          return route;
        }
        return joinIntoUrl(baseUrl, route);
      };
      var isHashId = (accountId) => {
        const hash = accountId.match(/^[a-zA-Z0-9]+$/);
        return Boolean(hash);
      };
      exports2.StringUtils = {
        isUriEncoded,
        decodeUriFully,
        StringRegex: exports2.StringRegex,
        reverse,
        notNullEmpty: exports2.notNullEmpty,
        nullEmpty: exports2.nullEmpty,
        anyNullEmpty,
        safeAppend: exports2.safeAppend,
        createPadder,
        pad: pad2,
        convertToSlug: exports2.convertToSlug,
        stringToConstantStyledString: exports2.stringToConstantStyledString,
        removeAndTrim,
        sortCompareStrings,
        comparePure,
        onlyNotNullEmpty,
        firstNotNullEmpty: exports2.firstNotNullEmpty,
        joinIntoUrl,
        getUrlWithBaseUrl,
        isHashId
      };
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_utility/state_utils/EnvironmentStorageUtils.js
  var require_EnvironmentStorageUtils = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_utility/state_utils/EnvironmentStorageUtils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EnvironmentStateAdapter_Sync = exports2.EnvironmentStateAdapter = void 0;
      var EnvironmentStateAdapter = class {
        constructor(implementation) {
          this.implementation = implementation;
        }
        async setJson(key, value) {
          await this.implementation.setString(key, JSON.stringify(value));
        }
        async getJson(key) {
          const val = await this.implementation.getString(key);
          if (val == null || val === "undefined" || val === "null") {
            return void 0;
          }
          return JSON.parse(val);
        }
        async setString(key, value) {
          await this.implementation.setString(key, value);
        }
        async getString(key) {
          const val = await this.implementation.getString(key);
          if (val == null) {
            return void 0;
          }
          return val;
        }
        createJsonGetterSetter(key) {
          return {
            get: () => this.getJson(key),
            set: (value) => this.setJson(key, value)
          };
        }
        createStringGetterSetter(key) {
          return {
            get: () => this.getString(key),
            set: (value) => this.setString(key, value)
          };
        }
      };
      exports2.EnvironmentStateAdapter = EnvironmentStateAdapter;
      var EnvironmentStateAdapter_Sync = class {
        constructor(implementation) {
          this.implementation = implementation;
        }
        setJson(key, value) {
          this.implementation.setString(key, JSON.stringify(value));
        }
        getJson(key) {
          const val = this.implementation.getString(key);
          if (val == null || val === "undefined" || val === "null") {
            return void 0;
          }
          return JSON.parse(val);
        }
        setString(key, value) {
          this.implementation.setString(key, value);
        }
        getString(key) {
          const val = this.implementation.getString(key);
          if (val == null) {
            return void 0;
          }
          return val;
        }
        clear(key) {
          this.implementation.clear(key);
        }
        createJsonGetterSetter(key) {
          return {
            get: () => this.getJson(key),
            set: (value) => this.setJson(key, value)
          };
        }
        createStringGetterSetter(key) {
          return {
            get: () => this.getString(key),
            set: (value) => this.setString(key, value)
          };
        }
      };
      exports2.EnvironmentStateAdapter_Sync = EnvironmentStateAdapter_Sync;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/MeteorWalletConstants.js
  var require_MeteorWalletConstants = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/MeteorWalletConstants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WALLET_URL_LOCALHOST_BASE = exports2.WALLET_URL_PRODUCTION_BASE = exports2.WALLET_URL_DEV_BASE = void 0;
      exports2.WALLET_URL_DEV_BASE = "https://dev.wallet.meteorwallet.app";
      exports2.WALLET_URL_PRODUCTION_BASE = "https://wallet.meteorwallet.app";
      exports2.WALLET_URL_LOCALHOST_BASE = "https://localhost:3000";
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/envConfig.js
  var require_envConfig = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/envConfig.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setEnvConfig = exports2.envConfig = void 0;
      var MeteorWalletConstants_1 = require_MeteorWalletConstants();
      var locallySetBaseUrl = typeof window !== "undefined" ? window.localStorage.getItem("DEV__METEOR_WALLET_BASE_URL") : void 0;
      exports2.envConfig = {
        wallet_base_url: locallySetBaseUrl ?? MeteorWalletConstants_1.WALLET_URL_PRODUCTION_BASE
      };
      function setEnvConfig(config4) {
        Object.assign(exports2.envConfig, config4);
      }
      exports2.setEnvConfig = setEnvConfig;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/utils/MeteorSdkUtils.js
  var require_MeteorSdkUtils = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/utils/MeteorSdkUtils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getNetworkPreset = exports2.resolveWalletUrl = void 0;
      var envConfig_1 = require_envConfig();
      var resolveWalletUrl2 = (network, walletUrl) => {
        if (walletUrl) {
          return walletUrl;
        }
        const base3 = envConfig_1.envConfig.wallet_base_url;
        switch (network) {
          case "mainnet":
            return `${base3}/connect/mainnet`;
          case "testnet":
            return `${base3}/connect/testnet`;
          case "betanet":
            return `${base3}/connect/betanet`;
          default:
            throw new Error("Invalid wallet URL");
        }
      };
      exports2.resolveWalletUrl = resolveWalletUrl2;
      var getNetworkPreset2 = (networkId) => {
        switch (networkId) {
          case "mainnet":
            return {
              networkId,
              nodeUrl: "https://rpc.mainnet.near.org",
              helperUrl: "https://helper.mainnet.near.org",
              explorerUrl: "https://explorer.near.org"
            };
          case "testnet":
            return {
              networkId,
              nodeUrl: "https://rpc.testnet.near.org",
              helperUrl: "https://helper.testnet.near.org",
              explorerUrl: "https://explorer.testnet.near.org"
            };
          case "betanet":
            return {
              networkId,
              nodeUrl: "https://rpc.betanet.near.org",
              helperUrl: "https://helper.betanet.near.org",
              explorerUrl: "https://explorer.betanet.near.org"
            };
          default:
            throw Error(`Failed to find config for: '${networkId}'`);
        }
      };
      exports2.getNetworkPreset = getNetworkPreset2;
    }
  });

  // node_modules/nanoid/url-alphabet/index.js
  var urlAlphabet;
  var init_url_alphabet = __esm({
    "node_modules/nanoid/url-alphabet/index.js"() {
      init_process();
      init_buffer();
      urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    }
  });

  // node_modules/nanoid/index.browser.js
  var index_browser_exports = {};
  __export(index_browser_exports, {
    customAlphabet: () => customAlphabet,
    customRandom: () => customRandom,
    nanoid: () => nanoid,
    random: () => random,
    urlAlphabet: () => urlAlphabet
  });
  var random, customRandom, customAlphabet, nanoid;
  var init_index_browser = __esm({
    "node_modules/nanoid/index.browser.js"() {
      init_process();
      init_buffer();
      init_url_alphabet();
      random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
      customRandom = (alphabet, defaultSize, getRandom) => {
        let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
        let step = -~(1.6 * mask * defaultSize / alphabet.length);
        return (size = defaultSize) => {
          let id7 = "";
          while (true) {
            let bytes = getRandom(step);
            let j = step;
            while (j--) {
              id7 += alphabet[bytes[j] & mask] || "";
              if (id7.length === size) return id7;
            }
          }
        };
      };
      customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
      nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id7, byte) => {
        byte &= 63;
        if (byte < 36) {
          id7 += byte.toString(36);
        } else if (byte < 62) {
          id7 += (byte - 26).toString(36).toUpperCase();
        } else if (byte > 62) {
          id7 += "-";
        } else {
          id7 += "_";
        }
        return id7;
      }, "");
    }
  });

  // node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split7) {
        try {
          return [decodeURIComponent(components.join(""))];
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split7 = split7 || 1;
        var left = components.slice(0, split7);
        var right = components.slice(split7);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher) || [];
          for (var i = 1; i < tokens.length; i++) {
            input = decodeComponents(tokens, i).join("");
            tokens = input.match(singleMatcher) || [];
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match5 = multiMatcher.exec(input);
        while (match5) {
          try {
            replaceMap[match5[0]] = decodeURIComponent(match5[0]);
          } catch (err) {
            var result = decode(match5[0]);
            if (result !== match5[0]) {
              replaceMap[match5[0]] = result;
            }
          }
          match5 = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries2 = Object.keys(replaceMap);
        for (var i = 0; i < entries2.length; i++) {
          var key = entries2[i];
          input = input.replace(new RegExp(key, "g"), replaceMap[key]);
        }
        return input;
      }
      module2.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = (string, separator) => {
        if (!(typeof string === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string];
        }
        const separatorIndex = string.indexOf(separator);
        if (separatorIndex === -1) {
          return [string];
        }
        return [
          string.slice(0, separatorIndex),
          string.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // node_modules/filter-obj/index.js
  var require_filter_obj = __commonJS({
    "node_modules/filter-obj/index.js"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      module2.exports = function(obj, predicate) {
        var ret = {};
        var keys14 = Object.keys(obj);
        var isArr = Array.isArray(predicate);
        for (var i = 0; i < keys14.length; i++) {
          var key = keys14[i];
          var val = obj[key];
          if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
          }
        }
        return ret;
      };
    }
  });

  // node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "node_modules/query-string/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var filterObject = require_filter_obj();
      var isNullOrUndefined2 = (value) => value === null || value === void 0;
      var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key) => (result, value) => {
              const index = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), "[", index, "]"].join("")];
              }
              return [
                ...result,
                [encode3(key, options), "[", encode3(index, options), "]=", encode3(value, options)].join("")
              ];
            };
          case "bracket":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), "[]"].join("")];
              }
              return [...result, [encode3(key, options), "[]=", encode3(value, options)].join("")];
            };
          case "colon-list-separator":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), ":list="].join("")];
              }
              return [...result, [encode3(key, options), ":list=", encode3(value, options)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode3(key, options), keyValueSep, encode3(value, options)].join("")];
              }
              return [[result, encode3(value, options)].join(options.arrayFormatSeparator)];
            };
          }
          default:
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode3(key, options)];
              }
              return [...result, [encode3(key, options), "=", encode3(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key);
              key = key.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = {};
              }
              accumulator[key][result[1]] = value;
            };
          case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key);
              key = key.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "colon-list-separator":
            return (key, value, accumulator) => {
              result = /(:list)$/.exec(key);
              key = key.replace(/:list$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "comma":
          case "separator":
            return (key, value, accumulator) => {
              const isArray6 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray6 && decode(value, options).includes(options.arrayFormatSeparator);
              value = isEncodedArray ? decode(value, options) : value;
              const newValue = isArray6 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
              accumulator[key] = newValue;
            };
          case "bracket-separator":
            return (key, value, accumulator) => {
              const isArray6 = /(\[\])$/.test(key);
              key = key.replace(/\[\]$/, "");
              if (!isArray6) {
                accumulator[key] = value ? decode(value, options) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
              if (accumulator[key] === void 0) {
                accumulator[key] = arrayValue;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
          default:
            return (key, value, accumulator) => {
              if (accumulator[key] === void 0) {
                accumulator[key] = value;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode3(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash2(url) {
        let hash = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash = url.slice(hashStart);
        }
        return hash;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse3(query, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
          formatter(decode(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if (typeof value === "object" && value !== null) {
            for (const k of Object.keys(value)) {
              value[k] = parseValue(value[k], options);
            }
          } else {
            ret[key] = parseValue(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
          const value = ret[key];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key] = keysSorter(value);
          } else {
            result[key] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports2.extract = extract;
      exports2.parse = parse3;
      exports2.stringify = (object, options) => {
        if (!object) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key of Object.keys(object)) {
          if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
          }
        }
        const keys14 = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys14.sort(options.sort);
        }
        return keys14.map((key) => {
          const value = object[key];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode3(key, options);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === "bracket-separator") {
              return encode3(key, options) + "[]";
            }
            return value.reduce(formatter(key), []).join("&");
          }
          return encode3(key, options) + "=" + encode3(value, options);
        }).filter((x) => x.length > 0).join("&");
      };
      exports2.parseUrl = (url, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url_, hash] = splitOnFirst(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse3(extract(url), options)
          },
          options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
        );
      };
      exports2.stringifyUrl = (object, options) => {
        options = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options);
        const url = removeHash(object.url).split("?")[0] || "";
        const queryFromUrl = exports2.extract(object.url);
        const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports2.stringify(query, options);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash = getHash2(object.url);
        if (object.fragmentIdentifier) {
          hash = `#${options[encodeFragmentIdentifier] ? encode3(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
        }
        return `${url}${queryString}${hash}`;
      };
      exports2.pick = (input, filter, options) => {
        options = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options);
        const { url, query, fragmentIdentifier } = exports2.parseUrl(input, options);
        return exports2.stringifyUrl({
          url,
          query: filterObject(query, filter),
          fragmentIdentifier
        }, options);
      };
      exports2.exclude = (input, filter, options) => {
        const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
        return exports2.pick(input, exclusionFilter, options);
      };
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_app_core/theme/constants_theme.js
  var require_constants_theme = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_app_core/theme/constants_theme.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.THEME_SMALL_WINDOW_WIDTH_MAX = exports2.THEME_CONSTANT_BADGE_GREY_COLOR = exports2.THEME_CONSTANT_GREEN_COLOR = exports2.THEME_CONSTANT_RED_COLOR = exports2.THEME_CONSTANT_COLOR_DARK = exports2.THEME_CONSTANT_COLOR_BRAND = exports2.SIGN_POPUP_HEIGHT = exports2.SIGN_POPUP_WIDTH = void 0;
      exports2.SIGN_POPUP_WIDTH = 390;
      exports2.SIGN_POPUP_HEIGHT = 650;
      exports2.THEME_CONSTANT_COLOR_BRAND = "#471be8";
      exports2.THEME_CONSTANT_COLOR_DARK = "#101046";
      exports2.THEME_CONSTANT_RED_COLOR = "#e25252";
      exports2.THEME_CONSTANT_GREEN_COLOR = "#8bdaa1";
      exports2.THEME_CONSTANT_BADGE_GREY_COLOR = "rgba(116,117,126,0.67)";
      exports2.THEME_SMALL_WINDOW_WIDTH_MAX = 600;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/postMessage/MeteorPostMessenger.js
  var require_MeteorPostMessenger = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/postMessage/MeteorPostMessenger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getMeteorPostMessenger = void 0;
      var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
      var envConfig_1 = require_envConfig();
      var types_dappConnect_1 = require_types_dappConnect();
      var query_string_1 = require_query_string();
      var error_handling_dappConnect_1 = require_error_handling_dappConnect();
      var constants_theme_1 = require_constants_theme();
      var ComWindow = class {
        constructor(connection, listener5) {
          const baseWalletUrl = envConfig_1.envConfig.wallet_base_url;
          const url = new URL(baseWalletUrl);
          this.walletOrigin = url.origin;
          if (window.meteorCom == null) {
            this.comType = types_dappConnect_1.EDappActionSource.website_post_message;
            console.log("No extension found. Need to connect to web popup for Meteor communication");
            const queryParams = {
              source: types_dappConnect_1.EDappActionSource.website_post_message,
              connectionUid: connection.uid
            };
            const w = constants_theme_1.SIGN_POPUP_WIDTH;
            const h = constants_theme_1.SIGN_POPUP_HEIGHT;
            const y = window.top.outerHeight / 2 + window.top.screenY - h / 2;
            const x = window.top.outerWidth / 2 + window.top.screenX - w / 2;
            const newWindow = window.open(`${baseWalletUrl}/connect/${connection.network}/${connection.actionType}?${(0, query_string_1.stringify)(queryParams)}`, "_blank", `popup=1,width=${w},height=${h},top=${y},left=${x}`);
            if (newWindow != null) {
              this.websiteWindow = newWindow;
            } else {
              throw new types_dappConnect_1.MeteorActionError({
                message: "Couldn't open popup window to complete wallet action",
                endTags: [error_handling_dappConnect_1.EDappActionErrorTag.POPUP_WINDOW_OPEN_FAILED]
              });
            }
            window.addEventListener("message", (event) => listener5(event.data));
            this.wasOpened = false;
          } else {
            this.comType = types_dappConnect_1.EDappActionSource.extension_injected;
            this.wasOpened = true;
            window.meteorCom.addMessageDataListener(listener5);
          }
        }
        focus() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            this.websiteWindow?.focus();
          }
        }
        sendMessage(data7) {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            this.websiteWindow?.postMessage(data7, this.walletOrigin);
          } else {
            window.meteorCom?.sendMessageData(data7);
          }
        }
        isWindowClosed() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            return this.websiteWindow?.closed ?? true;
          } else {
            return false;
          }
        }
        hasActiveWindow() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            return this.websiteWindow != null;
          } else {
            return true;
          }
        }
        close() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            delete this.websiteWindow;
          } else {
          }
        }
      };
      var pingInterval = 450;
      var MeteorPostMessenger = class {
        constructor() {
          this.connections = [];
          const baseUrl = envConfig_1.envConfig.wallet_base_url;
          const url = new URL(baseUrl);
          this.baseWalletUrl = baseUrl;
          this.walletOrigin = url.origin;
          this.listener = (data7) => {
            if (data7 != null) {
              const currentConnection = this.connections.find((con) => con.uid === data7.uid);
              if (currentConnection != null) {
                this.updateConnection(currentConnection.uid, {
                  lastConnection: Date.now()
                });
                if (data7.status === types_dappConnect_1.EDappActionConnectionStatus.attempting_reconnect) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.initializing
                  });
                  this.sendComs();
                }
                if (data7.status === types_dappConnect_1.EDappActionConnectionStatus.connected && currentConnection.status === types_dappConnect_1.EDappActionConnectionStatus.initializing) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.connected
                  });
                }
                if (data7.status === types_dappConnect_1.EDappActionConnectionStatus.closed_success) {
                  currentConnection.resolve({
                    success: true,
                    endTags: [],
                    payload: data7.payload
                  });
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_success
                  });
                  this.sendComs();
                }
                if (data7.status === types_dappConnect_1.EDappActionConnectionStatus.closed_fail) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_fail
                  });
                  this.sendComs();
                  currentConnection.reject(new types_dappConnect_1.MeteorActionError({ endTags: data7.endTags }));
                }
                if (data7.status === types_dappConnect_1.EDappActionConnectionStatus.closed_window) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_window
                  });
                  currentConnection.reject(new types_dappConnect_1.MeteorActionError({
                    endTags: data7.endTags,
                    message: "User closed the window"
                  }));
                }
                if ([
                  types_dappConnect_1.EDappActionConnectionStatus.disconnected,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_fail,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_window,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_success
                ].includes(data7.status)) {
                  this.removeConnection(currentConnection.uid);
                }
              }
            }
          };
        }
        removeConnection(uid7) {
          this.connections = this.connections.filter((con) => con.uid !== uid7);
          if (this.connections.length === 0) {
            delete this.comWindow;
            clearInterval(this.comInterval);
            delete this.comInterval;
          }
        }
        updateConnection(uid7, newConnectionProperties) {
          this.connections = this.connections.map((con) => {
            if (con.uid === uid7) {
              return {
                ...con,
                ...newConnectionProperties,
                uid: con.uid
              };
            }
            return con;
          });
        }
        sendComs() {
          if (this.comWindow?.hasActiveWindow() && this.connections.length > 0) {
            if (this.comInterval == null) {
              this.comInterval = setInterval(() => this.sendComs(), pingInterval);
            }
            if (this.comWindow.isWindowClosed()) {
              if (this.comWindow.wasOpened) {
                for (const con of this.connections) {
                  con.reject(new types_dappConnect_1.MeteorActionError({
                    message: "User closed the window before completing the action",
                    endTags: [
                      error_handling_dappConnect_1.EDappActionErrorTag.INCOMPLETE_ACTION,
                      error_handling_dappConnect_1.EDappActionErrorTag.WINDOW_CLOSED
                    ]
                  }));
                }
                this.connections = [];
                this.comWindow.close();
              } else {
                console.log("Window is closed, need to allow popup");
              }
            } else {
              this.comWindow.wasOpened = true;
              for (const { network, actionType, endTags, status, inputs, uid: uid7 } of this.connections) {
                const postMessage2 = {
                  endTags,
                  actionType,
                  status,
                  uid: uid7,
                  network
                };
                if (status === types_dappConnect_1.EDappActionConnectionStatus.initializing) {
                  postMessage2.inputs = inputs;
                }
                this.comWindow.sendMessage(postMessage2);
              }
            }
          } else {
            clearInterval(this.comInterval);
            delete this.comInterval;
          }
        }
        addAndStartConnection(connection) {
          if (this.connections.length > 0) {
            for (const con of this.connections) {
              con.status = types_dappConnect_1.EDappActionConnectionStatus.disconnected;
              con.endTags = [error_handling_dappConnect_1.EDappActionErrorTag.NEW_ACTION_STARTED];
            }
          }
          this.connections.push(connection);
          if (this.comWindow == null || !this.comWindow.hasActiveWindow()) {
            this.comWindow = new ComWindow(connection, this.listener);
          } else {
            this.comWindow.focus();
          }
          this.sendComs();
        }
        async connectAndWaitForResponse({ actionType, network, inputs }) {
          let newConnection = {
            uid: (0, nanoid_1.nanoid)(),
            actionType,
            lastAttemptedConnection: 0,
            lastConnection: 0,
            status: types_dappConnect_1.EDappActionConnectionStatus.initializing,
            promise: void 0,
            reject: void 0,
            resolve: void 0,
            currentPayload: {},
            inputs,
            network,
            endTags: []
          };
          const promise5 = new Promise((resolve5, reject5) => {
            newConnection.resolve = resolve5;
            newConnection.reject = (error2) => {
              this.connections = this.connections.filter((con) => con.uid !== newConnection.uid);
              reject5(error2);
            };
          });
          newConnection.promise = promise5;
          this.addAndStartConnection(newConnection);
          return await promise5;
        }
      };
      var postMessenger;
      function getMeteorPostMessenger() {
        if (postMessenger == null) {
          postMessenger = new MeteorPostMessenger();
        }
        return postMessenger;
      }
      exports2.getMeteorPostMessenger = getMeteorPostMessenger;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/near-schema/TransactionSchemaV2.js
  var require_TransactionSchemaV2 = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/near-schema/TransactionSchemaV2.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SCHEMA_V2 = void 0;
      var crypto_1 = require_commonjs3();
      var transactions_1 = require_commonjs4();
      exports2.SCHEMA_V2 = /* @__PURE__ */ new Map([
        [
          transactions_1.Signature,
          {
            kind: "struct",
            fields: [
              ["keyType", "u8"],
              ["data", [64]]
            ]
          }
        ],
        [
          transactions_1.SignedTransaction,
          {
            kind: "struct",
            fields: [
              ["transaction", transactions_1.Transaction],
              ["signature", transactions_1.Signature]
            ]
          }
        ],
        [
          transactions_1.Transaction,
          {
            kind: "struct",
            fields: [
              ["signerId", "string"],
              ["publicKey", crypto_1.PublicKey],
              ["nonce", "u64"],
              ["receiverId", "string"],
              ["blockHash", [32]],
              ["actions", [transactions_1.Action]]
            ]
          }
        ],
        [
          crypto_1.PublicKey,
          {
            kind: "struct",
            fields: [
              ["keyType", "u8"],
              ["data", [32]]
            ]
          }
        ],
        [
          transactions_1.AccessKey,
          {
            kind: "struct",
            fields: [
              ["nonce", "u64"],
              ["permission", transactions_1.AccessKeyPermission]
            ]
          }
        ],
        [
          transactions_1.AccessKeyPermission,
          {
            kind: "enum",
            field: "enum",
            values: [
              ["functionCall", transactions_1.FunctionCallPermission],
              ["fullAccess", transactions_1.FullAccessPermission]
            ]
          }
        ],
        [
          transactions_1.FunctionCallPermission,
          {
            kind: "struct",
            fields: [
              ["allowance", { kind: "option", type: "u128" }],
              ["receiverId", "string"],
              ["methodNames", ["string"]]
            ]
          }
        ],
        [transactions_1.FullAccessPermission, { kind: "struct", fields: [] }],
        [
          transactions_1.Action,
          {
            kind: "enum",
            field: "enum",
            values: [
              ["createAccount", transactions_1.CreateAccount],
              ["deployContract", transactions_1.DeployContract],
              ["functionCall", transactions_1.FunctionCall],
              ["transfer", transactions_1.Transfer],
              ["stake", transactions_1.Stake],
              ["addKey", transactions_1.AddKey],
              ["deleteKey", transactions_1.DeleteKey],
              ["deleteAccount", transactions_1.DeleteAccount],
              ["signedDelegate", transactions_1.SignedDelegate]
            ]
          }
        ],
        [transactions_1.CreateAccount, { kind: "struct", fields: [] }],
        [transactions_1.DeployContract, { kind: "struct", fields: [["code", ["u8"]]] }],
        [
          transactions_1.FunctionCall,
          {
            kind: "struct",
            fields: [
              ["methodName", "string"],
              ["args", ["u8"]],
              ["gas", "u64"],
              ["deposit", "u128"]
            ]
          }
        ],
        [transactions_1.Transfer, { kind: "struct", fields: [["deposit", "u128"]] }],
        [
          transactions_1.Stake,
          {
            kind: "struct",
            fields: [
              ["stake", "u128"],
              ["publicKey", crypto_1.PublicKey]
            ]
          }
        ],
        [
          transactions_1.AddKey,
          {
            kind: "struct",
            fields: [
              ["publicKey", crypto_1.PublicKey],
              ["accessKey", transactions_1.AccessKey]
            ]
          }
        ],
        [transactions_1.DeleteKey, { kind: "struct", fields: [["publicKey", crypto_1.PublicKey]] }],
        [transactions_1.DeleteAccount, { kind: "struct", fields: [["beneficiaryId", "string"]] }],
        [
          transactions_1.DelegateAction,
          {
            kind: "struct",
            fields: [
              ["senderId", "string"],
              ["receiverId", "string"],
              ["actions", [transactions_1.Action]],
              ["nonce", "u64"],
              ["maxBlockHeight", "u64"],
              ["publicKey", crypto_1.PublicKey]
            ]
          }
        ],
        [
          transactions_1.SignedDelegate,
          {
            kind: "struct",
            fields: [
              ["delegateAction", transactions_1.DelegateAction],
              ["signature", transactions_1.Signature]
            ]
          }
        ]
      ]);
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/utils/create-action.js
  var require_create_action = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/utils/create-action.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createAction = exports2.parseArgs = void 0;
      var bn_js_1 = require_bn();
      var transactions_1 = require_commonjs4();
      var crypto_1 = require_commonjs3();
      var getAccessKey2 = (permission) => {
        if (permission === "FullAccess") {
          return transactions_1.actionCreators.fullAccessKey();
        }
        const { receiverId, methodNames = [] } = permission;
        const allowance = permission.allowance ? new bn_js_1.BN(permission.allowance) : void 0;
        return transactions_1.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
      };
      var parseArgs = (data7) => {
        if (typeof data7 === "string")
          return Buffer.from(data7, "base64");
        return data7;
      };
      exports2.parseArgs = parseArgs;
      var createAction2 = (action) => {
        switch (action.type) {
          case "CreateAccount":
            return transactions_1.actionCreators.createAccount();
          case "DeployContract": {
            const { code } = action.params;
            return transactions_1.actionCreators.deployContract(code);
          }
          case "FunctionCall": {
            const { methodName, args, gas, deposit } = action.params;
            return transactions_1.actionCreators.functionCall(methodName, (0, exports2.parseArgs)(args), new bn_js_1.BN(gas), new bn_js_1.BN(deposit));
          }
          case "Transfer": {
            const { deposit } = action.params;
            return transactions_1.actionCreators.transfer(new bn_js_1.BN(deposit));
          }
          case "Stake": {
            const { stake, publicKey } = action.params;
            return transactions_1.actionCreators.stake(new bn_js_1.BN(stake), crypto_1.PublicKey.from(publicKey));
          }
          case "AddKey": {
            const { publicKey, accessKey } = action.params;
            return transactions_1.actionCreators.addKey(
              crypto_1.PublicKey.from(publicKey),
              // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
              getAccessKey2(accessKey.permission)
            );
          }
          case "DeleteKey": {
            const { publicKey } = action.params;
            return transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey));
          }
          case "DeleteAccount": {
            const { beneficiaryId } = action.params;
            return transactions_1.actionCreators.deleteAccount(beneficiaryId);
          }
          default:
            throw new Error("Invalid action type");
        }
      };
      exports2.createAction = createAction2;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/MeteorWallet.js
  var require_MeteorWallet = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/MeteorWallet.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConnectedMeteorWalletAccount = exports2.MeteorWallet = void 0;
      var near_api_js_1 = require_browser_index2();
      var transactions_1 = require_commonjs4();
      var types_dappConnect_1 = require_types_dappConnect();
      var borsh_1 = require_lib33();
      var StringUtils_1 = require_StringUtils();
      var EnvironmentStorageUtils_1 = require_EnvironmentStorageUtils();
      var MeteorSdkUtils_1 = require_MeteorSdkUtils();
      var MeteorPostMessenger_1 = require_MeteorPostMessenger();
      var TransactionSchemaV2_1 = require_TransactionSchemaV2();
      var crypto_1 = require_commonjs3();
      var create_action_1 = require_create_action();
      var bn_js_1 = require_bn();
      var MULTISIG_HAS_METHOD = "add_request_and_confirm";
      var LOCAL_STORAGE_KEY_SUFFIX = "_meteor_wallet_auth_key";
      var localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
        getString: (key) => window.localStorage.getItem(key),
        setString: (key, value) => window.localStorage.setItem(key, value),
        clear: (key) => window.localStorage.removeItem(key)
      });
      var sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
        getString: (key) => window.sessionStorage.getItem(key),
        setString: (key, value) => window.sessionStorage.setItem(key, value),
        clear: (key) => window.sessionStorage.removeItem(key)
      });
      var MeteorWallet2 = class _MeteorWallet {
        /**
         * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.
         *
         * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}
         *
         * @example
         * ```js
         * const wallet = await MeteorWallet.init({ networkId: "testnet" });
         * ```
         */
        static async init({ walletUrl, ...config4 }) {
          const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();
          const near = await (0, near_api_js_1.connect)({
            keyStore,
            headers: {},
            walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config4.networkId, walletUrl),
            ...(0, MeteorSdkUtils_1.getNetworkPreset)(config4.networkId),
            ...config4
          });
          const wallet = new _MeteorWallet({ near, appKeyPrefix: "near_app" });
          if (!wallet.isSignedIn()) {
            await keyStore.clear();
          }
          return wallet;
        }
        /**
         * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}
         *
         * @example
         * ```js
         * // create new MeteorWallet instance (passing in your initialized Near connection)
         * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
         *
         * if(!meteorWallet.isSignedIn()) {
         *   const { accountId } = await meteorWallet.requestSignIn();
         * }
         * ```
         */
        constructor({ near, appKeyPrefix = near.config.contractName ?? "default" }) {
          this._initializationPromises = [];
          this._near = near;
          const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
          this._authDataKey = authDataKey;
          this._authData = localStorageAdapter.getJson(authDataKey) ?? { allKeys: [] };
          this._networkId = near.config.networkId;
          this._walletBaseUrl = near.config.walletUrl;
          this._keyStore = near.connection.signer.keyStore;
        }
        /* async initialize() {
           await Promise.all(this._initializationPromises);
         }*/
        isExtensionInstalled() {
          return window.meteorWallet != null;
        }
        /**
         * Returns true, if this app is authorized with an account in the wallet.
         * @example
         * ```js
         * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
         * wallet.isSignedIn();
         * ```
         */
        isSignedIn() {
          return !!this._authData.accountId;
        }
        /**
         * Returns authorized Account ID.
         * @example
         * ```js
         * const wallet = new MeteorWallet(near, 'my-app');
         * const accountId = wallet.getAccountId();
         * ```
         */
        getAccountId() {
          return this._authData.accountId;
        }
        /**
         * Verifies that the user is the owner of a specific Near account, available in the wallet.
         * Removes the need to do blockchain operations for simple Dapp actions.
         * Signs a payload with the wallet's private key. Will return a promise with a payload like so:
         *
         * ```ts
         * interface VerifiedOwner {
         *   accountId: string;
         *   message: string;                 // The same passed message, unencrypted
         *   blockId: string;
         *   publicKey: string;               // The public key which should be verified as belonging to this account
         *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this "signature" property)
         *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package
         * }
         * ```
         *
         * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.
         * */
        async verifyOwner(options) {
          const accountId = options.accountId ?? this.getAccountId();
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.verify_owner,
            inputs: {
              accountId,
              message: options.message
            },
            network: this._networkId
          });
          if (response.success) {
            return response;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the
         * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.
         * */
        async requestSignIn(options) {
          const { keyPair, ...restOptions } = options;
          const accessKey = keyPair ?? near_api_js_1.KeyPair.fromRandom("ed25519");
          let usingPublicKey = accessKey.getPublicKey().toString();
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.login,
            inputs: { public_key: usingPublicKey, ...restOptions },
            network: this._networkId
          });
          if (response.success) {
            const { allKeys, accountId } = response.payload;
            this._authData = {
              accountId,
              allKeys,
              signedInContract: {
                contract_id: restOptions.contract_id,
                public_key: usingPublicKey
              }
            };
            localStorageAdapter.setJson(this._authDataKey, this._authData);
            await this._keyStore.setKey(this._networkId, accountId, accessKey);
            return {
              success: true,
              endTags: [],
              payload: {
                accessKey,
                accountId
              }
            };
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Sign out from the current account
         */
        async signOut() {
          const accountId = this.getAccountId();
          if (this._authData.signedInContract != null && accountId != null) {
            const inputs = {
              accountId,
              contractInfo: this._authData.signedInContract
            };
            const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
              actionType: types_dappConnect_1.EExternalActionType.logout,
              inputs,
              network: this._networkId
            });
          }
          this._authData = { allKeys: [] };
          localStorageAdapter.clear(this._authDataKey);
        }
        /**
         * Allows users to sign a message for a specific recipient using their NEAR account, based on the [NEP413](https://github.com/near/NEPs/pull/413).
         *
         * Will return a promise with a payload like so:
         *
         * ```ts
         * interface signMessage {
         *   accountId: string;               // The account name to which the publicKey corresponds as plain text
         *   publicKey: string;               // The public counterpart of the key used to sign
         *   signature: string;               // The base64 representation of the signature
         *   state?: string;                  // The same state passed in.
         * }
         * ```
         *
         * or throw a {@link MeteorActionError} error if the signing failed for whatever reason.
         * */
        async signMessage({ message, nonce, recipient, callbackUrl, state, accountId }) {
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.sign_message,
            inputs: {
              message,
              nonce,
              recipient,
              callbackUrl,
              state,
              accountId
            },
            network: this._networkId
          });
          if (response.success) {
            response.payload.state = state;
            return response;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`
         * of the given transactions.
         * */
        async requestSignTransactions(inputs) {
          const { transactions: transactions4 } = inputs;
          const transformedTransactions = await this.transformTransactions(transactions4);
          console.log("Transformed transactions", transformedTransactions);
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.sign,
            inputs: {
              transactions: transformedTransactions.map((transaction) => (0, borsh_1.serialize)(TransactionSchemaV2_1.SCHEMA_V2, transaction)).map((serialized) => Buffer.from(serialized).toString("base64")).join(",")
            },
            // inputs: { public_key: usingPublicKey, ...options },
            network: this._networkId
          });
          if (response.success) {
            return response.payload.executionOutcomes;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Returns the current connected wallet account
         */
        account() {
          const currentAccountId = this.getAccountId();
          if ((0, StringUtils_1.notNullEmpty)(currentAccountId) && this._connectedAccount?.accountId !== currentAccountId) {
            this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);
          }
          return this._connectedAccount;
        }
        async transformTransactions(transactions4) {
          const account = this.account();
          const { networkId, signer, provider } = account.connection;
          const localKey = await signer.getPublicKey(account.accountId, networkId);
          return Promise.all(transactions4.map(async (transaction, index) => {
            const accessKey = await account.accessKeyForTransaction(localKey);
            if (!accessKey) {
              throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);
            }
            const transformedActions = transaction.actions.map((action) => (0, create_action_1.createAction)(action));
            const block = await provider.block({ finality: "final" });
            return (0, transactions_1.createTransaction)(account.accountId, crypto_1.PublicKey.from(accessKey.public_key), transaction.receiverId, new bn_js_1.BN(accessKey.access_key.nonce).add(new bn_js_1.BN(index)).add(new bn_js_1.BN(1)), transformedActions, near_api_js_1.utils.serialize.base_decode(block.header.hash));
          }));
        }
      };
      exports2.MeteorWallet = MeteorWallet2;
      var ConnectedMeteorWalletAccount = class extends near_api_js_1.Account {
        /** @hidden */
        constructor(walletConnection, connection, accountId) {
          super(connection, accountId);
          this.meteorWallet = walletConnection;
        }
        /**
         * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}
         */
        async signAndSendTransaction(...args) {
          if (typeof args[0] === "string") {
            return this.signAndSendTransaction_direct({
              receiverId: args[0],
              actions: args[1]
            });
          }
          return this.signAndSendTransaction_direct(args[0]);
        }
        /** @hidden */
        async trySendOrCreateTransaction({ receiverId, actions }) {
          const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
          let accessKey = await this.accessKeyForTransaction(localKey);
          if (accessKey != null && accessKey.access_key.permission !== "FullAccess") {
            const accessKeyMatchesTransaction = await this.accessKeyMatchesTransaction(accessKey, receiverId, actions);
            if (!accessKeyMatchesTransaction) {
              return {
                sent: false,
                transaction: {
                  receiverId,
                  signerId: this.accountId,
                  actions
                }
              };
            }
          }
          if (accessKey) {
            if (localKey && localKey.toString() === accessKey.public_key) {
              try {
                return {
                  executionOutcome: await super.signAndSendTransaction({
                    receiverId,
                    actions: actions.map((action) => (0, create_action_1.createAction)(action))
                  }),
                  sent: true
                };
              } catch (e) {
                if (e.type !== "NotEnoughAllowance") {
                  throw e;
                }
              }
            }
          }
          return {
            sent: false,
            transaction: {
              receiverId,
              signerId: this.accountId,
              actions
            }
          };
        }
        /**
         * Sign a transaction using Meteor Wallet
         * @see {@link MeteorWallet.requestSignTransactions}
         */
        async signAndSendTransaction_direct({ receiverId, actions }) {
          const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
          if (sent) {
            return executionOutcome;
          }
          return (await this.meteorWallet.requestSignTransactions({
            transactions: [transaction]
          }))[0];
        }
        /** @hidden */
        /*async signAndSendTransaction_redirect({
            receiverId,
            actions,
            walletMeta,
            walletCallbackUrl = window.location.href,
          }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
            const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
        
            if (sent) {
              return executionOutcome!;
            }
        
            await this.meteorWallet.requestSignTransactions_redirect({
              transactions: [transaction!],
              meta: walletMeta,
              callback_url: walletCallbackUrl,
            });
        
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                reject(new Error("Failed to redirect to sign transaction"));
              }, 1000);
            });
          }*/
        /**
         * Check if given access key allows the function call or method attempted in transaction
         * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
         * @param receiverId The NEAR account attempting to have access
         * @param actions The action(s) needed to be checked for access
         */
        async accessKeyMatchesTransaction(accessKey, receiverId, actions) {
          const { access_key: { permission } } = accessKey;
          if (permission === "FullAccess") {
            return true;
          }
          console.log("Comparing access key and actions", {
            accessKey,
            receiverId,
            actions
          });
          if (permission.FunctionCall) {
            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
            if (allowedReceiverId === receiverId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
              return true;
            }
            if (allowedReceiverId === receiverId) {
              if (actions.length !== 1) {
                return false;
              }
              const firstAction = actions[0];
              console.log(firstAction);
              if (firstAction.type === "FunctionCall") {
                const functionCallParams = firstAction.params;
                return (!functionCallParams.deposit || functionCallParams.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                (allowedMethods.length === 0 || allowedMethods.includes(functionCallParams.methodName));
              }
            }
          }
          return false;
        }
        /**
         * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
         * @param localKey A local public key provided to check for access
         * @returns Promise<any>
         */
        async accessKeyForTransaction(localKey) {
          const accessKeys = await this.getAccessKeys();
          console.log("accessKeys", accessKeys);
          if (localKey) {
            const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
            if (accessKey) {
              return accessKey;
            }
          }
          const walletKeys = this.meteorWallet._authData.allKeys;
          for (const accessKey of accessKeys) {
            if (walletKeys.indexOf(accessKey.public_key) !== -1) {
              return accessKey;
            }
          }
          for (const accessKey of accessKeys) {
            if (accessKey.access_key.permission === "FullAccess") {
              return accessKey;
            }
          }
          return null;
        }
      };
      exports2.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_external/near/types/near_basic_types.js
  var require_near_basic_types = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-common/src/modules_external/near/types/near_basic_types.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ENearNetworkSuffix = exports2.ENearNetwork = void 0;
      var ENearNetwork;
      (function(ENearNetwork2) {
        ENearNetwork2["localnet"] = "localnet";
        ENearNetwork2["testnet"] = "testnet";
        ENearNetwork2["betanet"] = "betanet";
        ENearNetwork2["mainnet"] = "mainnet";
      })(ENearNetwork = exports2.ENearNetwork || (exports2.ENearNetwork = {}));
      var ENearNetworkSuffix;
      (function(ENearNetworkSuffix2) {
        ENearNetworkSuffix2["testnet"] = ".testnet";
        ENearNetworkSuffix2["mainnet"] = ".near";
      })(ENearNetworkSuffix = exports2.ENearNetworkSuffix || (exports2.ENearNetworkSuffix = {}));
    }
  });

  // node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/index.js
  var require_src2 = __commonJS({
    "node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setEnvConfig = exports2.ENearNetwork = void 0;
      __exportStar(require_MeteorWallet(), exports2);
      __exportStar(require_MeteorSdkUtils(), exports2);
      __exportStar(require_MeteorWalletConstants(), exports2);
      __exportStar(require_types_dappConnect(), exports2);
      var near_basic_types_1 = require_near_basic_types();
      Object.defineProperty(exports2, "ENearNetwork", { enumerable: true, get: function() {
        return near_basic_types_1.ENearNetwork;
      } });
      var envConfig_1 = require_envConfig();
      Object.defineProperty(exports2, "setEnvConfig", { enumerable: true, get: function() {
        return envConfig_1.setEnvConfig;
      } });
    }
  });

  // node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs
  var require_exponential_backoff3 = __commonJS({
    "node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var exponential_backoff_exports = {};
      __export2(exponential_backoff_exports, {
        exponentialBackoff: () => exponentialBackoff2
      });
      module2.exports = __toCommonJS2(exponential_backoff_exports);
      async function exponentialBackoff2(startWaitTime, retryNumber, waitBackoff, getResult) {
        let waitTime = startWaitTime;
        for (let i = 0; i < retryNumber; i++) {
          const result = await getResult();
          if (result) {
            return result;
          }
          await sleep(waitTime);
          waitTime *= waitBackoff;
        }
        return null;
      }
      function sleep(millis) {
        return new Promise((resolve5) => setTimeout(resolve5, millis));
      }
    }
  });

  // node_modules/exponential-backoff/dist/options.js
  var require_options = __commonJS({
    "node_modules/exponential-backoff/dist/options.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var defaultOptions = {
        delayFirstAttempt: false,
        jitter: "none",
        maxDelay: Infinity,
        numOfAttempts: 10,
        retry: function() {
          return true;
        },
        startingDelay: 100,
        timeMultiple: 2
      };
      function getSanitizedOptions(options) {
        var sanitized = __assign(__assign({}, defaultOptions), options);
        if (sanitized.numOfAttempts < 1) {
          sanitized.numOfAttempts = 1;
        }
        return sanitized;
      }
      exports2.getSanitizedOptions = getSanitizedOptions;
    }
  });

  // node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
  var require_full_jitter = __commonJS({
    "node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function fullJitter(delay) {
        var jitteredDelay = Math.random() * delay;
        return Math.round(jitteredDelay);
      }
      exports2.fullJitter = fullJitter;
    }
  });

  // node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
  var require_no_jitter = __commonJS({
    "node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function noJitter(delay) {
        return delay;
      }
      exports2.noJitter = noJitter;
    }
  });

  // node_modules/exponential-backoff/dist/jitter/jitter.factory.js
  var require_jitter_factory = __commonJS({
    "node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var full_jitter_1 = require_full_jitter();
      var no_jitter_1 = require_no_jitter();
      function JitterFactory(options) {
        switch (options.jitter) {
          case "full":
            return full_jitter_1.fullJitter;
          case "none":
          default:
            return no_jitter_1.noJitter;
        }
      }
      exports2.JitterFactory = JitterFactory;
    }
  });

  // node_modules/exponential-backoff/dist/delay/delay.base.js
  var require_delay_base = __commonJS({
    "node_modules/exponential-backoff/dist/delay/delay.base.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var jitter_factory_1 = require_jitter_factory();
      var Delay = (
        /** @class */
        (function() {
          function Delay2(options) {
            this.options = options;
            this.attempt = 0;
          }
          Delay2.prototype.apply = function() {
            var _this = this;
            return new Promise(function(resolve5) {
              return setTimeout(resolve5, _this.jitteredDelay);
            });
          };
          Delay2.prototype.setAttemptNumber = function(attempt) {
            this.attempt = attempt;
          };
          Object.defineProperty(Delay2.prototype, "jitteredDelay", {
            get: function() {
              var jitter = jitter_factory_1.JitterFactory(this.options);
              return jitter(this.delay);
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Delay2.prototype, "delay", {
            get: function() {
              var constant = this.options.startingDelay;
              var base3 = this.options.timeMultiple;
              var power = this.numOfDelayedAttempts;
              var delay = constant * Math.pow(base3, power);
              return Math.min(delay, this.options.maxDelay);
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
            get: function() {
              return this.attempt;
            },
            enumerable: true,
            configurable: true
          });
          return Delay2;
        })()
      );
      exports2.Delay = Delay;
    }
  });

  // node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
  var require_skip_first_delay = __commonJS({
    "node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports2 && exports2.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var delay_base_1 = require_delay_base();
      var SkipFirstDelay = (
        /** @class */
        (function(_super) {
          __extends2(SkipFirstDelay2, _super);
          function SkipFirstDelay2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          SkipFirstDelay2.prototype.apply = function() {
            return __awaiter6(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
              });
            });
          };
          Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
            get: function() {
              return this.attempt === 0;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
            get: function() {
              return this.attempt - 1;
            },
            enumerable: true,
            configurable: true
          });
          return SkipFirstDelay2;
        })(delay_base_1.Delay)
      );
      exports2.SkipFirstDelay = SkipFirstDelay;
    }
  });

  // node_modules/exponential-backoff/dist/delay/always/always.delay.js
  var require_always_delay = __commonJS({
    "node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var delay_base_1 = require_delay_base();
      var AlwaysDelay = (
        /** @class */
        (function(_super) {
          __extends2(AlwaysDelay2, _super);
          function AlwaysDelay2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          return AlwaysDelay2;
        })(delay_base_1.Delay)
      );
      exports2.AlwaysDelay = AlwaysDelay;
    }
  });

  // node_modules/exponential-backoff/dist/delay/delay.factory.js
  var require_delay_factory = __commonJS({
    "node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var skip_first_delay_1 = require_skip_first_delay();
      var always_delay_1 = require_always_delay();
      function DelayFactory(options, attempt) {
        var delay = initDelayClass(options);
        delay.setAttemptNumber(attempt);
        return delay;
      }
      exports2.DelayFactory = DelayFactory;
      function initDelayClass(options) {
        if (!options.delayFirstAttempt) {
          return new skip_first_delay_1.SkipFirstDelay(options);
        }
        return new always_delay_1.AlwaysDelay(options);
      }
    }
  });

  // node_modules/exponential-backoff/dist/backoff.js
  var require_backoff = __commonJS({
    "node_modules/exponential-backoff/dist/backoff.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports2 && exports2.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var options_1 = require_options();
      var delay_factory_1 = require_delay_factory();
      function backOff(request3, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter6(this, void 0, void 0, function() {
          var sanitizedOptions, backOff2;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                sanitizedOptions = options_1.getSanitizedOptions(options);
                backOff2 = new BackOff(request3, sanitizedOptions);
                return [4, backOff2.execute()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      }
      exports2.backOff = backOff;
      var BackOff = (
        /** @class */
        (function() {
          function BackOff2(request3, options) {
            this.request = request3;
            this.options = options;
            this.attemptNumber = 0;
          }
          BackOff2.prototype.execute = function() {
            return __awaiter6(this, void 0, void 0, function() {
              var e_1, shouldRetry;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!!this.attemptLimitReached) return [3, 7];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 4, , 6]);
                    return [4, this.applyDelay()];
                  case 2:
                    _a.sent();
                    return [4, this.request()];
                  case 3:
                    return [2, _a.sent()];
                  case 4:
                    e_1 = _a.sent();
                    this.attemptNumber++;
                    return [4, this.options.retry(e_1, this.attemptNumber)];
                  case 5:
                    shouldRetry = _a.sent();
                    if (!shouldRetry || this.attemptLimitReached) {
                      throw e_1;
                    }
                    return [3, 6];
                  case 6:
                    return [3, 0];
                  case 7:
                    throw new Error("Something went wrong.");
                }
              });
            });
          };
          Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
            get: function() {
              return this.attemptNumber >= this.options.numOfAttempts;
            },
            enumerable: true,
            configurable: true
          });
          BackOff2.prototype.applyDelay = function() {
            return __awaiter6(this, void 0, void 0, function() {
              var delay;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                    return [4, delay.apply()];
                  case 1:
                    _a.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          return BackOff2;
        })()
      );
    }
  });

  // node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs
  var require_fetch_json3 = __commonJS({
    "node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var fetch_json_exports = {};
      __export2(fetch_json_exports, {
        ProviderError: () => ProviderError,
        fetchJsonRpc: () => fetchJsonRpc,
        retryConfig: () => retryConfig
      });
      module2.exports = __toCommonJS2(fetch_json_exports);
      var import_types = require_commonjs();
      var import_exponential_backoff = require_backoff();
      var BACKOFF_MULTIPLIER = 1.5;
      var RETRY_NUMBER = 10;
      var RETRY_DELAY = 0;
      function retryConfig(numOfAttempts = RETRY_NUMBER, timeMultiple = BACKOFF_MULTIPLIER, startingDelay = RETRY_DELAY) {
        return {
          numOfAttempts,
          timeMultiple,
          startingDelay,
          retry: (e) => {
            if ([503, 500, 408].includes(e.cause)) {
              return true;
            }
            if (e.toString().includes("FetchError") || e.toString().includes("Failed to fetch")) {
              return true;
            }
            return false;
          }
        };
      }
      var ProviderError = class extends Error {
        cause;
        constructor(message, options) {
          super(message, options);
          if (options.cause) {
            this.cause = options.cause;
          }
        }
      };
      async function fetchJsonRpc(url, json, headers, retryConfig2) {
        const response = await (0, import_exponential_backoff.backOff)(async () => {
          const res = await fetch(url, {
            method: "POST",
            body: JSON.stringify(json),
            headers: { ...headers, "Content-Type": "application/json" }
          });
          const { ok, status } = res;
          if (status === 500) {
            throw new ProviderError("Internal server error", { cause: status });
          } else if (status === 408) {
            throw new ProviderError("Timeout error", { cause: status });
          } else if (status === 400) {
            throw new ProviderError("Request validation error", { cause: status });
          } else if (status === 503) {
            throw new ProviderError(`${url} unavailable`, { cause: status });
          }
          if (!ok) {
            throw new ProviderError(await res.text(), { cause: status });
          }
          return res;
        }, retryConfig2);
        if (!response) {
          throw new import_types.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${url}.`, "RetriesExceeded");
        }
        return await response.json();
      }
    }
  });

  // node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs
  var require_json_rpc_provider4 = __commonJS({
    "node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var json_rpc_provider_exports = {};
      __export2(json_rpc_provider_exports, {
        JsonRpcProvider: () => JsonRpcProvider3
      });
      module2.exports = __toCommonJS2(json_rpc_provider_exports);
      var import_utils = require_commonjs2();
      var import_types = require_commonjs();
      var import_transactions = require_commonjs4();
      var import_fetch_json = require_fetch_json3();
      var REQUEST_RETRY_NUMBER = 12;
      var REQUEST_RETRY_WAIT = 500;
      var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
      var _nextId = 123;
      var DEFAULT_FINALITY = "optimistic";
      var JsonRpcProvider3 = class {
        /** @hidden */
        connection;
        /** @hidden */
        options;
        /** @hidden */
        networkId;
        /**
         * @param connectionInfo Connection info
         */
        constructor(connectionInfo, options) {
          this.connection = connectionInfo || { url: "" };
          const defaultOptions = {
            retries: REQUEST_RETRY_NUMBER,
            wait: REQUEST_RETRY_WAIT,
            backoff: REQUEST_RETRY_WAIT_BACKOFF
          };
          this.options = Object.assign({}, defaultOptions, options);
          this.networkId = void 0;
        }
        async getNetworkId() {
          if (this.networkId) return this.networkId;
          const { chain_id } = await this.viewNodeStatus();
          this.networkId = chain_id;
          return this.networkId;
        }
        async getCurrentEpochSeatPrice() {
          const { minimum_stake_ratio: minStakeRatio, protocol_version: protocolVersion } = await this.experimental_protocolConfig({ finality: DEFAULT_FINALITY });
          const { current_validators: currentValidators } = await this.viewValidators();
          const maxNumberOfSeats = 300;
          return (0, import_utils.findSeatPrice)(currentValidators, maxNumberOfSeats, minStakeRatio, protocolVersion);
        }
        async getNextEpochSeatPrice() {
          const { minimum_stake_ratio: minStakeRatio, protocol_version: protocolVersion } = await this.experimental_protocolConfig({ finality: DEFAULT_FINALITY });
          const { next_validators: nextValidators } = await this.viewValidators();
          const maxNumberOfSeats = 300;
          return (0, import_utils.findSeatPrice)(nextValidators, maxNumberOfSeats, minStakeRatio, protocolVersion);
        }
        async viewAccessKey(accountId, publicKey, finalityQuery = { finality: DEFAULT_FINALITY }) {
          const data7 = await this.query({
            ...finalityQuery,
            request_type: "view_access_key",
            account_id: accountId,
            public_key: publicKey.toString()
          });
          return {
            ...data7,
            nonce: BigInt(data7.nonce)
          };
        }
        async viewAccessKeyList(accountId, finalityQuery = { finality: DEFAULT_FINALITY }) {
          return this.query({
            ...finalityQuery,
            request_type: "view_access_key_list",
            account_id: accountId
          });
        }
        async viewAccount(accountId, blockQuery = { finality: DEFAULT_FINALITY }) {
          const data7 = await this.query({
            ...blockQuery,
            request_type: "view_account",
            account_id: accountId
          });
          return {
            ...data7,
            amount: BigInt(data7.amount),
            locked: BigInt(data7.locked)
          };
        }
        async viewContractCode(contractId, blockQuery = { finality: DEFAULT_FINALITY }) {
          const data7 = await this.query({
            ...blockQuery,
            request_type: "view_code",
            account_id: contractId
          });
          return {
            ...data7,
            code: new Uint8Array(Buffer.from(data7.code_base64, "base64"))
          };
        }
        async viewContractState(contractId, prefix, blockQuery = { finality: DEFAULT_FINALITY }) {
          const prefixBase64 = Buffer.from(prefix || "").toString("base64");
          return this.query({
            ...blockQuery,
            request_type: "view_state",
            account_id: contractId,
            prefix_base64: prefixBase64
          });
        }
        async callFunction(contractId, method2, args, blockQuery = { finality: DEFAULT_FINALITY }) {
          const { result } = await this.callFunctionRaw(
            contractId,
            method2,
            args,
            blockQuery
          );
          if (result.length === 0) return void 0;
          const serializedResult = Buffer.from(result).toString();
          try {
            return JSON.parse(serializedResult);
          } catch {
            return serializedResult;
          }
        }
        async callFunctionRaw(contractId, method2, args, blockQuery = { finality: DEFAULT_FINALITY }) {
          const argsBuffer = ArrayBuffer.isView(args) ? Buffer.from(args) : Buffer.from(JSON.stringify(args));
          const argsBase64 = argsBuffer.toString("base64");
          return await this.query({
            ...blockQuery,
            request_type: "call_function",
            account_id: contractId,
            method_name: method2,
            args_base64: argsBase64
          });
        }
        async viewBlock(blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("block", { block_id: blockId, finality });
        }
        async viewChunk(chunkId) {
          return this.sendJsonRpc("chunk", [chunkId]);
        }
        async viewGasPrice(blockId) {
          return this.sendJsonRpc("gas_price", [blockId || null]);
        }
        async viewNodeStatus() {
          return this.sendJsonRpc("status", []);
        }
        async viewValidators(blockId) {
          return this.sendJsonRpc("validators", [blockId || null]);
        }
        /**
         * Query validators of an epoch.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param params Object specifying either a block or epoch to query.
         * - `{ blockId }`: Block hash or height.
         * - `{ epochId }`: Epoch hash.
         * - `null`: Current epoch.
         */
        async viewValidatorsV2(params) {
          if (params === null) return this.sendJsonRpc("validators", [null]);
          if (typeof params === "object" && "blockId" in params) return this.sendJsonRpc("validators", { block_id: params.blockId });
          if (typeof params === "object" && "epochId" in params) return this.sendJsonRpc("validators", { epoch_id: params.epochId });
          throw new Error("Invalid parameters for validatorsV2");
        }
        async viewTransactionStatus(txHash, accountId, waitUntil) {
          const encodedTxHash = typeof txHash === "string" ? txHash : (0, import_utils.baseEncode)(txHash);
          return this.sendJsonRpc("tx", {
            tx_hash: encodedTxHash,
            sender_account_id: accountId,
            wait_until: waitUntil
          });
        }
        async viewTransactionStatusWithReceipts(txHash, accountId, waitUntil) {
          const encodedTxHash = typeof txHash === "string" ? txHash : (0, import_utils.baseEncode)(txHash);
          return this.sendJsonRpc("EXPERIMENTAL_tx_status", {
            tx_hash: encodedTxHash,
            sender_account_id: accountId,
            wait_until: waitUntil
          });
        }
        async viewTransactionReceipt(receiptId) {
          return this.sendJsonRpc("EXPERIMENTAL_receipt", {
            receipt_id: receiptId
          });
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        async status() {
          return this.sendJsonRpc("status", []);
        }
        /**
         * Sends a signed transaction to the RPC
         *
         * @param signedTransaction The signed transaction being sent
         * @param waitUntil
         */
        async sendTransactionUntil(signedTransaction, waitUntil) {
          const bytes = (0, import_transactions.encodeTransaction)(signedTransaction);
          return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes).toString("base64"), wait_until: waitUntil });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        async sendTransaction(signedTransaction) {
          return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async sendTransactionAsync(signedTransaction) {
          return this.sendTransactionUntil(signedTransaction, "NONE");
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         */
        async txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          if (typeof txHash === "string") {
            return this.txStatusString(txHash, accountId, waitUntil);
          } else {
            return this.txStatusUint8Array(txHash, accountId, waitUntil);
          }
        }
        async txStatusUint8Array(txHash, accountId, waitUntil) {
          return this.sendJsonRpc("tx", { tx_hash: (0, import_utils.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
        }
        async txStatusString(txHash, accountId, waitUntil) {
          return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          if (typeof txHash === "string") {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
          } else {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, import_utils.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
          }
        }
        /**
         * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
         * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
         *
         * @typeParam T the shape of the returned query response
         */
        async query(...args) {
          let result;
          if (args.length === 1) {
            const { block_id, blockId, ...otherParams } = args[0];
            result = await this.sendJsonRpc("query", { ...otherParams, block_id: block_id || blockId });
          } else {
            const [path7, data7] = args;
            result = await this.sendJsonRpc("query", [path7, data7]);
          }
          if (result && result.error) {
            throw new import_types.TypedError(
              `Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`,
              (0, import_utils.getErrorTypeFromErrorMessage)(result.error, result.error.name)
            );
          }
          return result;
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        async block(blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("block", { block_id: blockId, finality });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        async blockChanges(blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        async chunk(chunkId) {
          return this.sendJsonRpc("chunk", [chunkId]);
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async validators(blockId) {
          return this.sendJsonRpc("validators", [blockId]);
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        async experimental_protocolConfig(blockReference) {
          const { blockId, ...otherParams } = blockReference;
          return await this.sendJsonRpc("EXPERIMENTAL_protocol_config", { ...otherParams, block_id: blockId });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        async lightClientProof(request3) {
          return await this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request3);
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         * 
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        async nextLightClientBlock(request3) {
          return await this.sendJsonRpc("next_light_client_block", request3);
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        async accessKeyChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "all_access_key_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        async singleAccessKeyChanges(accessKeyArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "single_access_key_changes",
            keys: accessKeyArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        async accountChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "account_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "data_changes",
            account_ids: accountIdArray,
            key_prefix_base64: keyPrefix,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractCodeChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "contract_code_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async gasPrice(blockId) {
          return await this.sendJsonRpc("gas_price", [blockId]);
        }
        /**
         * Directly call the RPC specifying the method and params
         *
         * @param method RPC method
         * @param params Parameters to the method
         */
        async sendJsonRpc(method2, params) {
          const request3 = {
            method: method2,
            params,
            id: _nextId++,
            jsonrpc: "2.0"
          };
          const response = await (0, import_fetch_json.fetchJsonRpc)(this.connection.url, request3, this.connection.headers || {}, (0, import_fetch_json.retryConfig)(this.options.retries, this.options.backoff, this.options.wait));
          if (response.error) {
            if (typeof response.error.data === "object") {
              if (typeof response.error.data.error_message === "string" && typeof response.error.data.error_type === "string") {
                throw new import_types.TypedError(response.error.data.error_message, response.error.data.error_type);
              }
              throw (0, import_utils.parseRpcError)(response.error.data);
            } else {
              const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;
              const errorType = (0, import_utils.getErrorTypeFromErrorMessage)(response.error.data, "");
              if (errorType) {
                throw new import_types.TypedError((0, import_utils.formatError)(errorType, params), errorType);
              }
              throw new import_types.TypedError(errorMessage, response.error.name);
            }
          } else if (typeof response.result?.error === "string") {
            const errorType = (0, import_utils.getErrorTypeFromErrorMessage)(response.result.error, "");
            if (errorType) {
              throw new import_utils.ServerError((0, import_utils.formatError)(errorType, params), errorType);
            }
          }
          const { result } = response;
          if (typeof result === "undefined") {
            throw new import_types.TypedError(
              `Exceeded ${this.options.retries} attempts for request to ${method2}.`,
              "RetriesExceeded"
            );
          }
          return result;
        }
      };
    }
  });

  // node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs
  var require_failover_rpc_provider4 = __commonJS({
    "node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var failover_rpc_provider_exports = {};
      __export2(failover_rpc_provider_exports, {
        FailoverRpcProvider: () => FailoverRpcProvider2
      });
      module2.exports = __toCommonJS2(failover_rpc_provider_exports);
      var import_utils = require_commonjs2();
      var import_types = require_commonjs();
      var FailoverRpcProvider2 = class {
        /** @hidden */
        providers;
        currentProviderIndex;
        /**
         * @param providers list of providers
         */
        constructor(providers4) {
          if (providers4.length === 0) {
            throw new Error("At least one provider must be specified");
          }
          this.providers = providers4;
          this.currentProviderIndex = 0;
        }
        switchToNextProvider() {
          if (this.providers.length === 1) return;
          if (this.providers.length - 1 <= this.currentProviderIndex) {
            this.currentProviderIndex = 0;
          } else {
            this.currentProviderIndex += 1;
          }
          import_utils.Logger.debug(
            `Switched to provider at the index ${this.currentProviderIndex}`
          );
        }
        get currentProvider() {
          const provider = this.providers[this.currentProviderIndex];
          if (!provider)
            throw new Error(
              `Provider wasn't found at index ${this.currentProviderIndex}`
            );
          return provider;
        }
        async withBackoff(getResult) {
          for (let i = 0; i < this.providers.length; i++) {
            try {
              const result = await getResult(this.currentProvider);
              if (typeof result === "undefined") continue;
              return result;
            } catch (e) {
              console.error(e);
              this.switchToNextProvider();
            }
          }
          throw new import_types.TypedError(
            `Exceeded ${this.providers.length} providers to execute request`,
            "RetriesExceeded"
          );
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        async status() {
          return this.withBackoff((currentProvider) => currentProvider.status());
        }
        async getNetworkId() {
          return this.withBackoff((currentProvider) => currentProvider.getNetworkId());
        }
        async getCurrentEpochSeatPrice() {
          return this.withBackoff((currentProvider) => currentProvider.getCurrentEpochSeatPrice());
        }
        async getNextEpochSeatPrice() {
          return this.withBackoff((currentProvider) => currentProvider.getNextEpochSeatPrice());
        }
        async viewAccessKey(accountId, publicKey, finalityQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewAccessKey(accountId, publicKey, finalityQuery));
        }
        async viewAccessKeyList(accountId, finalityQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewAccessKeyList(accountId, finalityQuery));
        }
        async viewAccount(accountId, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewAccount(accountId, blockQuery));
        }
        async viewContractCode(accountId, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewContractCode(accountId, blockQuery));
        }
        async viewContractState(accountId, prefix, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewContractState(accountId, prefix, blockQuery));
        }
        async callFunction(accountId, method2, args, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.callFunction(accountId, method2, args, blockQuery));
        }
        async callFunctionRaw(accountId, method2, args, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.callFunctionRaw(accountId, method2, args, blockQuery));
        }
        async viewBlock(blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.viewBlock(blockQuery));
        }
        async viewChunk(chunkId) {
          return this.withBackoff((currentProvider) => currentProvider.viewChunk(chunkId));
        }
        async viewGasPrice(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.viewGasPrice(blockId));
        }
        async viewNodeStatus() {
          return this.withBackoff((currentProvider) => currentProvider.viewNodeStatus());
        }
        async viewValidators(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.viewValidators(blockId));
        }
        async viewValidatorsV2(params) {
          return this.withBackoff((currentProvider) => currentProvider.viewValidatorsV2(params));
        }
        async viewTransactionStatus(txHash, accountId, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.viewTransactionStatus(txHash, accountId, waitUntil));
        }
        async viewTransactionStatusWithReceipts(txHash, accountId, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.viewTransactionStatusWithReceipts(txHash, accountId, waitUntil));
        }
        async viewTransactionReceipt(receiptId) {
          return this.withBackoff((currentProvider) => currentProvider.viewTransactionReceipt(receiptId));
        }
        async sendTransactionUntil(signedTransaction, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        async sendTransaction(signedTransaction) {
          return this.withBackoff(
            (currentProvider) => currentProvider.sendTransaction(signedTransaction)
          );
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async sendTransactionAsync(signedTransaction) {
          return this.withBackoff(
            (currentProvider) => currentProvider.sendTransactionAsync(signedTransaction)
          );
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         */
        async txStatus(txHash, accountId, waitUntil) {
          return this.withBackoff(
            (currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil)
          );
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async txStatusReceipts(txHash, accountId, waitUntil) {
          return this.withBackoff(
            (currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil)
          );
        }
        async query(paramsOrPath, data7) {
          if (data7) {
            return this.withBackoff(
              (currentProvider) => currentProvider.query(paramsOrPath, data7)
            );
          }
          return this.withBackoff(
            (currentProvider) => currentProvider.query(paramsOrPath)
          );
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        async block(blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        async blockChanges(blockQuery) {
          return this.withBackoff(
            (currentProvider) => currentProvider.blockChanges(blockQuery)
          );
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        async chunk(chunkId) {
          return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async validators(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        async experimental_protocolConfig(blockReference) {
          return this.withBackoff(
            (currentProvider) => currentProvider.experimental_protocolConfig(blockReference)
          );
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        async lightClientProof(request3) {
          return this.withBackoff(
            (currentProvider) => currentProvider.lightClientProof(request3)
          );
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        async nextLightClientBlock(request3) {
          return this.withBackoff(
            (currentProvider) => currentProvider.nextLightClientBlock(request3)
          );
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        async accessKeyChanges(accountIdArray, blockQuery) {
          return this.withBackoff(
            (currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery)
          );
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        async singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return this.withBackoff(
            (currentProvider) => currentProvider.singleAccessKeyChanges(
              accessKeyArray,
              blockQuery
            )
          );
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        async accountChanges(accountIdArray, blockQuery) {
          return this.withBackoff(
            (currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery)
          );
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return this.withBackoff(
            (currentProvider) => currentProvider.contractStateChanges(
              accountIdArray,
              blockQuery,
              keyPrefix
            )
          );
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractCodeChanges(accountIdArray, blockQuery) {
          return this.withBackoff(
            (currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery)
          );
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async gasPrice(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
        }
      };
    }
  });

  // node_modules/@near-js/providers/lib/commonjs/index.cjs
  var require_commonjs5 = __commonJS({
    "node_modules/@near-js/providers/lib/commonjs/index.cjs"(exports2, module2) {
      "use strict";
      init_process();
      init_buffer();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all5) => {
        for (var name in all5)
          __defProp2(target, name, { get: all5[name], enumerable: true });
      };
      var __copyProps2 = (to, from5, except, desc) => {
        if (from5 && typeof from5 === "object" || typeof from5 === "function") {
          for (let key of __getOwnPropNames2(from5))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc2(from5, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var index_exports = {};
      __export2(index_exports, {
        FailoverRpcProvider: () => import_failover_rpc_provider.FailoverRpcProvider,
        JsonRpcProvider: () => import_json_rpc_provider.JsonRpcProvider,
        exponentialBackoff: () => import_exponential_backoff.exponentialBackoff
      });
      module2.exports = __toCommonJS2(index_exports);
      var import_exponential_backoff = require_exponential_backoff3();
      var import_json_rpc_provider = require_json_rpc_provider4();
      var import_failover_rpc_provider = require_failover_rpc_provider4();
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/constants.cjs
  var require_constants15 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/constants.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeySize = exports2.KeyType = void 0;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
        KeyType2[KeyType2["SECP256K1"] = 1] = "SECP256K1";
      })(KeyType || (exports2.KeyType = KeyType = {}));
      exports2.KeySize = {
        SECRET_KEY: 32,
        ED25519_PUBLIC_KEY: 32,
        SECP256k1_PUBLIC_KEY: 64
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs
  var require_key_pair_base8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairBase = void 0;
      var KeyPairBase = class {
      };
      exports2.KeyPairBase = KeyPairBase;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/constants.cjs
  var require_constants16 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/constants.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = 30000000000000n;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/error_messages.json
  var require_error_messages7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed",
        ShardCongested: "Shard {{shard_id}} rejected the transaction due to congestion level {{congestion_level}}, try again later",
        ShardStuck: "Shard {{shard_id}} rejected the transaction because it missed {{missed_chunks}} chunks and needs to recover before accepting new transactions, try again later"
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/errors.cjs
  var require_errors22 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/errors.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorMessages = void 0;
      var error_messages_json_1 = __importDefault(require_error_messages7());
      exports2.ErrorMessages = error_messages_json_1.default;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/assignable.cjs
  var require_assignable8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/assignable.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/enum.cjs
  var require_enum2 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/enum.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Enum = void 0;
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Enum = Enum;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/errors.cjs
  var require_errors23 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/errors.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        type;
        context;
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        transactionHash;
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs
  var require_light_client8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 || (exports2.IdType = IdType2 = {}));
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/response.cjs
  var require_response8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/response.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 || (exports2.ExecutionStatusBasic = ExecutionStatusBasic2 = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 || (exports2.FinalExecutionStatusBasic = FinalExecutionStatusBasic2 = {}));
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/index.cjs
  var require_provider17 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/provider/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client8();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response8();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/index.cjs
  var require_commonjs6 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/types/lib/commonjs/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable8(), exports2);
      __exportStar(require_enum2(), exports2);
      __exportStar(require_errors23(), exports2);
      __exportStar(require_provider17(), exports2);
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/format.cjs
  var require_format8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/format.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var base_1 = require_lib31();
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = 10n ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = 10n;
      for (let i = 0, offset = 5n; i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return base_1.base58.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return base_1.base58.decode(value);
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/rpc_error_schema.json
  var require_rpc_error_schema7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              forwarded_buffered_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_buffered_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded",
              "StorageError",
              "ShardCongested",
              "ShardStuck"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptSizeExceeded: {
            name: "ReceiptSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation",
              "ReceiptSizeExceeded"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          ShardCongested: {
            name: "ShardCongested",
            subtypes: [],
            props: {
              congestion_level: "",
              shard_id: ""
            }
          },
          ShardStuck: {
            name: "ShardStuck",
            subtypes: [],
            props: {
              missed_chunks: "",
              shard_id: ""
            }
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/rpc_errors.cjs
  var require_rpc_errors8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/rpc_errors.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_commonjs6();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format8();
      var errors_1 = require_errors22();
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema7());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
        transaction_outcome;
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof errors_1.ErrorMessages[errorClassName] === "string") {
          return mustache_1.default.render(errors_1.ErrorMessages[errorClassName], {
            ...errorData,
            ...mustacheHelpers
          });
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/index.cjs
  var require_errors24 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/errors/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.ErrorMessages = void 0;
      var errors_1 = require_errors22();
      Object.defineProperty(exports2, "ErrorMessages", { enumerable: true, get: function() {
        return errors_1.ErrorMessages;
      } });
      var rpc_errors_1 = require_rpc_errors8();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/console.logger.cjs
  var require_console_logger7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/console.logger.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        logLevels;
        constructor(logLevels) {
          this.logLevels = logLevels;
        }
        isLevelEnabled = (level) => {
          return this.logLevels.includes(level);
        };
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/logger.cjs
  var require_logger14 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/logger.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger7();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static instanceRef = DEFAULT_LOGGER;
        static overrideLogger = (logger2) => {
          this.instanceRef = logger2;
        };
        static error(message, ...optionalParams) {
          this.instanceRef?.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          this.instanceRef?.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          this.instanceRef?.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          this.instanceRef?.debug?.(message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          this.instanceRef?.verbose?.(message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          this.instanceRef?.fatal?.(message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/index.cjs
  var require_logger15 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logger/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = exports2.ConsoleLogger = void 0;
      var console_logger_1 = require_console_logger7();
      Object.defineProperty(exports2, "ConsoleLogger", { enumerable: true, get: function() {
        return console_logger_1.ConsoleLogger;
      } });
      var logger_1 = require_logger14();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logging.cjs
  var require_logging7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/logging.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors24();
      var logger_1 = require_logger15();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/provider.cjs
  var require_provider18 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/provider.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/utils.cjs
  var require_utils34 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/utils.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/validators.cjs
  var require_validators8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/validators.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils34();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = 1n, right = stakesSum + 1n;
        while (left !== right - 1n) {
          const mid = (left + right) / 2n;
          let found = false;
          let currentSum = 0n;
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + 1n;
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/index.cjs
  var require_commonjs7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/node_modules/@near-js/utils/lib/commonjs/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants16(), exports2);
      __exportStar(require_errors24(), exports2);
      __exportStar(require_format8(), exports2);
      __exportStar(require_logging7(), exports2);
      __exportStar(require_provider18(), exports2);
      __exportStar(require_validators8(), exports2);
      __exportStar(require_logger15(), exports2);
      __exportStar(require_utils34(), exports2);
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/public_key.cjs
  var require_public_key8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/public_key.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = void 0;
      var utils_1 = require_commonjs7();
      var ed25519_1 = require_ed255197();
      var secp256k1_1 = __importDefault(require_elliptic3());
      var constants_1 = require_constants15();
      function key_type_to_str(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          case constants_1.KeyType.SECP256K1:
            return "secp256k1";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          case "secp256k1":
            return constants_1.KeyType.SECP256K1;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function resolveEnumKeyName(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519: {
            return "ed25519Key";
          }
          case constants_1.KeyType.SECP256K1: {
            return "secp256k1Key";
          }
          default: {
            throw Error(`unknown type ${keyType}`);
          }
        }
      }
      var Enum = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      var PublicKey = class _PublicKey extends Enum {
        enum;
        ed25519Key;
        secp256k1Key;
        constructor(publicKey) {
          const keyName = resolveEnumKeyName(publicKey.keyType);
          super({ [keyName]: publicKey });
          this[keyName] = publicKey;
          this.enum = keyName;
        }
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (!keyType) {
            keyType = decodedPublicKey.length === constants_1.KeySize.SECP256k1_PUBLIC_KEY ? constants_1.KeyType.SECP256K1 : constants_1.KeyType.ED25519;
          }
          const keySize = keyType === constants_1.KeyType.ED25519 ? constants_1.KeySize.ED25519_PUBLIC_KEY : constants_1.KeySize.SECP256k1_PUBLIC_KEY;
          if (decodedPublicKey.length !== keySize) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${keySize}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          const encodedKey = (0, utils_1.baseEncode)(this.data);
          return `${key_type_to_str(this.keyType)}:${encodedKey}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          const keyType = this.keyType;
          const data7 = this.data;
          switch (keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, data7);
            case constants_1.KeyType.SECP256K1:
              return secp256k1_1.default.ecdsaVerify(signature.subarray(0, 64), message, new Uint8Array([4, ...data7]));
            default:
              throw new Error(`Unknown key type: ${keyType}`);
          }
        }
        get keyPair() {
          return this.ed25519Key || this.secp256k1Key;
        }
        get keyType() {
          return this.keyPair.keyType;
        }
        get data() {
          return this.keyPair.data;
        }
      };
      exports2.PublicKey = PublicKey;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs
  var require_key_pair_ed255198 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = void 0;
      var utils_1 = require_commonjs7();
      var ed25519_1 = require_ed255197();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants15();
      var key_pair_base_1 = require_key_pair_base8();
      var public_key_1 = require_public_key8();
      var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        publicKey;
        secretKey;
        extendedSecretKey;
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairEd25519 = KeyPairEd25519;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs
  var require_key_pair_secp256k12 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairSecp256k1 = void 0;
      var utils_1 = require_commonjs7();
      var randombytes_1 = __importDefault(require_browser2());
      var secp256k1_1 = __importDefault(require_elliptic3());
      var constants_1 = require_constants15();
      var key_pair_base_1 = require_key_pair_base8();
      var public_key_1 = require_public_key8();
      var KeyPairSecp256k1 = class _KeyPairSecp256k1 extends key_pair_base_1.KeyPairBase {
        publicKey;
        secretKey;
        extendedSecretKey;
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param {string} extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const withHeader = secp256k1_1.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const data7 = withHeader.subarray(1, withHeader.length);
          this.publicKey = new public_key_1.PublicKey({
            keyType: constants_1.KeyType.SECP256K1,
            data: data7
          });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const withHeader = secp256k1_1.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const publicKey = withHeader.subarray(1, withHeader.length);
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairSecp256k1((0, utils_1.baseEncode)(extendedSecretKey));
        }
        sign(message) {
          const { signature, recid } = secp256k1_1.default.ecdsaSign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature: new Uint8Array([...signature, recid]), publicKey: this.publicKey };
        }
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        toString() {
          return `secp256k1:${this.extendedSecretKey}`;
        }
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports2.KeyPairSecp256k1 = KeyPairSecp256k1;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs
  var require_key_pair9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base8();
      var key_pair_ed25519_1 = require_key_pair_ed255198();
      var key_pair_secp256k1_1 = require_key_pair_secp256k12();
      var KeyPair = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            case "SECP256K1":
              return key_pair_secp256k1_1.KeyPairSecp256k1.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              case "SECP256K1":
                return new key_pair_secp256k1_1.KeyPairSecp256k1(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports2.KeyPair = KeyPair;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/index.cjs
  var require_commonjs8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/crypto/lib/commonjs/index.cjs"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKey = exports2.KeyPairSecp256k1 = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.KeyType = void 0;
      var constants_1 = require_constants15();
      Object.defineProperty(exports2, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair9();
      Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed255198();
      Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var key_pair_secp256k1_1 = require_key_pair_secp256k12();
      Object.defineProperty(exports2, "KeyPairSecp256k1", { enumerable: true, get: function() {
        return key_pair_secp256k1_1.KeyPairSecp256k1;
      } });
      var public_key_1 = require_public_key8();
      Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/js-sha256/src/sha256.js
  var require_sha2566 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/js-sha256/src/sha256.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function() {
        "use strict";
        var ERROR2 = "input is invalid type";
        var WINDOW2 = typeof window === "object";
        var root3 = WINDOW2 ? window : {};
        if (root3.JS_SHA256_NO_WINDOW) {
          WINDOW2 = false;
        }
        var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
        var NODE_JS2 = !root3.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node && process.type != "renderer";
        if (NODE_JS2) {
          root3 = globalThis;
        } else if (WEB_WORKER2) {
          root3 = self;
        }
        var COMMON_JS2 = !root3.JS_SHA256_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD2 = typeof define === "function" && define.amd;
        var ARRAY_BUFFER3 = !root3.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS2 = "0123456789abcdef".split("");
        var EXTRA2 = [-2147483648, 8388608, 32768, 128];
        var SHIFT2 = [24, 16, 8, 0];
        var K2 = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES2 = ["hex", "array", "digest", "arrayBuffer"];
        var blocks2 = [];
        if (root3.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER3 && (root3.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod2 = function(outputType, is2242) {
          return function(message) {
            return new Sha2562(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod8 = function(is2242) {
          var method2 = createOutputMethod2("hex", is2242);
          if (NODE_JS2) {
            method2 = nodeWrap2(method2, is2242);
          }
          method2.create = function() {
            return new Sha2562(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
            var type = OUTPUT_TYPES2[i];
            method2[type] = createOutputMethod2(type, is2242);
          }
          return method2;
        };
        var nodeWrap2 = function(method2, is2242) {
          var crypto2 = require_crypto9();
          var Buffer3 = require_buffer().Buffer;
          var algorithm2 = is2242 ? "sha224" : "sha256";
          var bufferFrom;
          if (Buffer3.from && !root3.JS_SHA256_NO_BUFFER_FROM) {
            bufferFrom = Buffer3.from;
          } else {
            bufferFrom = function(message) {
              return new Buffer3(message);
            };
          }
          var nodeMethod2 = function(message) {
            if (typeof message === "string") {
              return crypto2.createHash(algorithm2).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR2);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer3) {
              return crypto2.createHash(algorithm2).update(bufferFrom(message)).digest("hex");
            } else {
              return method2(message);
            }
          };
          return nodeMethod2;
        };
        var createHmacOutputMethod2 = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha2562(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod2 = function(is2242) {
          var method2 = createHmacOutputMethod2("hex", is2242);
          method2.create = function(key) {
            return new HmacSha2562(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
            var type = OUTPUT_TYPES2[i];
            method2[type] = createHmacOutputMethod2(type, is2242);
          }
          return method2;
        };
        function Sha2562(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks2[0] = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            this.blocks = blocks2;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha2562.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR2);
              } else if (ARRAY_BUFFER3 && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER3 || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR2);
                }
              }
            } else {
              throw new Error(ERROR2);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks3 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks3[0] = this.block;
              this.block = blocks3[16] = blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks3[i >>> 2] |= message[index] << SHIFT2[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks3[i >>> 2] |= code << SHIFT2[i++ & 3];
                } else if (code < 2048) {
                  blocks3[i >>> 2] |= (192 | code >>> 6) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks3[i >>> 2] |= (224 | code >>> 12) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks3[i >>> 2] |= (240 | code >>> 18) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT2[i++ & 3];
                  blocks3[i >>> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks3[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha2562.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks3 = this.blocks, i = this.lastByteIndex;
          blocks3[16] = this.block;
          blocks3[i >>> 2] |= EXTRA2[i & 3];
          this.block = blocks3[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks3[0] = this.block;
            blocks3[16] = blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = 0;
          }
          blocks3[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks3[15] = this.bytes << 3;
          this.hash();
        };
        Sha2562.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks3 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks3[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks3[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks3[j] = blocks3[j - 16] + s0 + blocks3[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks3[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks3[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K2[j] + blocks3[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K2[j + 1] + blocks3[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K2[j + 2] + blocks3[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K2[j + 3] + blocks3[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
            this.chromeBugWorkAround = true;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha2562.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS2[h0 >>> 28 & 15] + HEX_CHARS2[h0 >>> 24 & 15] + HEX_CHARS2[h0 >>> 20 & 15] + HEX_CHARS2[h0 >>> 16 & 15] + HEX_CHARS2[h0 >>> 12 & 15] + HEX_CHARS2[h0 >>> 8 & 15] + HEX_CHARS2[h0 >>> 4 & 15] + HEX_CHARS2[h0 & 15] + HEX_CHARS2[h1 >>> 28 & 15] + HEX_CHARS2[h1 >>> 24 & 15] + HEX_CHARS2[h1 >>> 20 & 15] + HEX_CHARS2[h1 >>> 16 & 15] + HEX_CHARS2[h1 >>> 12 & 15] + HEX_CHARS2[h1 >>> 8 & 15] + HEX_CHARS2[h1 >>> 4 & 15] + HEX_CHARS2[h1 & 15] + HEX_CHARS2[h2 >>> 28 & 15] + HEX_CHARS2[h2 >>> 24 & 15] + HEX_CHARS2[h2 >>> 20 & 15] + HEX_CHARS2[h2 >>> 16 & 15] + HEX_CHARS2[h2 >>> 12 & 15] + HEX_CHARS2[h2 >>> 8 & 15] + HEX_CHARS2[h2 >>> 4 & 15] + HEX_CHARS2[h2 & 15] + HEX_CHARS2[h3 >>> 28 & 15] + HEX_CHARS2[h3 >>> 24 & 15] + HEX_CHARS2[h3 >>> 20 & 15] + HEX_CHARS2[h3 >>> 16 & 15] + HEX_CHARS2[h3 >>> 12 & 15] + HEX_CHARS2[h3 >>> 8 & 15] + HEX_CHARS2[h3 >>> 4 & 15] + HEX_CHARS2[h3 & 15] + HEX_CHARS2[h4 >>> 28 & 15] + HEX_CHARS2[h4 >>> 24 & 15] + HEX_CHARS2[h4 >>> 20 & 15] + HEX_CHARS2[h4 >>> 16 & 15] + HEX_CHARS2[h4 >>> 12 & 15] + HEX_CHARS2[h4 >>> 8 & 15] + HEX_CHARS2[h4 >>> 4 & 15] + HEX_CHARS2[h4 & 15] + HEX_CHARS2[h5 >>> 28 & 15] + HEX_CHARS2[h5 >>> 24 & 15] + HEX_CHARS2[h5 >>> 20 & 15] + HEX_CHARS2[h5 >>> 16 & 15] + HEX_CHARS2[h5 >>> 12 & 15] + HEX_CHARS2[h5 >>> 8 & 15] + HEX_CHARS2[h5 >>> 4 & 15] + HEX_CHARS2[h5 & 15] + HEX_CHARS2[h6 >>> 28 & 15] + HEX_CHARS2[h6 >>> 24 & 15] + HEX_CHARS2[h6 >>> 20 & 15] + HEX_CHARS2[h6 >>> 16 & 15] + HEX_CHARS2[h6 >>> 12 & 15] + HEX_CHARS2[h6 >>> 8 & 15] + HEX_CHARS2[h6 >>> 4 & 15] + HEX_CHARS2[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS2[h7 >>> 28 & 15] + HEX_CHARS2[h7 >>> 24 & 15] + HEX_CHARS2[h7 >>> 20 & 15] + HEX_CHARS2[h7 >>> 16 & 15] + HEX_CHARS2[h7 >>> 12 & 15] + HEX_CHARS2[h7 >>> 8 & 15] + HEX_CHARS2[h7 >>> 4 & 15] + HEX_CHARS2[h7 & 15];
          }
          return hex;
        };
        Sha2562.prototype.toString = Sha2562.prototype.hex;
        Sha2562.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 & 255,
            h2 >>> 24 & 255,
            h2 >>> 16 & 255,
            h2 >>> 8 & 255,
            h2 & 255,
            h3 >>> 24 & 255,
            h3 >>> 16 & 255,
            h3 >>> 8 & 255,
            h3 & 255,
            h4 >>> 24 & 255,
            h4 >>> 16 & 255,
            h4 >>> 8 & 255,
            h4 & 255,
            h5 >>> 24 & 255,
            h5 >>> 16 & 255,
            h5 >>> 8 & 255,
            h5 & 255,
            h6 >>> 24 & 255,
            h6 >>> 16 & 255,
            h6 >>> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha2562.prototype.array = Sha2562.prototype.digest;
        Sha2562.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha2562(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >>> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >>> 12;
                bytes[index++] = 128 | code >>> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >>> 18;
                bytes[index++] = 128 | code >>> 12 & 63;
                bytes[index++] = 128 | code >>> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR2);
              } else if (ARRAY_BUFFER3 && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER3 || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR2);
                }
              }
            } else {
              throw new Error(ERROR2);
            }
          }
          if (key.length > 64) {
            key = new Sha2562(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha2562.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha2562.prototype = new Sha2562();
        HmacSha2562.prototype.finalize = function() {
          Sha2562.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha2562.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha2562.prototype.finalize.call(this);
          }
        };
        var exports3 = createMethod8();
        exports3.sha256 = exports3;
        exports3.sha224 = createMethod8(true);
        exports3.sha256.hmac = createHmacMethod2();
        exports3.sha224.hmac = createHmacMethod2(true);
        if (COMMON_JS2) {
          module2.exports = exports3;
        } else {
          root3.sha256 = exports3.sha256;
          root3.sha224 = exports3.sha224;
          if (AMD2) {
            define(function() {
              return exports3;
            });
          }
        }
      })();
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/actions.js
  var require_actions5 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/actions.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createAction = exports2.parseArgs = void 0;
      var crypto_1 = require_commonjs8();
      var transactions_1 = require_commonjs4();
      var getAccessKey2 = (permission) => {
        if (permission === "FullAccess") {
          return transactions_1.actionCreators.fullAccessKey();
        }
        const { receiverId, methodNames = [] } = permission;
        const allowance = permission.allowance ? BigInt(permission.allowance) : void 0;
        return transactions_1.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
      };
      var parseArgs = (data7) => {
        if (typeof data7 === "string")
          return Buffer.from(data7, "base64");
        return data7;
      };
      exports2.parseArgs = parseArgs;
      var createAction2 = (action) => {
        switch (action.type) {
          case "CreateAccount":
            return transactions_1.actionCreators.createAccount();
          case "DeployContract": {
            const { code } = action.params;
            return transactions_1.actionCreators.deployContract(code);
          }
          case "FunctionCall": {
            const { methodName, args, gas, deposit } = action.params;
            return transactions_1.actionCreators.functionCall(methodName, (0, exports2.parseArgs)(args), BigInt(gas), BigInt(deposit));
          }
          case "Transfer": {
            const { deposit } = action.params;
            return transactions_1.actionCreators.transfer(BigInt(deposit));
          }
          case "Stake": {
            const { stake, publicKey } = action.params;
            return transactions_1.actionCreators.stake(BigInt(stake), crypto_1.PublicKey.from(publicKey));
          }
          case "AddKey": {
            const { publicKey, accessKey } = action.params;
            return transactions_1.actionCreators.addKey(
              crypto_1.PublicKey.from(publicKey),
              // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
              getAccessKey2(accessKey.permission)
            );
          }
          case "DeleteKey": {
            const { publicKey } = action.params;
            return transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey));
          }
          case "DeleteAccount": {
            const { beneficiaryId } = action.params;
            return transactions_1.actionCreators.deleteAccount(beneficiaryId);
          }
          default:
            throw new Error("Invalid action type");
        }
      };
      exports2.createAction = createAction2;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/base-x/index.js
  var require_base_x7 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/base-x/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = function base3(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode3(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer3.allocUnsafe(0);
          var bytes = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * BASE;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes.push(0);
          }
          return Buffer3.from(bytes.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/bs58/index.js
  var require_bs588 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/bs58/index.js"(exports2, module2) {
      init_process();
      init_buffer();
      var basex = require_base_x7();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/borsh/lib/index.js
  var require_lib34 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/borsh/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs588());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports2.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str) {
          this.maybeResize();
          const b = Buffer.from(str, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array) {
          this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
          this.maybeResize();
          this.writeU32(array.length);
          for (const elem of array) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports2.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports2.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize3(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports2.serialize = serialize3;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map3 = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map3.set(key, val);
            }
            return map3;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports2.deserialize = deserialize2;
      function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports2.deserializeUnchecked = deserializeUnchecked;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/nep0314.js
  var require_nep0314 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/nep0314.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.verifySignature = exports2.authPayloadSchema = exports2.AuthPayload = void 0;
      var borsh = __importStar(require_lib34());
      var js_sha256_1 = __importDefault(require_sha2566());
      var crypto_1 = require_commonjs8();
      var AuthPayload = class {
        constructor({ message, nonce, recipient, callbackUrl }) {
          this.tag = 2147484061;
          this.message = message;
          this.nonce = nonce;
          this.recipient = recipient;
          if (callbackUrl) {
            this.callbackUrl = callbackUrl;
          }
        }
      };
      exports2.AuthPayload = AuthPayload;
      exports2.authPayloadSchema = {
        struct: {
          tag: "u32",
          message: "string",
          nonce: { array: { type: "u8", len: 32 } },
          recipient: "string",
          callbackUrl: { option: "string" }
        }
      };
      function verifySignature(request3, result) {
        const payload = new AuthPayload(request3);
        const borsh_payload = borsh.serialize(exports2.authPayloadSchema, payload);
        const to_sign = Uint8Array.from(js_sha256_1.default.sha256.array(borsh_payload));
        let real_signature = new Uint8Array(Buffer.from(result.signature, "base64"));
        const myPK = crypto_1.PublicKey.from(result.publicKey);
        return myPK.verify(to_sign, real_signature);
      }
      exports2.verifySignature = verifySignature;
    }
  });

  // node_modules/uuid4/browser.js
  var require_browser6 = __commonJS({
    "node_modules/uuid4/browser.js"(exports2, module2) {
      init_process();
      init_buffer();
      var uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      function valid(uuid) {
        return uuidPattern.test(uuid);
      }
      function uuid4() {
        var temp_url = URL.createObjectURL(new Blob());
        var uuid = temp_url.toString();
        URL.revokeObjectURL(temp_url);
        return uuid.split(/[:\/]/g).pop().toLowerCase();
      }
      uuid4.valid = valid;
      module2.exports = uuid4;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/types.js
  var require_types3 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/types.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HereProviderError = exports2.HereProviderStatus = void 0;
      var HereProviderStatus;
      (function(HereProviderStatus2) {
        HereProviderStatus2[HereProviderStatus2["APPROVING"] = 1] = "APPROVING";
        HereProviderStatus2[HereProviderStatus2["FAILED"] = 2] = "FAILED";
        HereProviderStatus2[HereProviderStatus2["SUCCESS"] = 3] = "SUCCESS";
      })(HereProviderStatus = exports2.HereProviderStatus || (exports2.HereProviderStatus = {}));
      var HereProviderError = class extends Error {
        constructor(payload, parentError) {
          super(payload !== null && payload !== void 0 ? payload : parentError === null || parentError === void 0 ? void 0 : parentError.message);
          this.payload = payload;
          this.parentError = parentError;
        }
      };
      exports2.HereProviderError = HereProviderError;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/utils.js
  var require_utils35 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isValidAccessKey = exports2.internalThrow = exports2.getPublicKeys = exports2.serializeActions = exports2.isMobile = exports2.getDeviceId = void 0;
      var uuid4_1 = __importDefault(require_browser6());
      var types_1 = require_types3();
      var getDeviceId = () => {
        const topicId = (window === null || window === void 0 ? void 0 : window.localStorage.getItem("herewallet-topic")) || (0, uuid4_1.default)();
        window === null || window === void 0 ? void 0 : window.localStorage.setItem("herewallet-topic", topicId);
        return topicId;
      };
      exports2.getDeviceId = getDeviceId;
      var isMobile = () => {
        return (window === null || window === void 0 ? void 0 : window.matchMedia("(any-pointer:coarse)").matches) || false;
      };
      exports2.isMobile = isMobile;
      var serializeActions = (actions) => {
        return actions.map((act) => {
          if (act.type !== "FunctionCall")
            return act;
          let { args, deposit, gas, methodName } = act.params;
          if (ArrayBuffer.isView(args)) {
            args = Buffer.from(args.buffer, args.byteOffset, args.byteLength);
          }
          if (args instanceof Buffer) {
            args = args.toString("base64");
          }
          return {
            type: act.type,
            params: { args, deposit, gas, methodName }
          };
        });
      };
      exports2.serializeActions = serializeActions;
      var getPublicKeys = (rpc, accountId) => __awaiter6(void 0, void 0, void 0, function* () {
        const res = yield fetch(rpc, {
          method: "POST",
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "dontcare",
            method: "query",
            params: {
              request_type: "view_access_key_list",
              finality: "final",
              account_id: accountId
            }
          }),
          headers: {
            "content-type": "application/json"
          }
        });
        if (res.ok === false) {
          return [];
        }
        const data7 = yield res.json();
        return data7.result.keys;
      });
      exports2.getPublicKeys = getPublicKeys;
      var internalThrow = (error2, strategy, selector) => {
        if (error2 instanceof types_1.HereProviderError) {
          throw error2;
        }
        const result = {
          payload: error2 instanceof Error ? error2.message : "UNKNOWN",
          status: types_1.HereProviderStatus.FAILED,
          type: (selector === null || selector === void 0 ? void 0 : selector.type) || "web",
          account_id: (selector === null || selector === void 0 ? void 0 : selector.id) || ""
        };
        strategy.onFailed(result);
        throw error2;
      };
      exports2.internalThrow = internalThrow;
      var isValidAccessKey = (accountId, accessKey, call) => {
        const { permission } = accessKey.access_key;
        if (permission === "FullAccess") {
          return true;
        }
        if (permission.FunctionCall) {
          const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
          if (allowedReceiverId === accountId && allowedMethods.includes("add_request_and_confirm")) {
            return true;
          }
          if (allowedReceiverId === call.receiverId) {
            if (call.actions.length !== 1)
              return false;
            return call.actions.every((action) => {
              if (action.type !== "FunctionCall")
                return false;
              return (!action.params.deposit || action.params.deposit.toString() === "0") && (allowedMethods.length === 0 || allowedMethods.includes(action.params.methodName));
            });
          }
        }
        return false;
      };
      exports2.isValidAccessKey = isValidAccessKey;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/storage/JSONStorage.js
  var require_JSONStorage = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/storage/JSONStorage.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.StateStorage = void 0;
      var mockStorage = {
        getItem(k) {
          return null;
        },
        setItem(k, v) {
        },
        removeItem(k) {
        }
      };
      var StateStorage = class {
        constructor() {
          this.dataKey = `herewallet:keystore`;
          this.storage = typeof window !== "undefined" ? window.localStorage : mockStorage;
        }
        setState(network, state) {
          return __awaiter6(this, void 0, void 0, function* () {
            const data7 = yield this.getFullState();
            data7[network] = state;
            this.storage.setItem(this.dataKey, JSON.stringify(data7));
          });
        }
        getFullState() {
          return __awaiter6(this, void 0, void 0, function* () {
            try {
              return JSON.parse(this.storage.getItem(this.dataKey)) || {};
            } catch (_a) {
              return {};
            }
          });
        }
        getState(network) {
          return __awaiter6(this, void 0, void 0, function* () {
            const json = yield this.getFullState();
            return json[network] || { activeAccount: null, accounts: {} };
          });
        }
        clear() {
          return __awaiter6(this, void 0, void 0, function* () {
            this.storage.removeItem(this.dataKey);
          });
        }
      };
      exports2.StateStorage = StateStorage;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/storage/HereKeyStore.js
  var require_HereKeyStore = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/storage/HereKeyStore.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HereKeyStore = void 0;
      var crypto_1 = require_commonjs8();
      var JSONStorage_1 = require_JSONStorage();
      var HereKeyStore = class {
        constructor(storage = new JSONStorage_1.StateStorage()) {
          this.storage = storage;
        }
        setActiveAccount(network, id7) {
          return __awaiter6(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            state.activeAccount = id7;
            this.storage.setState(network, state);
          });
        }
        setKey(networkId, accountId, keyPair) {
          return __awaiter6(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(networkId);
            state.accounts[accountId] = keyPair.toString();
            this.storage.setState(networkId, state);
          });
        }
        getAccounts(network) {
          return __awaiter6(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            return Object.keys(state.accounts);
          });
        }
        getActiveAccount(network) {
          return __awaiter6(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            return state.activeAccount;
          });
        }
        getKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(networkId);
            const privateKey = state.accounts[accountId];
            if (privateKey == null)
              throw Error(`For ${accountId} in ${networkId} network key not found`);
            const keyPair = crypto_1.KeyPair.fromString(privateKey);
            return keyPair;
          });
        }
        removeKey(networkId, accountId) {
          return __awaiter6(this, void 0, void 0, function* () {
            let state = yield this.storage.getState(networkId);
            if (state.activeAccount === accountId) {
              state.activeAccount = null;
            }
            delete state.accounts[accountId];
            this.storage.setState(networkId, state);
          });
        }
        getNetworks() {
          return __awaiter6(this, void 0, void 0, function* () {
            let state = yield this.storage.getFullState();
            return Object.keys(state.accounts);
          });
        }
        clear() {
          return __awaiter6(this, void 0, void 0, function* () {
            yield this.storage.clear();
          });
        }
      };
      exports2.HereKeyStore = HereKeyStore;
    }
  });

  // node_modules/crypt/crypt.js
  var require_crypt = __commonJS({
    "node_modules/crypt/crypt.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
          // Bit-wise rotation left
          rotl: function(n, b) {
            return n << b | n >>> 32 - b;
          },
          // Bit-wise rotation right
          rotr: function(n, b) {
            return n << 32 - b | n >>> b;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt.endian(n[i]);
            return n;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n) {
            for (var bytes = []; n > 0; n--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes) {
            for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
              words[b >>> 5] |= bytes[i] << 24 - b % 32;
            return words;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words) {
            for (var bytes = [], b = 0; b < words.length * 32; b += 8)
              bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
            return bytes;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes) {
            for (var hex = [], i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 15).toString(16));
            }
            return hex.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex) {
            for (var bytes = [], c = 0; c < hex.length; c += 2)
              bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes) {
            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
              var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                else
                  base64.push("=");
            }
            return base64.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0) continue;
              bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
          }
        };
        module2.exports = crypt;
      })();
    }
  });

  // node_modules/charenc/charenc.js
  var require_charenc = __commonJS({
    "node_modules/charenc/charenc.js"(exports2, module2) {
      init_process();
      init_buffer();
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes = [], i = 0; i < str.length; i++)
              bytes.push(str.charCodeAt(i) & 255);
            return bytes;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            for (var str = [], i = 0; i < bytes.length; i++)
              str.push(String.fromCharCode(bytes[i]));
            return str.join("");
          }
        }
      };
      module2.exports = charenc;
    }
  });

  // node_modules/sha1/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/sha1/sha1.js"(exports2, module2) {
      init_process();
      init_buffer();
      (function() {
        var crypt = require_crypt(), utf8 = require_charenc().utf8, bin = require_charenc().bin, sha1 = function(message) {
          if (message.constructor == String)
            message = utf8.stringToBytes(message);
          else if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(message))
            message = Array.prototype.slice.call(message, 0);
          else if (!Array.isArray(message))
            message = message.toString();
          var m = crypt.bytesToWords(message), l = message.length * 8, w = [], H0 = 1732584193, H1 = -271733879, H2 = -1732584194, H3 = 271733878, H4 = -1009589776;
          m[l >> 5] |= 128 << 24 - l % 32;
          m[(l + 64 >>> 9 << 4) + 15] = l;
          for (var i = 0; i < m.length; i += 16) {
            var a = H0, b = H1, c = H2, d = H3, e = H4;
            for (var j = 0; j < 80; j++) {
              if (j < 16)
                w[j] = m[i + j];
              else {
                var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
                w[j] = n << 1 | n >>> 31;
              }
              var t = (H0 << 5 | H0 >>> 27) + H4 + (w[j] >>> 0) + (j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 : j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 : j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 : (H1 ^ H2 ^ H3) - 899497514);
              H4 = H3;
              H3 = H2;
              H2 = H1 << 30 | H1 >>> 2;
              H1 = H0;
              H0 = t;
            }
            H0 += a;
            H1 += b;
            H2 += c;
            H3 += d;
            H4 += e;
          }
          return [H0, H1, H2, H3, H4];
        }, api = function(message, options) {
          var digestbytes = crypt.wordsToBytes(sha1(message));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
        };
        api._blocksize = 16;
        api._digestsize = 20;
        module2.exports = api;
      })();
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/constants.js
  var require_constants17 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/constants.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports2.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConsoleLogger = void 0;
      var ConsoleLogger = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports2.ConsoleLogger = ConsoleLogger;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger16 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/logger.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var console_logger_1 = require_console_logger8();
      var DEFAULT_LOG_LEVELS = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS);
      var Logger2 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports2.Logger = Logger2;
      _a = Logger2;
      Logger2.instanceRef = DEFAULT_LOGGER;
      Logger2.overrideLogger = (logger2) => {
        _a.instanceRef = logger2;
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger17 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logger/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = void 0;
      var logger_1 = require_logger16();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors25 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logWarning = void 0;
      var logger_1 = require_logger17();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports2.logWarning = logWarning;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/assignable.js
  var require_assignable9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/assignable.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Assignable = void 0;
      var Assignable = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports2.Assignable = Assignable;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/errors.js
  var require_errors26 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorContext = exports2.TypedError = exports2.ArgumentTypeError = exports2.PositionalArgsError = void 0;
      var PositionalArgsError = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports2.PositionalArgsError = PositionalArgsError;
      var ArgumentTypeError = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports2.ArgumentTypeError = ArgumentTypeError;
      var TypedError = class extends Error {
        constructor(message, type, context2) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context2;
        }
      };
      exports2.TypedError = TypedError;
      var ErrorContext = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports2.ErrorContext = ErrorContext;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IdType = void 0;
      var IdType2;
      (function(IdType3) {
        IdType3["Transaction"] = "transaction";
        IdType3["Receipt"] = "receipt";
      })(IdType2 = exports2.IdType || (exports2.IdType = {}));
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/response.js
  var require_response9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/response.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic2;
      (function(ExecutionStatusBasic3) {
        ExecutionStatusBasic3["Unknown"] = "Unknown";
        ExecutionStatusBasic3["Pending"] = "Pending";
        ExecutionStatusBasic3["Failure"] = "Failure";
      })(ExecutionStatusBasic2 = exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic2;
      (function(FinalExecutionStatusBasic3) {
        FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic3["Started"] = "Started";
        FinalExecutionStatusBasic3["Failure"] = "Failure";
      })(FinalExecutionStatusBasic2 = exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/index.js
  var require_provider19 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/provider/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = exports2.IdType = void 0;
      var light_client_1 = require_light_client9();
      Object.defineProperty(exports2, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response9();
      Object.defineProperty(exports2, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/index.js
  var require_lib35 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/types/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_assignable9(), exports2);
      __exportStar(require_errors26(), exports2);
      __exportStar(require_provider19(), exports2);
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/format.js
  var require_format9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/format.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.baseDecode = exports2.baseEncode = exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs588());
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = BigInt(10) ** BigInt(exports2.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS = [];
      var BN10 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports2.NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
        ROUNDING_OFFSETS[i] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split7 = amt.split(".");
        const wholePart = split7[0];
        const fracPart = split7[1] || "";
        if (split7.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode(value) {
        if (typeof value === "string") {
          const bytes = [];
          for (let c = 0; c < value.length; c++) {
            bytes.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes);
        }
        return bs58_1.default.encode(value);
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports2, module2) {
      module2.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports2, module2) {
      module2.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.parseResultError = exports2.parseRpcError = exports2.ServerError = void 0;
      var types_1 = require_lib35();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format9();
      var error_messages_json_1 = __importDefault(require_error_messages8());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema8());
      var mustacheHelpers = {
        formatNear: () => (n, render) => (0, format_1.formatNearAmount)(render(n))
      };
      var ServerError = class extends types_1.TypedError {
      };
      exports2.ServerError = ServerError;
      var ServerTransactionError = class extends ServerError {
      };
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error2 = new ServerError(formatError2(errorClassName, result), errorClassName);
        Object.assign(error2, result);
        return error2;
      }
      exports2.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports2.parseResultError = parseResultError;
      function formatError2(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      exports2.formatError = formatError2;
      function walkSubtype(errorObj, schema, result, typeName) {
        let error2;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject8(errorObj[errorName])) {
            error2 = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject8(errorObj.kind) && isObject8(errorObj.kind[errorName])) {
            error2 = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error2 && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error2[prop];
          }
          return walkSubtype(error2, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
      function isObject8(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors27 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseRpcError = exports2.parseResultError = exports2.getErrorTypeFromErrorMessage = exports2.formatError = exports2.ServerError = exports2.logWarning = void 0;
      var errors_1 = require_errors25();
      Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors9();
      Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports2, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports2, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logging.js
  var require_logging8 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/logging.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors27();
      var logger_1 = require_logger17();
      function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
      function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
        for (const log3 of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log3}`);
        }
      }
      exports2.printTxOutcomeLogs = printTxOutcomeLogs;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/provider.js
  var require_provider20 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/provider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = void 0;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/utils.js
  var require_utils36 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/utils.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sortBigIntAsc = void 0;
      function sortBigIntAsc(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports2.sortBigIntAsc = sortBigIntAsc;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/validators.js
  var require_validators9 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/validators.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils36();
      function findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate2 = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate2("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports2.findSeatPrice = findSeatPrice;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports2.diffEpochValidators = diffEpochValidators;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/index.js
  var require_lib36 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@near-js/utils/lib/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants17(), exports2);
      __exportStar(require_errors27(), exports2);
      __exportStar(require_format9(), exports2);
      __exportStar(require_logging8(), exports2);
      __exportStar(require_provider20(), exports2);
      __exportStar(require_validators9(), exports2);
      __exportStar(require_logger17(), exports2);
      __exportStar(require_utils36(), exports2);
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/proxyMethods.js
  var require_proxyMethods = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/proxyMethods.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createRequest = exports2.computeRequestId = exports2.deleteRequest = exports2.getResponse = exports2.getRequest = exports2.proxyApi = void 0;
      var sha1_1 = __importDefault(require_sha1());
      var uuid4_1 = __importDefault(require_browser6());
      var utils_1 = require_lib36();
      var utils_2 = require_utils35();
      exports2.proxyApi = "https://h4n.app";
      var getRequest = (id7, signal) => __awaiter6(void 0, void 0, void 0, function* () {
        const res = yield fetch(`${exports2.proxyApi}/${id7}/request`, {
          signal,
          headers: { "content-type": "application/json" },
          method: "GET"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        const { data: data7 } = yield res.json();
        return JSON.parse(Buffer.from((0, utils_1.baseDecode)(data7)).toString("utf8"));
      });
      exports2.getRequest = getRequest;
      var getResponse = (id7) => __awaiter6(void 0, void 0, void 0, function* () {
        var _a;
        const res = yield fetch(`${exports2.proxyApi}/${id7}/response`, {
          headers: { "content-type": "application/json" },
          method: "GET"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        const { data: data7 } = yield res.json();
        const result = (_a = JSON.parse(data7)) !== null && _a !== void 0 ? _a : {};
        return Object.assign({ type: "here", public_key: "", account_id: "", payload: "", status: -1, path: "" }, result);
      });
      exports2.getResponse = getResponse;
      var deleteRequest = (id7) => __awaiter6(void 0, void 0, void 0, function* () {
        const res = yield fetch(`${exports2.proxyApi}/${id7}`, {
          headers: { "content-type": "application/json" },
          method: "DELETE"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
      });
      exports2.deleteRequest = deleteRequest;
      var computeRequestId = (request3) => __awaiter6(void 0, void 0, void 0, function* () {
        const query = (0, utils_1.baseEncode)(JSON.stringify(Object.assign(Object.assign({}, request3), { _id: (0, uuid4_1.default)() })));
        const hashsum = (0, sha1_1.default)(query);
        const id7 = Buffer.from(hashsum, "hex").toString("base64");
        const requestId = id7.replaceAll("/", "_").replaceAll("-", "+").slice(0, 13);
        return { requestId, query };
      });
      exports2.computeRequestId = computeRequestId;
      var createRequest = (request3, signal) => __awaiter6(void 0, void 0, void 0, function* () {
        const { query, requestId } = yield (0, exports2.computeRequestId)(request3);
        const res = yield fetch(`${exports2.proxyApi}/${requestId}/request`, {
          method: "POST",
          body: JSON.stringify({ topic_id: (0, utils_2.getDeviceId)(), data: query }),
          headers: { "content-type": "application/json" },
          signal
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        return requestId;
      });
      exports2.createRequest = createRequest;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/HereStrategy.js
  var require_HereStrategy = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/HereStrategy.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HereStrategy = exports2.getRequest = exports2.proxyApi = exports2.deleteRequest = exports2.getResponse = exports2.createRequest = void 0;
      var types_1 = require_types3();
      var proxyMethods_1 = require_proxyMethods();
      Object.defineProperty(exports2, "createRequest", { enumerable: true, get: function() {
        return proxyMethods_1.createRequest;
      } });
      Object.defineProperty(exports2, "getResponse", { enumerable: true, get: function() {
        return proxyMethods_1.getResponse;
      } });
      Object.defineProperty(exports2, "deleteRequest", { enumerable: true, get: function() {
        return proxyMethods_1.deleteRequest;
      } });
      Object.defineProperty(exports2, "proxyApi", { enumerable: true, get: function() {
        return proxyMethods_1.proxyApi;
      } });
      Object.defineProperty(exports2, "getRequest", { enumerable: true, get: function() {
        return proxyMethods_1.getRequest;
      } });
      var HereStrategy = class {
        connect(wallet) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.wallet = wallet;
          });
        }
        onInitialized() {
          return __awaiter6(this, void 0, void 0, function* () {
          });
        }
        onRequested(id7, request3, reject5) {
          return __awaiter6(this, void 0, void 0, function* () {
          });
        }
        onApproving(result) {
          return __awaiter6(this, void 0, void 0, function* () {
          });
        }
        onSuccess(result) {
          return __awaiter6(this, void 0, void 0, function* () {
          });
        }
        onFailed(result) {
          return __awaiter6(this, void 0, void 0, function* () {
          });
        }
        request(conf) {
          return __awaiter6(this, void 0, void 0, function* () {
            let { request: request3, disableCleanupRequest, id: id7, signal } = conf, delegate = __rest(conf, ["request", "disableCleanupRequest", "id", "signal"]);
            if (id7 != null)
              request3 = yield (0, proxyMethods_1.getRequest)(id7, signal);
            else
              id7 = yield (0, proxyMethods_1.createRequest)(request3, signal);
            return new Promise((resolve5, reject5) => {
              let fallbackHttpTimer = null;
              const clear5 = () => __awaiter6(this, void 0, void 0, function* () {
                fallbackHttpTimer = -1;
                clearInterval(fallbackHttpTimer);
                if (disableCleanupRequest !== true) {
                  yield (0, proxyMethods_1.deleteRequest)(id7);
                }
              });
              const processApprove = (data7) => {
                switch (data7.status) {
                  case types_1.HereProviderStatus.APPROVING:
                    this.onApproving(data7);
                    return;
                  case types_1.HereProviderStatus.FAILED:
                    clear5();
                    reject5(new types_1.HereProviderError(data7.payload));
                    this.onFailed(data7);
                    return;
                  case types_1.HereProviderStatus.SUCCESS:
                    clear5();
                    resolve5(data7);
                    this.onSuccess(data7);
                    return;
                }
              };
              const rejectAction = (payload) => {
                var _a;
                processApprove({
                  type: ((_a = request3.selector) === null || _a === void 0 ? void 0 : _a.type) || "web",
                  status: types_1.HereProviderStatus.FAILED,
                  payload
                });
              };
              this.onRequested(id7, request3, rejectAction);
              signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", () => rejectAction());
              const setupTimer = () => {
                if (fallbackHttpTimer === -1) {
                  return;
                }
                fallbackHttpTimer = setTimeout(() => __awaiter6(this, void 0, void 0, function* () {
                  var _a;
                  try {
                    const data7 = yield (0, proxyMethods_1.getResponse)(id7);
                    if (fallbackHttpTimer === -1)
                      return;
                    processApprove(data7);
                    setupTimer();
                  } catch (e) {
                    const status = types_1.HereProviderStatus.FAILED;
                    const error2 = e instanceof Error ? e : void 0;
                    const payload = error2 === null || error2 === void 0 ? void 0 : error2.message;
                    clear5();
                    reject5(new types_1.HereProviderError(payload, error2));
                    this.onFailed({ type: ((_a = request3.selector) === null || _a === void 0 ? void 0 : _a.type) || "web", status, payload });
                  }
                }), 3e3);
              };
              setupTimer();
            });
          });
        }
      };
      exports2.HereStrategy = HereStrategy;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/WidgetStrategy.js
  var require_WidgetStrategy = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/WidgetStrategy.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WidgetStrategy = exports2.defaultUrl = void 0;
      var HereStrategy_1 = require_HereStrategy();
      var createIframe = (widget) => {
        const connector = document.createElement("iframe");
        connector.src = widget;
        connector.allow = "usb";
        connector.style.border = "none";
        connector.style.zIndex = "10000";
        connector.style.position = "fixed";
        connector.style.display = "none";
        connector.style.top = "0";
        connector.style.left = "0";
        connector.style.width = "100%";
        connector.style.height = "100%";
        document.body.appendChild(connector);
        return connector;
      };
      exports2.defaultUrl = "https://my.herewallet.app/connector/index.html";
      var WidgetStrategy = class _WidgetStrategy extends HereStrategy_1.HereStrategy {
        constructor(options = { widget: exports2.defaultUrl, lazy: false }) {
          super();
          this.options = {
            lazy: typeof options === "object" ? options.lazy || false : false,
            widget: typeof options === "string" ? options : options.widget || exports2.defaultUrl
          };
          if (!this.options.lazy) {
            this.initIframe();
          }
        }
        initIframe() {
          if (_WidgetStrategy.connector == null) {
            _WidgetStrategy.connector = createIframe(this.options.widget);
            _WidgetStrategy.connector.addEventListener("load", () => {
              _WidgetStrategy.isLoaded = true;
            });
          }
          return _WidgetStrategy.connector;
        }
        onRequested(id7, request3, reject5) {
          return __awaiter6(this, void 0, void 0, function* () {
            const iframe = this.initIframe();
            iframe.style.display = "block";
            const loadHandler = () => {
              var _a, _b, _c;
              (_a = _WidgetStrategy.connector) === null || _a === void 0 ? void 0 : _a.removeEventListener("load", loadHandler);
              (_c = (_b = _WidgetStrategy.connector) === null || _b === void 0 ? void 0 : _b.contentWindow) === null || _c === void 0 ? void 0 : _c.postMessage(JSON.stringify({ type: "request", payload: { id: id7, request: request3 } }), new URL(this.options.widget).origin);
            };
            if (_WidgetStrategy.isLoaded)
              loadHandler();
            else
              iframe.addEventListener("load", loadHandler);
            this.messageHandler = (event) => {
              try {
                if (event.origin !== new URL(this.options.widget).origin)
                  return;
                if (JSON.parse(event.data).type === "reject")
                  reject5();
              } catch (_a) {
              }
            };
            window === null || window === void 0 ? void 0 : window.addEventListener("message", this.messageHandler);
          });
        }
        postMessage(data7) {
          var _a;
          const iframe = this.initIframe();
          const args = JSON.stringify(data7);
          const origin = new URL(this.options.widget).origin;
          (_a = iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(args, origin);
        }
        onApproving() {
          return __awaiter6(this, void 0, void 0, function* () {
            this.postMessage({ type: "approving" });
          });
        }
        onSuccess(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            console.log(request3);
            this.postMessage({ type: "result", payload: { request: request3 } });
            this.close();
          });
        }
        onFailed(request3) {
          return __awaiter6(this, void 0, void 0, function* () {
            this.postMessage({ type: "result", payload: { request: request3 } });
            this.close();
          });
        }
        close() {
          if (this.messageHandler) {
            window === null || window === void 0 ? void 0 : window.removeEventListener("message", this.messageHandler);
            this.messageHandler = void 0;
          }
          if (_WidgetStrategy.connector) {
            _WidgetStrategy.connector.style.display = "none";
          }
        }
      };
      exports2.WidgetStrategy = WidgetStrategy;
      WidgetStrategy.isLoaded = false;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/TelegramAppStrategy.js
  var require_TelegramAppStrategy = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/TelegramAppStrategy.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TelegramAppStrategy = void 0;
      var crypto_1 = require_commonjs8();
      var utils_1 = require_lib36();
      var types_1 = require_types3();
      var proxyMethods_1 = require_proxyMethods();
      var HereStrategy_1 = require_HereStrategy();
      var utils_2 = require_utils35();
      var TelegramAppStrategy = class extends HereStrategy_1.HereStrategy {
        constructor(appId = "herewalletbot/app", walletId = "herewalletbot/app") {
          super();
          this.appId = appId;
          this.walletId = walletId;
        }
        connect(wallet) {
          var _a, _b, _c, _d, _e, _f;
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            this.wallet = wallet;
            const startapp = ((_c = (_b = (_a = window === null || window === void 0 ? void 0 : window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) === null || _b === void 0 ? void 0 : _b.initDataUnsafe) === null || _c === void 0 ? void 0 : _c.start_param) || "";
            (_f = (_d = window === null || window === void 0 ? void 0 : window.Telegram) === null || _d === void 0 ? void 0 : (_e = _d.WebApp).ready) === null || _f === void 0 ? void 0 : _f.call(_e);
            if (startapp.startsWith("hot")) {
              let requestId = startapp.split("-").pop() || "";
              requestId = Buffer.from((0, utils_1.baseDecode)(requestId)).toString("utf8");
              const requestPending = localStorage.getItem(`__telegramPendings:${requestId}`);
              if (requestPending == null)
                return;
              const data7 = yield (0, HereStrategy_1.getResponse)(requestId);
              if (data7.status !== types_1.HereProviderStatus.SUCCESS) {
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                return;
              }
              if (data7.type === "sign") {
                yield this.wallet.authStorage.setKey("mainnet", data7.account_id, crypto_1.KeyPairEd25519.fromRandom());
                yield this.wallet.authStorage.setActiveAccount("mainnet", data7.account_id);
              }
              try {
                const pending = JSON.parse(requestPending);
                if (pending.privateKey) {
                  yield this.wallet.authStorage.setKey("mainnet", data7.account_id, crypto_1.KeyPair.fromString(pending.privateKey));
                  yield this.wallet.authStorage.setActiveAccount("mainnet", data7.account_id);
                }
                const url = new URL(location.origin + (pending.callbackUrl || ""));
                url.searchParams.set("payload", data7.result);
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                location.assign(url.toString());
              } catch (e) {
                const url = new URL(location.href);
                url.searchParams.set("payload", data7.result);
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                location.assign(url.toString());
              }
            }
          });
        }
        request(conf) {
          var _a;
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            conf.request.telegramApp = this.appId;
            conf.request.callbackUrl = "";
            const { requestId, query } = yield (0, proxyMethods_1.computeRequestId)(conf.request);
            const res = yield fetch(`${proxyMethods_1.proxyApi}/${requestId}/request`, {
              method: "POST",
              body: JSON.stringify({ topic_id: (0, utils_2.getDeviceId)(), data: query }),
              headers: { "content-type": "application/json" },
              signal: conf.signal
            });
            if (res.ok === false) {
              throw Error(yield res.text());
            }
            localStorage.setItem(`__telegramPendings:${requestId}`, JSON.stringify({ callbackUrl: conf.callbackUrl, privateKey: (_a = conf.accessKey) === null || _a === void 0 ? void 0 : _a.toString() }));
            this.onRequested(requestId);
          });
        }
        onRequested(id7) {
          var _a, _b, _c, _d;
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            id7 = (0, utils_1.baseEncode)(id7);
            (_b = (_a = window === null || window === void 0 ? void 0 : window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) === null || _b === void 0 ? void 0 : _b.openTelegramLink(`https://t.me/${this.walletId}?startapp=h4n-${id7}`);
            (_d = (_c = window === null || window === void 0 ? void 0 : window.Telegram) === null || _c === void 0 ? void 0 : _c.WebApp) === null || _d === void 0 ? void 0 : _d.close();
          });
        }
      };
      exports2.TelegramAppStrategy = TelegramAppStrategy;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/waitInjected.js
  var require_waitInjected = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/waitInjected.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.waitInjectedHereWallet = void 0;
      exports2.waitInjectedHereWallet = new Promise((resolve5) => {
        if (typeof window === "undefined")
          return resolve5(null);
        if ((window === null || window === void 0 ? void 0 : window.self) === (window === null || window === void 0 ? void 0 : window.top))
          return resolve5(null);
        const handler = (e) => {
          if (e.data.type !== "here-wallet-injected")
            return;
          window === null || window === void 0 ? void 0 : window.parent.postMessage("here-sdk-init", "*");
          window === null || window === void 0 ? void 0 : window.removeEventListener("message", handler);
          resolve5({
            ethAddress: e.data.ethAddress,
            accountId: e.data.accountId,
            publicKey: e.data.publicKey,
            telegramId: e.data.telegramId,
            network: e.data.network || "mainnet"
          });
        };
        window === null || window === void 0 ? void 0 : window.addEventListener("message", handler);
        setTimeout(() => resolve5(null), 2e3);
      });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/InjectedStrategy.js
  var require_InjectedStrategy = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/InjectedStrategy.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InjectedStrategy = void 0;
      var uuid4_1 = __importDefault(require_browser6());
      var crypto_1 = require_commonjs8();
      var types_1 = require_types3();
      var waitInjected_1 = require_waitInjected();
      var HereStrategy_1 = require_HereStrategy();
      var InjectedStrategy = class extends HereStrategy_1.HereStrategy {
        connect(wallet) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return Promise.resolve();
            this.wallet = wallet;
            const injected = yield waitInjected_1.waitInjectedHereWallet;
            if (injected == null)
              return;
            yield this.wallet.authStorage.setKey(injected.network, injected.accountId, crypto_1.KeyPairEd25519.fromRandom());
            yield this.wallet.authStorage.setActiveAccount(injected.network, injected.accountId);
          });
        }
        request(conf) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return Promise.reject("SSR");
            return new Promise((resolve5) => {
              const id7 = (0, uuid4_1.default)();
              const handler = (e) => {
                if (e.data.id !== id7)
                  return;
                if (e.data.status === types_1.HereProviderStatus.SUCCESS || e.data.status === types_1.HereProviderStatus.FAILED) {
                  window === null || window === void 0 ? void 0 : window.removeEventListener("message", handler);
                  return resolve5(e.data);
                }
              };
              window === null || window === void 0 ? void 0 : window.parent.postMessage(Object.assign(Object.assign({ $here: true }, conf.request), { id: id7 }), "*");
              window === null || window === void 0 ? void 0 : window.addEventListener("message", handler);
            });
          });
        }
      };
      exports2.InjectedStrategy = InjectedStrategy;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/telegramEthereumProvider.js
  var require_telegramEthereumProvider = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/telegramEthereumProvider.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hereWalletProvider = void 0;
      var uuid4_1 = __importDefault(require_browser6());
      var waitInjected_1 = require_waitInjected();
      var promises = {};
      var request3 = (type, args) => {
        return new Promise((resolve5, reject5) => {
          const id7 = (0, uuid4_1.default)();
          window === null || window === void 0 ? void 0 : window.parent.postMessage({ type, id: id7, args }, "*");
          promises[id7] = { resolve: resolve5, reject: reject5 };
        });
      };
      var hereWalletProvider = {
        on() {
        },
        isHereWallet: true,
        isConnected: () => true,
        request: (data7) => request3("ethereum", data7)
      };
      exports2.hereWalletProvider = hereWalletProvider;
      function announceProvider() {
        return __awaiter6(this, void 0, void 0, function* () {
          if (typeof window === "undefined")
            return;
          const injected = yield waitInjected_1.waitInjectedHereWallet;
          if (injected == null)
            return;
          window === null || window === void 0 ? void 0 : window.dispatchEvent(new CustomEvent("eip6963:announceProvider", {
            detail: Object.freeze({
              provider: hereWalletProvider,
              info: {
                uuid: (0, uuid4_1.default)(),
                name: "HERE Wallet",
                icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTUwIiBoZWlnaHQ9IjU1MCIgdmlld0JveD0iMCAwIDU1MCA1NTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1NTAiIGhlaWdodD0iNTUwIiByeD0iMTIwIiBmaWxsPSIjRjNFQkVBIj48L3JlY3Q+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjcyLjA0NiAxODMuNTM4TDI5My43ODggMTQzTDMyMi4yODggMjM4LjVMMjc5LjU1OCAyMTkuMTgyTDI3Mi4wNDYgMTgzLjUzOFpNMTE4LjI4OCAyMjZMOTYuMTg0IDI2NS44NTdMMTYzLjc2OSAyOTguOTJMMjU2Ljc4OCAyOTIuNUwxMTguMjg4IDIyNlpNMTA1Ljk2OSAzMDEuMTU4TDg0IDM0MC44MDNMMjE4LjkzNyA0MDcuNzkxTDQ0My44MDcgMzk0LjE0MUw0NjUuNzc2IDM1NC40OTZMMjQwLjkwNiAzNjguMTQ3TDEwNS45NjkgMzAxLjE1OFoiIGZpbGw9IiMyQzMwMzQiPjwvcGF0aD4KPHBhdGggZD0iTTQ2NS43ODggMzU0LjVMMjQwLjk4MiAzNjguMTUzTDEwNC44ODcgMzAxLjAwNUwyNTIuMjU5IDI5Mi4wODhMMTE4LjI4OCAyMjZMMTg0LjA3NiAxNzAuMjgyTDMyMC41NDcgMjM3LjM5N0wyOTMuNzg5IDE0My4wMDFMNDI0LjE5NSAyMDYuOTQ5TDQ2NS43ODggMzU0LjVaIiBmaWxsPSIjRkRCRjFDIj48L3BhdGg+Cjwvc3ZnPg==",
                rdns: "app.herewallet.my"
              }
            })
          }));
        });
      }
      if (typeof window !== "undefined") {
        window === null || window === void 0 ? void 0 : window.addEventListener("message", (e) => {
          var _a, _b;
          if (e.data.type !== "ethereum")
            return;
          if (e.data.isSuccess)
            return (_a = promises[e.data.id]) === null || _a === void 0 ? void 0 : _a.resolve(e.data.result);
          (_b = promises[e.data.id]) === null || _b === void 0 ? void 0 : _b.reject(e.data.result);
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("eip6963:requestProvider", () => announceProvider());
        announceProvider();
      }
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/wallet.js
  var require_wallet = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/wallet.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HereWallet = void 0;
      var accounts_1 = require_lib24();
      var signers_1 = require_lib22();
      var providers_1 = require_commonjs5();
      var crypto_1 = require_commonjs8();
      var crypto_2 = require_crypto9();
      var js_sha256_1 = require_sha2566();
      var bn_js_1 = __importDefault(require_bn());
      var actions_1 = require_actions5();
      var nep0314_1 = require_nep0314();
      var utils_1 = require_utils35();
      var HereKeyStore_1 = require_HereKeyStore();
      var WidgetStrategy_1 = require_WidgetStrategy();
      var types_1 = require_types3();
      var TelegramAppStrategy_1 = require_TelegramAppStrategy();
      var InjectedStrategy_1 = require_InjectedStrategy();
      var waitInjected_1 = require_waitInjected();
      var telegramEthereumProvider_1 = require_telegramEthereumProvider();
      var AccessDenied = class extends Error {
      };
      var HereWallet2 = class _HereWallet {
        constructor({ injected, nodeUrl, networkId = "mainnet", authStorage, defaultStrategy } = {}) {
          this.authStorage = authStorage;
          this.strategy = defaultStrategy;
          Object.defineProperty(this, "ethAddress", { get: () => injected === null || injected === void 0 ? void 0 : injected.ethAddress });
          Object.defineProperty(this, "telegramId", { get: () => injected === null || injected === void 0 ? void 0 : injected.telegramId });
          Object.defineProperty(this, "ethProvider", { get: () => (injected === null || injected === void 0 ? void 0 : injected.ethAddress) ? telegramEthereumProvider_1.hereWalletProvider : null });
          const signer = new signers_1.InMemorySigner(this.authStorage);
          const rpc = new providers_1.JsonRpcProvider({ url: nodeUrl !== null && nodeUrl !== void 0 ? nodeUrl : `https://rpc.${networkId}.near.org` });
          this.connection = accounts_1.Connection.fromConfig({
            jsvmAccountId: `jsvm.${networkId}`,
            provider: rpc,
            networkId,
            signer
          });
        }
        static connect(options = {}) {
          var _a;
          return __awaiter6(this, void 0, void 0, function* () {
            if (options.authStorage == null)
              options.authStorage = new HereKeyStore_1.HereKeyStore();
            if (options.defaultStrategy) {
              const wallet2 = new _HereWallet(options);
              yield wallet2.strategy.connect(wallet2);
              return wallet2;
            }
            if (typeof window !== "undefined") {
              if (window !== parent) {
                const injected = yield waitInjected_1.waitInjectedHereWallet;
                if (injected != null) {
                  options.defaultStrategy = new InjectedStrategy_1.InjectedStrategy();
                  const wallet2 = new _HereWallet(Object.assign(Object.assign({}, options), { injected }));
                  yield wallet2.strategy.connect(wallet2);
                  return wallet2;
                }
              }
              if (((_a = window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) != null) {
                options.defaultStrategy = new TelegramAppStrategy_1.TelegramAppStrategy(options.botId, options.walletId);
                const wallet2 = new _HereWallet(options);
                yield wallet2.strategy.connect(wallet2);
                return wallet2;
              }
            }
            options.defaultStrategy = new WidgetStrategy_1.WidgetStrategy();
            const wallet = new _HereWallet(options);
            yield wallet.strategy.connect(wallet);
            return wallet;
          });
        }
        get rpc() {
          return this.connection.provider;
        }
        get signer() {
          return this.connection.signer;
        }
        get networkId() {
          return this.connection.networkId;
        }
        account(id7) {
          return __awaiter6(this, void 0, void 0, function* () {
            const accountId = id7 !== null && id7 !== void 0 ? id7 : yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new AccessDenied("Wallet not signed in");
            return new accounts_1.Account(this.connection, accountId);
          });
        }
        isSignedIn() {
          return __awaiter6(this, void 0, void 0, function* () {
            const id7 = yield this.authStorage.getActiveAccount(this.networkId);
            return id7 != null;
          });
        }
        signOut() {
          return __awaiter6(this, void 0, void 0, function* () {
            const accountId = yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new Error("Wallet not signed in");
            const key = yield this.authStorage.getKey(this.networkId, accountId);
            if (key != null) {
              const publicKey = key.getPublicKey().toString();
              yield this.silentSignAndSendTransaction({
                receiverId: accountId,
                actions: [{ type: "DeleteKey", params: { publicKey } }]
              }).catch(() => {
              });
            }
            yield this.authStorage.removeKey(this.networkId, accountId);
          });
        }
        getHereBalance(id7) {
          return __awaiter6(this, void 0, void 0, function* () {
            const account = yield this.account(id7);
            const contractId = this.networkId === "mainnet" ? "here.storage.near" : "here.storage.testnet";
            const hereCoins = yield account.viewFunction({ args: { account_id: account.accountId }, methodName: "ft_balance_of", contractId }).catch(() => "0");
            return new bn_js_1.default(hereCoins);
          });
        }
        getAvailableBalance(id7) {
          return __awaiter6(this, void 0, void 0, function* () {
            const account = yield this.account(id7);
            const result = yield account.getAccountBalance();
            const hereBalance = yield this.getHereBalance();
            return new bn_js_1.default(result.available).add(new bn_js_1.default(hereBalance));
          });
        }
        getAccounts() {
          return __awaiter6(this, void 0, void 0, function* () {
            return yield this.authStorage.getAccounts(this.networkId);
          });
        }
        getAccountId() {
          return __awaiter6(this, void 0, void 0, function* () {
            const accountId = yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new Error("Wallet not signed in");
            return accountId;
          });
        }
        switchAccount(id7) {
          return __awaiter6(this, void 0, void 0, function* () {
            const key = yield this.authStorage.getKey(this.networkId, id7);
            if (key == null)
              throw new Error(`Account ${id7} not signed in`);
            yield this.authStorage.setActiveAccount(this.networkId, id7);
          });
        }
        signIn({ contractId, allowance, methodNames = [], strategy = this.strategy, signal, callbackUrl, selector } = {}) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (contractId == null) {
              const { accountId } = yield this.authenticate({ strategy, signal, selector });
              yield this.authStorage.setKey(this.networkId, accountId, crypto_1.KeyPairEd25519.fromRandom());
              yield this.authStorage.setActiveAccount(this.networkId, accountId);
              return accountId;
            }
            yield strategy.onInitialized();
            try {
              const accessKey = crypto_1.KeyPair.fromRandom("ed25519");
              const permission = { receiverId: contractId, methodNames, allowance };
              const data7 = yield strategy.request({
                signal,
                accessKey,
                callbackUrl,
                request: {
                  type: "call",
                  network: this.networkId,
                  selector: selector || {},
                  transactions: [
                    {
                      actions: [
                        {
                          type: "AddKey",
                          params: {
                            publicKey: accessKey.getPublicKey().toString(),
                            accessKey: { permission }
                          }
                        }
                      ]
                    }
                  ]
                }
              });
              if (data7.account_id == null) {
                throw Error("Transaction is failed");
              }
              yield this.authStorage.setKey(this.networkId, data7.account_id, accessKey);
              yield this.authStorage.setActiveAccount(this.networkId, data7.account_id);
              return data7.account_id;
            } catch (error2) {
              (0, utils_1.internalThrow)(error2, strategy, selector);
              throw error2;
            }
          });
        }
        silentSignAndSendTransaction({ actions, receiverId, signerId }) {
          return __awaiter6(this, void 0, void 0, function* () {
            const account = yield this.account(signerId);
            const localKey = yield this.authStorage.getKey(this.networkId, account.accountId).catch(() => null);
            if (localKey == null)
              throw new AccessDenied();
            const publicKey = localKey.getPublicKey();
            const accessKeys = yield account.getAccessKeys();
            const call = { receiverId, actions };
            const isValid = accessKeys.some((v) => {
              if (v.public_key !== publicKey.toString())
                return false;
              return (0, utils_1.isValidAccessKey)(account.accountId, v, call);
            });
            if (isValid === false)
              throw new AccessDenied();
            return yield account.signAndSendTransaction({
              actions: actions.map((a) => (0, actions_1.createAction)(a)),
              receiverId: receiverId !== null && receiverId !== void 0 ? receiverId : account.accountId
            });
          });
        }
        signAndSendTransaction(opts) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { signerId, receiverId, actions, callbackUrl, strategy = this.strategy, signal, selector } = opts;
            yield strategy.onInitialized();
            try {
              const result = yield this.silentSignAndSendTransaction({ receiverId, actions, signerId });
              const success = { type: "web", status: types_1.HereProviderStatus.SUCCESS, payload: result === null || result === void 0 ? void 0 : result.transaction_outcome.id };
              strategy.onSuccess(success);
              return result;
            } catch (e) {
              try {
                if (!(e instanceof AccessDenied) && (e === null || e === void 0 ? void 0 : e.type) !== "NotEnoughAllowance") {
                  (0, utils_1.internalThrow)(e, strategy, selector);
                  throw e;
                }
                const activeAccount = yield this.getAccountId().catch(() => void 0);
                const data7 = yield strategy.request({
                  signal,
                  callbackUrl,
                  request: {
                    type: "call",
                    network: this.networkId,
                    transactions: [{ actions: (0, utils_1.serializeActions)(actions), receiverId, signerId }],
                    selector: opts.selector || { id: signerId || activeAccount }
                  }
                });
                if (data7.payload == null || data7.account_id == null) {
                  throw Error("Transaction not found, but maybe executed");
                }
                return yield this.rpc.txStatus(data7.payload, data7.account_id, "INCLUDED");
              } catch (error2) {
                (0, utils_1.internalThrow)(error2, strategy, selector);
                throw error2;
              }
            }
          });
        }
        verifyMessageNEP0413(request3, result) {
          return __awaiter6(this, void 0, void 0, function* () {
            const isSignatureValid = (0, nep0314_1.verifySignature)(request3, result);
            if (!isSignatureValid)
              throw Error("Incorrect signature");
            const account = yield this.account(result.accountId);
            const keys14 = yield account.getAccessKeys();
            const isFullAccess = keys14.some((k) => {
              if (k.public_key !== result.publicKey)
                return false;
              if (k.access_key.permission !== "FullAccess")
                return false;
              return true;
            });
            if (!isFullAccess)
              throw Error("Signer public key is not full access");
            return true;
          });
        }
        authenticate(options = {}) {
          var _a, _b, _c;
          return __awaiter6(this, void 0, void 0, function* () {
            const signRequest = {
              nonce: (_a = options.nonce) !== null && _a !== void 0 ? _a : (0, crypto_2.randomBytes)(32),
              recipient: (_b = options.recipient) !== null && _b !== void 0 ? _b : window === null || window === void 0 ? void 0 : window.location.host,
              message: (_c = options.message) !== null && _c !== void 0 ? _c : "Authenticate"
            };
            const signed = yield this.signMessage(Object.assign(Object.assign({}, signRequest), options));
            yield this.verifyMessageNEP0413(signRequest, signed);
            return signed;
          });
        }
        signMessage(options) {
          return __awaiter6(this, void 0, void 0, function* () {
            const { strategy = this.strategy, signal, selector, callbackUrl } = options;
            yield strategy.onInitialized();
            if ("receiver" in options)
              return yield this.legacySignMessage(options);
            const activeAccount = yield this.getAccountId().catch(() => void 0);
            const data7 = yield strategy.request({
              signal,
              callbackUrl,
              request: {
                type: "sign",
                message: options.message,
                recipient: options.recipient,
                nonce: Array.from(options.nonce),
                network: this.networkId,
                selector: selector || { id: activeAccount }
              }
            });
            if ((data7 === null || data7 === void 0 ? void 0 : data7.payload) == null)
              throw Error("Signature not found");
            const { publicKey, signature, accountId } = JSON.parse(data7.payload);
            return { publicKey, signature, accountId };
          });
        }
        legacySignMessage(_a) {
          var { receiver, message, nonce } = _a, delegate = __rest(_a, ["receiver", "message", "nonce"]);
          return __awaiter6(this, void 0, void 0, function* () {
            if (nonce == null) {
              let nonceArray = new Uint8Array(32);
              nonce = [...crypto.getRandomValues(nonceArray)];
            }
            const { strategy = this.strategy, callbackUrl, selector, signal } = delegate;
            const activeAccount = yield this.getAccountId().catch(() => void 0);
            const data7 = yield strategy.request({
              signal,
              callbackUrl,
              request: {
                type: "sign",
                network: this.networkId,
                selector: selector || { id: activeAccount },
                message,
                receiver,
                nonce
              }
            });
            if ((data7 === null || data7 === void 0 ? void 0 : data7.payload) == null) {
              throw Error("Signature not found");
            }
            try {
              const { publicKey, signature, accountId } = JSON.parse(data7.payload);
              const sign = new Uint8Array(Buffer.from(signature, "base64"));
              const json = JSON.stringify({ message, receiver, nonce });
              const msg = new Uint8Array(js_sha256_1.sha256.digest(`NEP0413:` + json));
              const isVerify = crypto_1.PublicKey.from(publicKey).verify(msg, sign);
              if (isVerify === false)
                throw Error();
              const account = yield this.account(accountId);
              const keys14 = yield account.getAccessKeys();
              const pb = publicKey.toString();
              const isValid = keys14.some((k) => {
                if (k.public_key !== pb)
                  return false;
                if (k.access_key.permission !== "FullAccess")
                  return false;
                return true;
              });
              if (isValid === false)
                throw Error();
              return {
                signature: new Uint8Array(Buffer.from(signature, "base64")),
                publicKey: crypto_1.PublicKey.from(publicKey),
                message: `NEP0413:` + json,
                receiver,
                accountId,
                nonce
              };
            } catch (_b) {
              throw Error("Signature not correct");
            }
          });
        }
        signAndSendTransactions(_a) {
          var { transactions: transactions4 } = _a, delegate = __rest(_a, ["transactions"]);
          return __awaiter6(this, void 0, void 0, function* () {
            const { strategy = this.strategy, selector, callbackUrl, signal } = delegate;
            yield strategy.onInitialized();
            let results = [];
            try {
              for (const call of transactions4) {
                const r = yield this.silentSignAndSendTransaction(call);
                results.push(r);
              }
              const payload = results.map((result) => result.transaction_outcome.id).join(",");
              const success = { type: "web", status: types_1.HereProviderStatus.SUCCESS, payload };
              strategy.onSuccess(success);
              return results;
            } catch (e) {
              try {
                if (!(e instanceof AccessDenied) && (e === null || e === void 0 ? void 0 : e.type) !== "NotEnoughAllowance") {
                  (0, utils_1.internalThrow)(e, strategy, selector);
                  throw e;
                }
                const activeAccount = yield this.getAccountId().catch(() => void 0);
                const uncompleted = transactions4.slice(results.length);
                const data7 = yield strategy.request({
                  signal,
                  callbackUrl,
                  request: {
                    type: "call",
                    network: this.networkId,
                    selector: selector || { id: uncompleted[0].signerId || activeAccount },
                    transactions: uncompleted.map((trx) => Object.assign(Object.assign({}, trx), { actions: (0, utils_1.serializeActions)(trx.actions) }))
                  }
                });
                if (data7.payload == null || data7.account_id == null) {
                  throw Error("Transaction not found, but maybe executed");
                }
                const promises = data7.payload.split(",").map((id7) => this.rpc.txStatus(id7, data7.account_id, "INCLUDED"));
                return yield Promise.all(promises);
              } catch (error2) {
                (0, utils_1.internalThrow)(error2, strategy, selector);
                throw error2;
              }
            }
          });
        }
      };
      exports2.HereWallet = HereWallet2;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/types.js
  var require_types4 = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/helpers/types.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/WindowStrategy.js
  var require_WindowStrategy = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/strategies/WindowStrategy.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __awaiter6 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve5) {
            resolve5(value);
          });
        }
        return new (P || (P = Promise))(function(resolve5, reject5) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject5(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject5(e);
            }
          }
          function step(result) {
            result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WindowStrategy = void 0;
      var HereStrategy_1 = require_HereStrategy();
      var WindowStrategy = class extends HereStrategy_1.HereStrategy {
        constructor(endpoint = "https://my.herewallet.app") {
          super();
          this.endpoint = endpoint;
          this.signWindow = null;
        }
        onInitialized() {
          return __awaiter6(this, void 0, void 0, function* () {
            if (this.signWindow)
              return;
            const left = window.innerWidth / 2 - 420 / 2;
            const top = window.innerHeight / 2 - 700 / 2;
            this.signWindow = window.open(`${this.endpoint}/loading`, "_blank", `popup=1,width=420,height=700,top=${top},left=${left}`);
          });
        }
        onRequested(id7, request3, reject5) {
          return __awaiter6(this, void 0, void 0, function* () {
            if (this.signWindow == null)
              return;
            this.unloadHandler = () => {
              var _a;
              return (_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.close();
            };
            window.addEventListener("beforeunload", this.unloadHandler);
            this.signWindow.location = `${this.endpoint}/request/${id7}`;
            this.timerHandler = setInterval(() => {
              var _a;
              if ((_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.closed)
                reject5("CLOSED");
            }, 1e3);
          });
        }
        close() {
          var _a;
          clearInterval(this.timerHandler);
          (_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.close();
          this.signWindow = null;
          if (this.unloadHandler) {
            window.removeEventListener("beforeunload", this.unloadHandler);
          }
        }
        onFailed() {
          return __awaiter6(this, void 0, void 0, function* () {
            this.close();
          });
        }
        onSuccess() {
          return __awaiter6(this, void 0, void 0, function* () {
            this.close();
          });
        }
      };
      exports2.WindowStrategy = WindowStrategy;
    }
  });

  // node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/index.js
  var require_build = __commonJS({
    "node_modules/@near-wallet-selector/here-wallet/node_modules/@here-wallet/core/build/index.js"(exports2) {
      "use strict";
      init_process();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HereWallet = void 0;
      var wallet_1 = require_wallet();
      Object.defineProperty(exports2, "HereWallet", { enumerable: true, get: function() {
        return wallet_1.HereWallet;
      } });
      __exportStar(require_waitInjected(), exports2);
      __exportStar(require_proxyMethods(), exports2);
      __exportStar(require_nep0314(), exports2);
      __exportStar(require_actions5(), exports2);
      __exportStar(require_types4(), exports2);
      __exportStar(require_utils35(), exports2);
      __exportStar(require_HereKeyStore(), exports2);
      __exportStar(require_JSONStorage(), exports2);
      __exportStar(require_HereStrategy(), exports2);
      __exportStar(require_InjectedStrategy(), exports2);
      __exportStar(require_TelegramAppStrategy(), exports2);
      __exportStar(require_WidgetStrategy(), exports2);
      __exportStar(require_WindowStrategy(), exports2);
      __exportStar(require_types3(), exports2);
    }
  });

  // wallet-selector.source.js
  init_process();
  init_buffer();

  // node_modules/@near-wallet-selector/core/index.js
  init_process();
  init_buffer();
  var nearAPI = __toESM(require_browser_index2(), 1);
  var import_near_api_js = __toESM(require_browser_index2(), 1);
  var import_providers = __toESM(require_providers(), 1);
  init_events();

  // node_modules/rxjs/dist/esm5/index.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  init_process();
  init_buffer();

  // node_modules/tslib/tslib.es6.mjs
  init_process();
  init_buffer();
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar2 = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar2;
  }
  function __spreadArray(to, from5, pack2) {
    if (pack2 || arguments.length === 2) for (var i = 0, l = from5.length, ar2; i < l; i++) {
      if (ar2 || !(i in from5)) {
        if (!ar2) ar2 = Array.prototype.slice.call(from5, 0, i);
        ar2[i] = from5[i];
      }
    }
    return to.concat(ar2 || Array.prototype.slice.call(from5));
  }

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  init_process();
  init_buffer();
  function isFunction3(value) {
    return typeof value === "function";
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  init_process();
  init_buffer();
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors2) {
      _super(this);
      this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors2;
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  init_process();
  init_buffer();
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = (function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors2;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction3(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors2 = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
                if (err instanceof UnsubscriptionError) {
                  errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
                } else {
                  errors2.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError(errors2);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent2) {
      var _parentage = this._parentage;
      return _parentage === parent2 || Array.isArray(_parentage) && _parentage.includes(parent2);
    };
    Subscription2.prototype._addParent = function(parent2) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent2), _parentage) : _parentage ? [_parentage, parent2] : parent2;
    };
    Subscription2.prototype._removeParent = function(parent2) {
      var _parentage = this._parentage;
      if (_parentage === parent2) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent2);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = (function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    })();
    return Subscription2;
  })();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction3(value.remove) && isFunction3(value.add) && isFunction3(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction3(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/config.js
  init_process();
  init_buffer();
  var config3 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  init_process();
  init_buffer();
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config3.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  init_process();
  init_buffer();
  function noop3() {
  }

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  init_process();
  init_buffer();
  var COMPLETE_NOTIFICATION = (function() {
    return createNotification("C", void 0, void 0);
  })();
  function errorNotification(error2) {
    return createNotification("E", void 0, error2);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  init_process();
  init_buffer();
  var context = null;
  function errorContext(cb) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error2 = _a.error;
        context = null;
        if (errorThrown) {
          throw error2;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config3.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = (function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next3, error2, complete) {
      return new SafeSubscriber(next3, error2, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  })(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = (function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    return ConsumerObserver2;
  })();
  var SafeSubscriber = (function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error2, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction3(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error2 !== null && error2 !== void 0 ? error2 : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config3.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  })(Subscriber);
  function handleUnhandledError(error2) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      captureError(error2);
    } else {
      reportUnhandledError(error2);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config3.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop3,
    error: defaultErrorHandler,
    complete: noop3
  };

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  init_process();
  init_buffer();
  var observable = (function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  })();

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  init_process();
  init_buffer();
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = (function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next3, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve5, reject5) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next3(value);
            } catch (err) {
              reject5(err);
              subscriber.unsubscribe();
            }
          },
          error: reject5,
          complete: resolve5
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve5, reject5) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject5(err);
        }, function() {
          return resolve5(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  })();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config3.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction3(value.next) && isFunction3(value.error) && isFunction3(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  init_process();
  init_buffer();
  function hasLift(source) {
    return isFunction3(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init3) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init3(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  init_process();
  init_buffer();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = (function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  })(Subscriber);

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  init_process();
  init_buffer();

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  init_process();
  init_buffer();
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = (function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  })(Observable);
  var AnonymousSubject = (function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  })(Subject);

  // node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  init_process();
  init_buffer();
  var BehaviorSubject = (function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  })(Subject);

  // node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
  init_process();
  init_buffer();
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && (function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      })));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scan.js
  init_process();
  init_buffer();
  function scan(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
  }

  // node_modules/@near-wallet-selector/core/index.js
  var import_borsh = __toESM(require_lib30(), 1);
  var import_js_sha256 = __toESM(require_sha2565(), 1);
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject5) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject5(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject5(e);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  var Provider = class {
    constructor(urls) {
      this.provider = new nearAPI.providers.FailoverRpcProvider(this.urlsToProviders(urls));
    }
    query(paramsOrPath, data7) {
      if (typeof paramsOrPath === "string" && data7 !== void 0) {
        return this.provider.query(paramsOrPath, data7);
      } else {
        return this.provider.query(paramsOrPath);
      }
    }
    viewAccessKey({
      accountId,
      publicKey
    }) {
      return this.query({
        request_type: "view_access_key",
        finality: "final",
        account_id: accountId,
        public_key: publicKey
      });
    }
    block(reference) {
      return this.provider.block(reference);
    }
    sendTransaction(signedTransaction) {
      return this.provider.sendTransaction(signedTransaction);
    }
    urlsToProviders(urls) {
      return urls && urls.length > 0 ? urls.map((url) => new import_providers.JsonRpcProvider({
        url
      })) : [];
    }
  };
  var KEY_DELIMITER = ":";
  var JsonStorage = class {
    constructor(storage, namespace) {
      this.storage = storage;
      this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;
    }
    resolveKey(key) {
      return [this.namespace, key].join(KEY_DELIMITER);
    }
    getItem(key) {
      return this.storage.getItem(this.resolveKey(key)).then((item) => {
        return typeof item === "string" ? JSON.parse(item) : null;
      });
    }
    setItem(key, value) {
      return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));
    }
    removeItem(key) {
      return this.storage.removeItem(this.resolveKey(key));
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var check = function(it) {
    return it && it.Math == Math && it;
  };
  var global$n = (
    // eslint-disable-next-line no-undef
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var objectGetOwnPropertyDescriptor = {};
  var fails$h = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var fails$g = fails$h;
  var descriptors = !fails$g(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectPropertyIsEnumerable = {};
  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$2(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;
  var createPropertyDescriptor$4 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var toString4 = {}.toString;
  var classofRaw$1 = function(it) {
    return toString4.call(it).slice(8, -1);
  };
  var fails$f = fails$h;
  var classof$9 = classofRaw$1;
  var split = "".split;
  var indexedObject = fails$f(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$9(it) == "String" ? split.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$4 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject$3 = indexedObject;
  var requireObjectCoercible$3 = requireObjectCoercible$4;
  var toIndexedObject$4 = function(it) {
    return IndexedObject$3(requireObjectCoercible$3(it));
  };
  var isObject$c = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var isObject$b = isObject$c;
  var toPrimitive$3 = function(input, PREFERRED_STRING) {
    if (!isObject$b(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$b(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$b(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$b(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var hasOwnProperty3 = {}.hasOwnProperty;
  var has$c = function(it, key) {
    return hasOwnProperty3.call(it, key);
  };
  var global$m = global$n;
  var isObject$a = isObject$c;
  var document$2 = global$m.document;
  var EXISTS = isObject$a(document$2) && isObject$a(document$2.createElement);
  var documentCreateElement$1 = function(it) {
    return EXISTS ? document$2.createElement(it) : {};
  };
  var DESCRIPTORS$a = descriptors;
  var fails$e = fails$h;
  var createElement$1 = documentCreateElement$1;
  var ie8DomDefine = !DESCRIPTORS$a && !fails$e(function() {
    return Object.defineProperty(createElement$1("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var DESCRIPTORS$9 = descriptors;
  var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
  var createPropertyDescriptor$3 = createPropertyDescriptor$4;
  var toIndexedObject$3 = toIndexedObject$4;
  var toPrimitive$2 = toPrimitive$3;
  var has$b = has$c;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;
  var nativeGetOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$9 ? nativeGetOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$3(O);
    P = toPrimitive$2(P, true);
    if (IE8_DOM_DEFINE$1) try {
      return nativeGetOwnPropertyDescriptor$1(O, P);
    } catch (error2) {
    }
    if (has$b(O, P)) return createPropertyDescriptor$3(!propertyIsEnumerableModule$1.f.call(O, P), O[P]);
  };
  var objectDefineProperty = {};
  var isObject$9 = isObject$c;
  var anObject$b = function(it) {
    if (!isObject$9(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var DESCRIPTORS$8 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var anObject$a = anObject$b;
  var toPrimitive$1 = toPrimitive$3;
  var nativeDefineProperty$1 = Object.defineProperty;
  objectDefineProperty.f = DESCRIPTORS$8 ? nativeDefineProperty$1 : function defineProperty(O, P, Attributes) {
    anObject$a(O);
    P = toPrimitive$1(P, true);
    anObject$a(Attributes);
    if (IE8_DOM_DEFINE) try {
      return nativeDefineProperty$1(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$7 = descriptors;
  var definePropertyModule$5 = objectDefineProperty;
  var createPropertyDescriptor$2 = createPropertyDescriptor$4;
  var createNonEnumerableProperty$a = DESCRIPTORS$7 ? function(object, key, value) {
    return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var redefine$5 = { exports: {} };
  var global$l = global$n;
  var createNonEnumerableProperty$9 = createNonEnumerableProperty$a;
  var setGlobal$3 = function(key, value) {
    try {
      createNonEnumerableProperty$9(global$l, key, value);
    } catch (error2) {
      global$l[key] = value;
    }
    return value;
  };
  var global$k = global$n;
  var setGlobal$2 = setGlobal$3;
  var SHARED = "__core-js_shared__";
  var store$3 = global$k[SHARED] || setGlobal$2(SHARED, {});
  var sharedStore = store$3;
  var store$2 = sharedStore;
  var functionToString = Function.toString;
  if (typeof store$2.inspectSource != "function") {
    store$2.inspectSource = function(it) {
      return functionToString.call(it);
    };
  }
  var inspectSource$3 = store$2.inspectSource;
  var global$j = global$n;
  var inspectSource$2 = inspectSource$3;
  var WeakMap$1 = global$j.WeakMap;
  var nativeWeakMap = typeof WeakMap$1 === "function" && /native code/.test(inspectSource$2(WeakMap$1));
  var shared$2 = { exports: {} };
  var store$1 = sharedStore;
  (shared$2.exports = function(key, value) {
    return store$1[key] || (store$1[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var id = 0;
  var postfix = Math.random();
  var uid$3 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
  };
  var shared$1 = shared$2.exports;
  var uid$2 = uid$3;
  var keys$1 = shared$1("keys");
  var sharedKey$3 = function(key) {
    return keys$1[key] || (keys$1[key] = uid$2(key));
  };
  var hiddenKeys$4 = {};
  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$i = global$n;
  var isObject$8 = isObject$c;
  var createNonEnumerableProperty$8 = createNonEnumerableProperty$a;
  var objectHas = has$c;
  var sharedKey$2 = sharedKey$3;
  var hiddenKeys$3 = hiddenKeys$4;
  var WeakMap2 = global$i.WeakMap;
  var set$2;
  var get$1;
  var has$a;
  var enforce = function(it) {
    return has$a(it) ? get$1(it) : set$2(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP) {
    store = new WeakMap2();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set$2 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get$1 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$a = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey$2("state");
    hiddenKeys$3[STATE] = true;
    set$2 = function(it, metadata) {
      createNonEnumerableProperty$8(it, STATE, metadata);
      return metadata;
    };
    get$1 = function(it) {
      return objectHas(it, STATE) ? it[STATE] : {};
    };
    has$a = function(it) {
      return objectHas(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState = {
    set: set$2,
    get: get$1,
    has: has$a,
    enforce,
    getterFor
  };
  var global$h = global$n;
  var createNonEnumerableProperty$7 = createNonEnumerableProperty$a;
  var has$9 = has$c;
  var setGlobal$1 = setGlobal$3;
  var inspectSource$1 = inspectSource$3;
  var InternalStateModule$4 = internalState;
  var getInternalState$4 = InternalStateModule$4.get;
  var enforceInternalState = InternalStateModule$4.enforce;
  var TEMPLATE = String(String).split("String");
  (redefine$5.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$9(value, "name")) createNonEnumerableProperty$7(value, "name", key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
    }
    if (O === global$h) {
      if (simple) O[key] = value;
      else setGlobal$1(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$7(O, key, value);
  })(Function.prototype, "toString", function toString5() {
    return typeof this == "function" && getInternalState$4(this).source || inspectSource$1(this);
  });
  var global$g = global$n;
  var path$1 = global$g;
  var path = path$1;
  var global$f = global$n;
  var aFunction$6 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$5 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction$6(path[namespace]) || aFunction$6(global$f[namespace]) : path[namespace] && path[namespace][method2] || global$f[namespace] && global$f[namespace][method2];
  };
  var objectGetOwnPropertyNames = {};
  var ceil = Math.ceil;
  var floor$1 = Math.floor;
  var toInteger$5 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);
  };
  var toInteger$4 = toInteger$5;
  var min$1 = Math.min;
  var toLength$b = function(argument) {
    return argument > 0 ? min$1(toInteger$4(argument), 9007199254740991) : 0;
  };
  var toInteger$3 = toInteger$5;
  var max = Math.max;
  var min = Math.min;
  var toAbsoluteIndex$3 = function(index, length) {
    var integer = toInteger$3(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
  };
  var toIndexedObject$2 = toIndexedObject$4;
  var toLength$a = toLength$b;
  var toAbsoluteIndex$2 = toAbsoluteIndex$3;
  var createMethod$3 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$2($this);
      var length = toLength$a(O.length);
      var index = toAbsoluteIndex$2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod$3(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$3(false)
  };
  var has$8 = has$c;
  var toIndexedObject$1 = toIndexedObject$4;
  var indexOf4 = arrayIncludes.indexOf;
  var hiddenKeys$2 = hiddenKeys$4;
  var objectKeysInternal = function(object, names) {
    var O = toIndexedObject$1(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$8(hiddenKeys$2, key) && has$8(O, key) && result.push(key);
    while (names.length > i) if (has$8(O, key = names[i++])) {
      ~indexOf4(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$3 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;
  var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys$1);
  };
  var objectGetOwnPropertySymbols = {};
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  var getBuiltIn$4 = getBuiltIn$5;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
  var anObject$9 = anObject$b;
  var ownKeys$1 = getBuiltIn$4("Reflect", "ownKeys") || function ownKeys(it) {
    var keys14 = getOwnPropertyNamesModule.f(anObject$9(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has$7 = has$c;
  var ownKeys2 = ownKeys$1;
  var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
  var definePropertyModule$4 = objectDefineProperty;
  var copyConstructorProperties$1 = function(target, source) {
    var keys14 = ownKeys2(source);
    var defineProperty14 = definePropertyModule$4.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule$1.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has$7(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$d = fails$h;
  var replacement = /#|\.prototype\./;
  var isForced$2 = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails$d(detection) : !!detection;
  };
  var normalize = isForced$2.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced$2.data = {};
  var NATIVE = isForced$2.NATIVE = "N";
  var POLYFILL = isForced$2.POLYFILL = "P";
  var isForced_1 = isForced$2;
  var global$e = global$n;
  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var createNonEnumerableProperty$6 = createNonEnumerableProperty$a;
  var redefine$4 = redefine$5.exports;
  var setGlobal = setGlobal$3;
  var copyConstructorProperties = copyConstructorProperties$1;
  var isForced$1 = isForced_1;
  var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$e;
    } else if (STATIC) {
      target = global$e[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global$e[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$6(sourceProperty, "sham", true);
      }
      redefine$4(target, key, sourceProperty, options);
    }
  };
  var global$d = global$n;
  var nativePromiseConstructor = global$d.Promise;
  var redefine$3 = redefine$5.exports;
  var redefineAll$2 = function(target, src, options) {
    for (var key in src) redefine$3(target, key, src[key], options);
    return target;
  };
  var fails$c = fails$h;
  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$c(function() {
    return !String(Symbol());
  });
  var NATIVE_SYMBOL$1 = nativeSymbol;
  var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var global$c = global$n;
  var shared = shared$2.exports;
  var has$6 = has$c;
  var uid$1 = uid$3;
  var NATIVE_SYMBOL = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var WellKnownSymbolsStore = shared("wks");
  var Symbol$1 = global$c.Symbol;
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
  var wellKnownSymbol$h = function(name) {
    if (!has$6(WellKnownSymbolsStore, name)) {
      if (NATIVE_SYMBOL && has$6(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
      else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  var defineProperty$4 = objectDefineProperty.f;
  var has$5 = has$c;
  var wellKnownSymbol$g = wellKnownSymbol$h;
  var TO_STRING_TAG$4 = wellKnownSymbol$g("toStringTag");
  var setToStringTag$4 = function(it, TAG, STATIC) {
    if (it && !has$5(it = STATIC ? it : it.prototype, TO_STRING_TAG$4)) {
      defineProperty$4(it, TO_STRING_TAG$4, { configurable: true, value: TAG });
    }
  };
  var getBuiltIn$3 = getBuiltIn$5;
  var definePropertyModule$3 = objectDefineProperty;
  var wellKnownSymbol$f = wellKnownSymbol$h;
  var DESCRIPTORS$6 = descriptors;
  var SPECIES$3 = wellKnownSymbol$f("species");
  var setSpecies$2 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
    var defineProperty14 = definePropertyModule$3.f;
    if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$3]) {
      defineProperty14(Constructor, SPECIES$3, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  var aFunction$5 = function(it) {
    if (typeof it != "function") {
      throw TypeError(String(it) + " is not a function");
    }
    return it;
  };
  var anInstance$3 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
    }
    return it;
  };
  var iterate$2 = { exports: {} };
  var iterators = {};
  var wellKnownSymbol$e = wellKnownSymbol$h;
  var Iterators$4 = iterators;
  var ITERATOR$5 = wellKnownSymbol$e("iterator");
  var ArrayPrototype$1 = Array.prototype;
  var isArrayIteratorMethod$2 = function(it) {
    return it !== void 0 && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
  };
  var aFunction$4 = aFunction$5;
  var functionBindContext = function(fn, that, length) {
    aFunction$4(fn);
    if (that === void 0) return fn;
    switch (length) {
      case 0:
        return function() {
          return fn.call(that);
        };
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var wellKnownSymbol$d = wellKnownSymbol$h;
  var TO_STRING_TAG$3 = wellKnownSymbol$d("toStringTag");
  var test = {};
  test[TO_STRING_TAG$3] = "z";
  var toStringTagSupport = String(test) === "[object z]";
  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$c = wellKnownSymbol$h;
  var TO_STRING_TAG$2 = wellKnownSymbol$c("toStringTag");
  var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
    return arguments;
  })()) == "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error2) {
    }
  };
  var classof$8 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
  };
  var classof$7 = classof$8;
  var Iterators$3 = iterators;
  var wellKnownSymbol$b = wellKnownSymbol$h;
  var ITERATOR$4 = wellKnownSymbol$b("iterator");
  var getIteratorMethod$2 = function(it) {
    if (it != void 0) return it[ITERATOR$4] || it["@@iterator"] || Iterators$3[classof$7(it)];
  };
  var anObject$8 = anObject$b;
  var callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES5) {
    try {
      return ENTRIES5 ? fn(anObject$8(value)[0], value[1]) : fn(value);
    } catch (error2) {
      var returnMethod = iterator["return"];
      if (returnMethod !== void 0) anObject$8(returnMethod.call(iterator));
      throw error2;
    }
  };
  var anObject$7 = anObject$b;
  var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
  var toLength$9 = toLength$b;
  var bind$4 = functionBindContext;
  var getIteratorMethod$1 = getIteratorMethod$2;
  var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
  var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var iterate$1 = iterate$2.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bind$4(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next3, step;
    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod$1(iterable);
      if (typeof iterFn != "function") throw TypeError("Target is not iterable");
      if (isArrayIteratorMethod$1(iterFn)) {
        for (index = 0, length = toLength$9(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject$7(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }
        return new Result(false);
      }
      iterator = iterFn.call(iterable);
    }
    next3 = iterator.next;
    while (!(step = next3.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == "object" && result && result instanceof Result) return result;
    }
    return new Result(false);
  };
  iterate$1.stop = function(result) {
    return new Result(true, result);
  };
  var wellKnownSymbol$a = wellKnownSymbol$h;
  var ITERATOR$3 = wellKnownSymbol$a("iterator");
  var SAFE_CLOSING = false;
  try {
    called = 0;
    iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$3] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error2) {
  }
  var called;
  var iteratorWithReturn;
  var checkCorrectnessOfIteration$2 = function(exec3, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$3] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec3(object);
    } catch (error2) {
    }
    return ITERATION_SUPPORT;
  };
  var anObject$6 = anObject$b;
  var aFunction$3 = aFunction$5;
  var wellKnownSymbol$9 = wellKnownSymbol$h;
  var SPECIES$2 = wellKnownSymbol$9("species");
  var speciesConstructor$2 = function(O, defaultConstructor) {
    var C = anObject$6(O).constructor;
    var S;
    return C === void 0 || (S = anObject$6(C)[SPECIES$2]) == void 0 ? defaultConstructor : aFunction$3(S);
  };
  var getBuiltIn$2 = getBuiltIn$5;
  var html$2 = getBuiltIn$2("document", "documentElement");
  var getBuiltIn$1 = getBuiltIn$5;
  var engineUserAgent = getBuiltIn$1("navigator", "userAgent") || "";
  var userAgent$1 = engineUserAgent;
  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent$1);
  var global$b = global$n;
  var fails$b = fails$h;
  var classof$6 = classofRaw$1;
  var bind$3 = functionBindContext;
  var html$1 = html$2;
  var createElement = documentCreateElement$1;
  var IS_IOS$1 = engineIsIos;
  var location2 = global$b.location;
  var set$1 = global$b.setImmediate;
  var clear = global$b.clearImmediate;
  var process$3 = global$b.process;
  var MessageChannel2 = global$b.MessageChannel;
  var Dispatch = global$b.Dispatch;
  var counter = 0;
  var queue3 = {};
  var ONREADYSTATECHANGE = "onreadystatechange";
  var defer;
  var channel;
  var port;
  var run = function(id7) {
    if (queue3.hasOwnProperty(id7)) {
      var fn = queue3[id7];
      delete queue3[id7];
      fn();
    }
  };
  var runner = function(id7) {
    return function() {
      run(id7);
    };
  };
  var listener = function(event) {
    run(event.data);
  };
  var post = function(id7) {
    global$b.postMessage(id7 + "", location2.protocol + "//" + location2.host);
  };
  if (!set$1 || !clear) {
    set$1 = function setImmediate2(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue3[++counter] = function() {
        (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id7) {
      delete queue3[id7];
    };
    if (classof$6(process$3) == "process") {
      defer = function(id7) {
        process$3.nextTick(runner(id7));
      };
    } else if (Dispatch && Dispatch.now) {
      defer = function(id7) {
        Dispatch.now(runner(id7));
      };
    } else if (MessageChannel2 && !IS_IOS$1) {
      channel = new MessageChannel2();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = bind$3(port.postMessage, port, 1);
    } else if (global$b.addEventListener && typeof postMessage == "function" && !global$b.importScripts && !fails$b(post) && location2.protocol !== "file:") {
      defer = post;
      global$b.addEventListener("message", listener, false);
    } else if (ONREADYSTATECHANGE in createElement("script")) {
      defer = function(id7) {
        html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
          html$1.removeChild(this);
          run(id7);
        };
      };
    } else {
      defer = function(id7) {
        setTimeout(runner(id7), 0);
      };
    }
  }
  var task$1 = {
    set: set$1,
    clear
  };
  var global$a = global$n;
  var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
  var classof$5 = classofRaw$1;
  var macrotask = task$1.set;
  var IS_IOS = engineIsIos;
  var MutationObserver = global$a.MutationObserver || global$a.WebKitMutationObserver;
  var process$2 = global$a.process;
  var Promise$1 = global$a.Promise;
  var IS_NODE$1 = classof$5(process$2) == "process";
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor2(global$a, "queueMicrotask");
  var queueMicrotask2 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
  var flush;
  var head;
  var last;
  var notify$1;
  var toggle;
  var node;
  var promise;
  var then;
  if (!queueMicrotask2) {
    flush = function() {
      var parent2, fn;
      if (IS_NODE$1 && (parent2 = process$2.domain)) parent2.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error2) {
          if (head) notify$1();
          else last = void 0;
          throw error2;
        }
      }
      last = void 0;
      if (parent2) parent2.enter();
    };
    if (IS_NODE$1) {
      notify$1 = function() {
        process$2.nextTick(flush);
      };
    } else if (MutationObserver && !IS_IOS) {
      toggle = true;
      node = document.createTextNode("");
      new MutationObserver(flush).observe(node, { characterData: true });
      notify$1 = function() {
        node.data = toggle = !toggle;
      };
    } else if (Promise$1 && Promise$1.resolve) {
      promise = Promise$1.resolve(void 0);
      then = promise.then;
      notify$1 = function() {
        then.call(promise, flush);
      };
    } else {
      notify$1 = function() {
        macrotask.call(global$a, flush);
      };
    }
  }
  var microtask$1 = queueMicrotask2 || function(fn) {
    var task5 = { fn, next: void 0 };
    if (last) last.next = task5;
    if (!head) {
      head = task5;
      notify$1();
    }
    last = task5;
  };
  var newPromiseCapability$2 = {};
  var aFunction$2 = aFunction$5;
  var PromiseCapability = function(C) {
    var resolve5, reject5;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve5 !== void 0 || reject5 !== void 0) throw TypeError("Bad Promise constructor");
      resolve5 = $$resolve;
      reject5 = $$reject;
    });
    this.resolve = aFunction$2(resolve5);
    this.reject = aFunction$2(reject5);
  };
  newPromiseCapability$2.f = function(C) {
    return new PromiseCapability(C);
  };
  var anObject$5 = anObject$b;
  var isObject$7 = isObject$c;
  var newPromiseCapability$1 = newPromiseCapability$2;
  var promiseResolve$1 = function(C, x) {
    anObject$5(C);
    if (isObject$7(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$1.f(C);
    var resolve5 = promiseCapability.resolve;
    resolve5(x);
    return promiseCapability.promise;
  };
  var global$9 = global$n;
  var hostReportErrors$1 = function(a, b) {
    var console2 = global$9.console;
    if (console2 && console2.error) {
      arguments.length === 1 ? console2.error(a) : console2.error(a, b);
    }
  };
  var perform$1 = function(exec3) {
    try {
      return { error: false, value: exec3() };
    } catch (error2) {
      return { error: true, value: error2 };
    }
  };
  var global$8 = global$n;
  var userAgent = engineUserAgent;
  var process$1 = global$8.process;
  var versions3 = process$1 && process$1.versions;
  var v8 = versions3 && versions3.v8;
  var match;
  var version3;
  if (v8) {
    match = v8.split(".");
    version3 = match[0] + match[1];
  } else if (userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version3 = match[1];
    }
  }
  var engineV8Version = version3 && +version3;
  var $$9 = _export;
  var global$7 = global$n;
  var getBuiltIn = getBuiltIn$5;
  var NativePromise = nativePromiseConstructor;
  var redefine$2 = redefine$5.exports;
  var redefineAll$1 = redefineAll$2;
  var setToStringTag$3 = setToStringTag$4;
  var setSpecies$1 = setSpecies$2;
  var isObject$6 = isObject$c;
  var aFunction$1 = aFunction$5;
  var anInstance$2 = anInstance$3;
  var classof$4 = classofRaw$1;
  var inspectSource = inspectSource$3;
  var iterate = iterate$2.exports;
  var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;
  var speciesConstructor$1 = speciesConstructor$2;
  var task = task$1.set;
  var microtask = microtask$1;
  var promiseResolve = promiseResolve$1;
  var hostReportErrors = hostReportErrors$1;
  var newPromiseCapabilityModule = newPromiseCapability$2;
  var perform = perform$1;
  var InternalStateModule$3 = internalState;
  var isForced = isForced_1;
  var wellKnownSymbol$8 = wellKnownSymbol$h;
  var V8_VERSION = engineV8Version;
  var SPECIES$1 = wellKnownSymbol$8("species");
  var PROMISE = "Promise";
  var getInternalState$3 = InternalStateModule$3.get;
  var setInternalState$3 = InternalStateModule$3.set;
  var getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);
  var PromiseConstructor = NativePromise;
  var TypeError$1 = global$7.TypeError;
  var document$1 = global$7.document;
  var process2 = global$7.process;
  var $fetch = getBuiltIn("fetch");
  var newPromiseCapability = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability;
  var IS_NODE = classof$4(process2) == "process";
  var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$7.dispatchEvent);
  var UNHANDLED_REJECTION = "unhandledrejection";
  var REJECTION_HANDLED = "rejectionhandled";
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal;
  var OwnPromiseCapability;
  var PromiseWrapper;
  var nativeThen;
  var FORCED$2 = isForced(PROMISE, function() {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE) {
      if (V8_VERSION === 66) return true;
      if (!IS_NODE && typeof PromiseRejectionEvent != "function") return true;
    }
    if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
    var promise5 = PromiseConstructor.resolve(1);
    var FakePromise = function(exec3) {
      exec3(function() {
      }, function() {
      });
    };
    var constructor = promise5.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    return !(promise5.then(function() {
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION = FORCED$2 || !checkCorrectnessOfIteration$1(function(iterable) {
    PromiseConstructor.all(iterable)["catch"](function() {
    });
  });
  var isThenable = function(it) {
    var then5;
    return isObject$6(it) && typeof (then5 = it.then) == "function" ? then5 : false;
  };
  var notify = function(promise5, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function() {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0;
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve5 = reaction.resolve;
        var reject5 = reaction.reject;
        var domain2 = reaction.domain;
        var result, then5, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(promise5, state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain2) domain2.enter();
              result = handler(value);
              if (domain2) {
                domain2.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject5(TypeError$1("Promise-chain cycle"));
            } else if (then5 = isThenable(result)) {
              then5.call(result, resolve5, reject5);
            } else resolve5(result);
          } else reject5(value);
        } catch (error2) {
          if (domain2 && !exited) domain2.exit();
          reject5(error2);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(promise5, state);
    });
  };
  var dispatchEvent = function(name, promise5, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$1.createEvent("Event");
      event.promise = promise5;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$7.dispatchEvent(event);
    } else event = { promise: promise5, reason };
    if (handler = global$7["on" + name]) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
  };
  var onUnhandled = function(promise5, state) {
    task.call(global$7, function() {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function() {
          if (IS_NODE) {
            process2.emit("unhandledRejection", value, promise5);
          } else dispatchEvent(UNHANDLED_REJECTION, promise5, value);
        });
        state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };
  var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
  };
  var onHandleUnhandled = function(promise5, state) {
    task.call(global$7, function() {
      if (IS_NODE) {
        process2.emit("rejectionHandled", promise5);
      } else dispatchEvent(REJECTION_HANDLED, promise5, state.value);
    });
  };
  var bind$2 = function(fn, promise5, state, unwrap) {
    return function(value) {
      fn(promise5, state, value, unwrap);
    };
  };
  var internalReject = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(promise5, state, true);
  };
  var internalResolve = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (promise5 === value) throw TypeError$1("Promise can't be resolved itself");
      var then5 = isThenable(value);
      if (then5) {
        microtask(function() {
          var wrapper = { done: false };
          try {
            then5.call(
              value,
              bind$2(internalResolve, promise5, wrapper, state),
              bind$2(internalReject, promise5, wrapper, state)
            );
          } catch (error2) {
            internalReject(promise5, wrapper, error2, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(promise5, state, false);
      }
    } catch (error2) {
      internalReject(promise5, { done: false }, error2, state);
    }
  };
  if (FORCED$2) {
    PromiseConstructor = function Promise2(executor) {
      anInstance$2(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState$3(this);
      try {
        executor(bind$2(internalResolve, this, state), bind$2(internalReject, this, state));
      } catch (error2) {
        internalReject(this, state, error2);
      }
    };
    Internal = function Promise2(executor) {
      setInternalState$3(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: void 0
      });
    };
    Internal.prototype = redefineAll$1(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then5(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
        reaction.fail = typeof onRejected == "function" && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability = function() {
      var promise5 = new Internal();
      var state = getInternalState$3(promise5);
      this.promise = promise5;
      this.resolve = bind$2(internalResolve, promise5, state);
      this.reject = bind$2(internalReject, promise5, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
      return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
    if (typeof NativePromise == "function") {
      nativeThen = NativePromise.prototype.then;
      redefine$2(NativePromise.prototype, "then", function then5(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve5, reject5) {
          nativeThen.call(that, resolve5, reject5);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      if (typeof $fetch == "function") $$9({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch2(input) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global$7, arguments));
        }
      });
    }
  }
  $$9({ global: true, wrap: true, forced: FORCED$2 }, {
    Promise: PromiseConstructor
  });
  setToStringTag$3(PromiseConstructor, PROMISE, false);
  setSpecies$1(PROMISE);
  PromiseWrapper = getBuiltIn(PROMISE);
  $$9({ target: PROMISE, stat: true, forced: FORCED$2 }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      capability.reject.call(void 0, r);
      return capability.promise;
    }
  });
  $$9({ target: PROMISE, stat: true, forced: FORCED$2 }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve(this, x);
    }
  });
  $$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve5 = capability.resolve;
      var reject5 = capability.reject;
      var result = perform(function() {
        var $promiseResolve = aFunction$1(C.resolve);
        var values2 = [];
        var counter5 = 0;
        var remaining = 1;
        iterate(iterable, function(promise5) {
          var index = counter5++;
          var alreadyCalled = false;
          values2.push(void 0);
          remaining++;
          $promiseResolve.call(C, promise5).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve5(values2);
          }, reject5);
        });
        --remaining || resolve5(values2);
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject5 = capability.reject;
      var result = perform(function() {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate(iterable, function(promise5) {
          $promiseResolve.call(C, promise5).then(capability.resolve, reject5);
        });
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    }
  });
  var WebStorageService = class {
    getItem(key) {
      return new Promise((resolve5) => {
        const value = localStorage.getItem(key);
        resolve5(value);
      });
    }
    setItem(key, value) {
      return new Promise((resolve5) => {
        localStorage.setItem(key, value);
        resolve5();
      });
    }
    removeItem(key) {
      return new Promise((resolve5) => {
        localStorage.removeItem(key);
        resolve5();
      });
    }
  };
  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys$1 = enumBugKeys$3;
  var objectKeys$2 = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys$1);
  };
  var DESCRIPTORS$5 = descriptors;
  var definePropertyModule$2 = objectDefineProperty;
  var anObject$4 = anObject$b;
  var objectKeys$1 = objectKeys$2;
  var objectDefineProperties = DESCRIPTORS$5 ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$4(O);
    var keys14 = objectKeys$1(Properties);
    var length = keys14.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$2.f(O, key = keys14[index++], Properties[key]);
    return O;
  };
  var anObject$3 = anObject$b;
  var defineProperties2 = objectDefineProperties;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys = hiddenKeys$4;
  var html = html$2;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$1 = sharedKey$3;
  var GT = ">";
  var LT = "<";
  var PROTOTYPE$1 = "prototype";
  var SCRIPT = "script";
  var IE_PROTO$1 = sharedKey$1("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument5) {
    activeXDocument5.write(scriptTag(""));
    activeXDocument5.close();
    var temp = activeXDocument5.parentWindow.Object;
    activeXDocument5 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = document.domain && new ActiveXObject("htmlfile");
    } catch (error2) {
    }
    NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
    return NullProtoObject();
  };
  hiddenKeys[IE_PROTO$1] = true;
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE$1] = anObject$3(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE$1] = null;
      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === void 0 ? result : defineProperties2(result, Properties);
  };
  var wellKnownSymbol$7 = wellKnownSymbol$h;
  var create$2 = objectCreate;
  var definePropertyModule$1 = objectDefineProperty;
  var UNSCOPABLES = wellKnownSymbol$7("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] == void 0) {
    definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create$2(null)
    });
  }
  var addToUnscopables$2 = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
  var requireObjectCoercible$2 = requireObjectCoercible$4;
  var toObject$7 = function(argument) {
    return Object(requireObjectCoercible$2(argument));
  };
  var fails$a = fails$h;
  var correctPrototypeGetter = !fails$a(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  var has$4 = has$c;
  var toObject$6 = toObject$7;
  var sharedKey = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var IE_PROTO = sharedKey("IE_PROTO");
  var ObjectPrototype$2 = Object.prototype;
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
    O = toObject$6(O);
    if (has$4(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == "function" && O instanceof O.constructor) {
      return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectPrototype$2 : null;
  };
  var getPrototypeOf$3 = objectGetPrototypeOf;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$a;
  var has$3 = has$c;
  var wellKnownSymbol$6 = wellKnownSymbol$h;
  var ITERATOR$2 = wellKnownSymbol$6("iterator");
  var BUGGY_SAFARI_ITERATORS$1 = false;
  var returnThis$2 = function() {
    return this;
  };
  var IteratorPrototype$2;
  var PrototypeOfArrayIteratorPrototype;
  var arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
    }
  }
  if (IteratorPrototype$2 == void 0) IteratorPrototype$2 = {};
  if (!has$3(IteratorPrototype$2, ITERATOR$2)) {
    createNonEnumerableProperty$5(IteratorPrototype$2, ITERATOR$2, returnThis$2);
  }
  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$2,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };
  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
  var create$1 = objectCreate;
  var createPropertyDescriptor$1 = createPropertyDescriptor$4;
  var setToStringTag$2 = setToStringTag$4;
  var Iterators$2 = iterators;
  var returnThis$1 = function() {
    return this;
  };
  var createIteratorConstructor$1 = function(IteratorConstructor, NAME2, next3) {
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    IteratorConstructor.prototype = create$1(IteratorPrototype$1, { next: createPropertyDescriptor$1(1, next3) });
    setToStringTag$2(IteratorConstructor, TO_STRING_TAG5, false);
    Iterators$2[TO_STRING_TAG5] = returnThis$1;
    return IteratorConstructor;
  };
  var isObject$5 = isObject$c;
  var aPossiblePrototype$1 = function(it) {
    if (!isObject$5(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + " as a prototype");
    }
    return it;
  };
  var anObject$2 = anObject$b;
  var aPossiblePrototype = aPossiblePrototype$1;
  var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test5 = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
      setter.call(test5, []);
      CORRECT_SETTER = test5 instanceof Array;
    } catch (error2) {
    }
    return function setPrototypeOf5(O, proto) {
      anObject$2(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  })() : void 0);
  var $$8 = _export;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf$2 = objectGetPrototypeOf;
  var setPrototypeOf$4 = objectSetPrototypeOf;
  var setToStringTag$1 = setToStringTag$4;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$a;
  var redefine$1 = redefine$5.exports;
  var wellKnownSymbol$5 = wellKnownSymbol$h;
  var Iterators$1 = iterators;
  var IteratorsCore = iteratorsCore;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol$5("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  var defineIterator$1 = function(Iterable, NAME2, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED5) {
    createIteratorConstructor(IteratorConstructor, NAME2, next3);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys14() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));
      if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf$4) {
            setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != "function") {
            createNonEnumerableProperty$4(CurrentIteratorPrototype, ITERATOR$1, returnThis);
          }
        }
        setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG5, true);
      }
    }
    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return nativeIterator.call(this);
      };
    }
    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
      createNonEnumerableProperty$4(IterablePrototype, ITERATOR$1, defaultIterator);
    }
    Iterators$1[NAME2] = defaultIterator;
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED5) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $$8({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    return methods;
  };
  var toIndexedObject = toIndexedObject$4;
  var addToUnscopables$1 = addToUnscopables$2;
  var Iterators = iterators;
  var InternalStateModule$2 = internalState;
  var defineIterator = defineIterator$1;
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState$2 = InternalStateModule$2.set;
  var getInternalState$2 = InternalStateModule$2.getterFor(ARRAY_ITERATOR);
  var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState$2(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState$2(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, "values");
  Iterators.Arguments = Iterators.Array;
  addToUnscopables$1("keys");
  addToUnscopables$1("values");
  addToUnscopables$1("entries");
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var global$6 = global$n;
  var DOMIterables = domIterables;
  var ArrayIteratorMethods = es_array_iterator;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$a;
  var wellKnownSymbol$4 = wellKnownSymbol$h;
  var ITERATOR = wellKnownSymbol$4("iterator");
  var TO_STRING_TAG$1 = wellKnownSymbol$4("toStringTag");
  var ArrayValues = ArrayIteratorMethods.values;
  for (COLLECTION_NAME in DOMIterables) {
    Collection = global$6[COLLECTION_NAME];
    CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
        createNonEnumerableProperty$3(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error2) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
      if (!CollectionPrototype[TO_STRING_TAG$1]) {
        createNonEnumerableProperty$3(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);
      }
      if (DOMIterables[COLLECTION_NAME]) for (METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
          createNonEnumerableProperty$3(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
        } catch (error2) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
        }
      }
    }
  }
  var Collection;
  var CollectionPrototype;
  var METHOD_NAME;
  var COLLECTION_NAME;
  var Logger = class _Logger {
    constructor(namespace) {
      this.namespace = namespace;
    }
    emit(method2, ...params) {
      if (!_Logger.debug) {
        return;
      }
      if (this.namespace && method2 !== "error") {
        console[method2](this.namespace, ...params);
        return;
      }
      console[method2](...params);
    }
    log(...params) {
      this.emit("log", ...params);
    }
    info(...params) {
      this.emit("info", ...params);
    }
    warn(...params) {
      this.emit("warn", ...params);
    }
    error(...params) {
      this.emit("error", ...params);
    }
  };
  Logger.debug = false;
  var logger = new Logger();
  var DESCRIPTORS$4 = descriptors;
  var fails$9 = fails$h;
  var has$2 = has$c;
  var defineProperty$3 = Object.defineProperty;
  var cache = {};
  var thrower = function(it) {
    throw it;
  };
  var arrayMethodUsesToLength$2 = function(METHOD_NAME, options) {
    if (has$2(cache, METHOD_NAME)) return cache[METHOD_NAME];
    if (!options) options = {};
    var method2 = [][METHOD_NAME];
    var ACCESSORS = has$2(options, "ACCESSORS") ? options.ACCESSORS : false;
    var argument0 = has$2(options, 0) ? options[0] : thrower;
    var argument1 = has$2(options, 1) ? options[1] : void 0;
    return cache[METHOD_NAME] = !!method2 && !fails$9(function() {
      if (ACCESSORS && !DESCRIPTORS$4) return true;
      var O = { length: -1 };
      if (ACCESSORS) defineProperty$3(O, 1, { enumerable: true, get: thrower });
      else O[1] = 1;
      method2.call(O, argument0, argument1);
    });
  };
  var $$7 = _export;
  var $includes = arrayIncludes.includes;
  var addToUnscopables = addToUnscopables$2;
  var arrayMethodUsesToLength$1 = arrayMethodUsesToLength$2;
  var USES_TO_LENGTH$1 = arrayMethodUsesToLength$1("indexOf", { ACCESSORS: true, 1: 0 });
  $$7({ target: "Array", proto: true, forced: !USES_TO_LENGTH$1 }, {
    includes: function includes3(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  addToUnscopables("includes");
  var DESCRIPTORS$3 = descriptors;
  var fails$8 = fails$h;
  var objectKeys2 = objectKeys$2;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var toObject$5 = toObject$7;
  var IndexedObject$2 = indexedObject;
  var nativeAssign = Object.assign;
  var defineProperty$2 = Object.defineProperty;
  var objectAssign = !nativeAssign || fails$8(function() {
    if (DESCRIPTORS$3 && nativeAssign({ b: 1 }, nativeAssign(defineProperty$2({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty$2(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return nativeAssign({}, A)[symbol] != 7 || objectKeys2(nativeAssign({}, B)).join("") != alphabet;
  }) ? function assign(target, source) {
    var T = toObject$5(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable7 = propertyIsEnumerableModule.f;
    while (argumentsLength > index) {
      var S = IndexedObject$2(arguments[index++]);
      var keys14 = getOwnPropertySymbols ? objectKeys2(S).concat(getOwnPropertySymbols(S)) : objectKeys2(S);
      var length = keys14.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys14[j++];
        if (!DESCRIPTORS$3 || propertyIsEnumerable7.call(S, key)) T[key] = S[key];
      }
    }
    return T;
  } : nativeAssign;
  var $$6 = _export;
  var assign2 = objectAssign;
  $$6({ target: "Object", stat: true, forced: Object.assign !== assign2 }, {
    assign: assign2
  });
  var isObject$4 = isObject$c;
  var classof$3 = classofRaw$1;
  var wellKnownSymbol$3 = wellKnownSymbol$h;
  var MATCH$1 = wellKnownSymbol$3("match");
  var isRegexp = function(it) {
    var isRegExp4;
    return isObject$4(it) && ((isRegExp4 = it[MATCH$1]) !== void 0 ? !!isRegExp4 : classof$3(it) == "RegExp");
  };
  var isRegExp2 = isRegexp;
  var notARegexp = function(it) {
    if (isRegExp2(it)) {
      throw TypeError("The method doesn't accept regular expressions");
    }
    return it;
  };
  var wellKnownSymbol$2 = wellKnownSymbol$h;
  var MATCH = wellKnownSymbol$2("match");
  var correctIsRegexpLogic = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (e) {
      try {
        regexp[MATCH] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (f) {
      }
    }
    return false;
  };
  var $$5 = _export;
  var notARegExp = notARegexp;
  var requireObjectCoercible$1 = requireObjectCoercible$4;
  var correctIsRegExpLogic = correctIsRegexpLogic;
  $$5({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
    includes: function includes4(searchString) {
      return !!~String(requireObjectCoercible$1(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var whitespaces$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  var requireObjectCoercible = requireObjectCoercible$4;
  var whitespaces$1 = whitespaces$2;
  var whitespace = "[" + whitespaces$1 + "]";
  var ltrim = RegExp("^" + whitespace + whitespace + "*");
  var rtrim = RegExp(whitespace + whitespace + "*$");
  var createMethod$2 = function(TYPE) {
    return function($this) {
      var string = String(requireObjectCoercible($this));
      if (TYPE & 1) string = string.replace(ltrim, "");
      if (TYPE & 2) string = string.replace(rtrim, "");
      return string;
    };
  };
  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
    start: createMethod$2(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
    end: createMethod$2(2),
    // `String.prototype.trim` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.trim
    trim: createMethod$2(3)
  };
  var fails$7 = fails$h;
  var whitespaces = whitespaces$2;
  var non = "\u200B\x85\u180E";
  var stringTrimForced = function(METHOD_NAME) {
    return fails$7(function() {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };
  var $$4 = _export;
  var $trim = stringTrim.trim;
  var forcedStringTrimMethod = stringTrimForced;
  $$4({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
    trim: function trim() {
      return $trim(this);
    }
  });
  var EventEmitter2 = class {
    constructor() {
      this.emitter = new EventEmitter();
    }
    on(eventName, callback) {
      this.emitter.on(eventName, callback);
      return {
        remove: () => this.emitter.off(eventName, callback)
      };
    }
    off(eventName, callback) {
      this.emitter.off(eventName, callback);
    }
    emit(eventName, event) {
      this.emitter.emit(eventName, event);
    }
  };
  var PACKAGE_NAME = "near-wallet-selector";
  var RECENTLY_SIGNED_IN_WALLETS = "recentlySignedInWallets";
  var REMEMBER_RECENT_WALLETS = "rememberRecentWallets";
  var REMEMBER_RECENT_WALLETS_STATE = {
    ENABLED: "enabled",
    DISABLED: "disabled"
  };
  var CONTRACT = "contract";
  var PENDING_CONTRACT = "contract:pending";
  var SELECTED_WALLET_ID = `selectedWalletId`;
  var PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;
  var WalletModules = class {
    constructor({
      factories,
      storage,
      options,
      store,
      emitter,
      provider
    }) {
      this.factories = factories;
      this.storage = storage;
      this.options = options;
      this.store = store;
      this.emitter = emitter;
      this.provider = provider;
      this.modules = [];
      this.instances = {};
    }
    validateWallet(id7) {
      return __awaiter(this, void 0, void 0, function* () {
        let accounts = [];
        const wallet = yield this.getWallet(id7);
        if (wallet) {
          accounts = yield wallet.getAccounts().catch((err) => {
            logger.log(`Failed to validate ${wallet.id} during setup`);
            logger.error(err);
            return [];
          });
        }
        return accounts;
      });
    }
    resolveStorageState() {
      return __awaiter(this, void 0, void 0, function* () {
        const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
        const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);
        const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);
        const rememberRecentWallets = yield jsonStorage.getItem(REMEMBER_RECENT_WALLETS);
        if (pendingSelectedWalletId && pendingContract) {
          const _accounts = yield this.validateWallet(pendingSelectedWalletId);
          yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);
          yield jsonStorage.removeItem(PENDING_CONTRACT);
          if (_accounts.length) {
            const {
              selectedWalletId: _selectedWalletId
            } = this.store.getState();
            const selectedWallet = yield this.getWallet(_selectedWalletId);
            if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {
              yield selectedWallet.signOut().catch((err) => {
                logger.log("Failed to sign out existing wallet");
                logger.error(err);
              });
            }
            let recentlySignedInWalletsFromPending = [];
            if (rememberRecentWallets === REMEMBER_RECENT_WALLETS_STATE.ENABLED) {
              recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);
            }
            return {
              accounts: _accounts,
              contract: pendingContract,
              selectedWalletId: pendingSelectedWalletId,
              recentlySignedInWallets: recentlySignedInWalletsFromPending,
              rememberRecentWallets: rememberRecentWallets || REMEMBER_RECENT_WALLETS_STATE.ENABLED
            };
          }
        }
        const {
          contract,
          selectedWalletId
        } = this.store.getState();
        const accounts = yield this.validateWallet(selectedWalletId);
        const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);
        if (!accounts.length) {
          return {
            accounts: [],
            contract: null,
            selectedWalletId: null,
            recentlySignedInWallets: recentlySignedInWallets || [],
            rememberRecentWallets: rememberRecentWallets || REMEMBER_RECENT_WALLETS_STATE.ENABLED
          };
        }
        return {
          accounts,
          contract,
          selectedWalletId,
          recentlySignedInWallets: recentlySignedInWallets || [],
          rememberRecentWallets: rememberRecentWallets || REMEMBER_RECENT_WALLETS_STATE.ENABLED
        };
      });
    }
    setWalletAsRecentlySignedIn(walletId) {
      return __awaiter(this, void 0, void 0, function* () {
        const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
        let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);
        if (!recentlySignedInWallets) {
          recentlySignedInWallets = [];
        }
        if (!recentlySignedInWallets.includes(walletId)) {
          recentlySignedInWallets.unshift(walletId);
          recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);
          yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);
        }
        return recentlySignedInWallets;
      });
    }
    signOutWallet(walletId) {
      return __awaiter(this, void 0, void 0, function* () {
        const wallet = yield this.getWallet(walletId);
        yield wallet.signOut().catch((err) => {
          logger.log(`Failed to sign out ${wallet.id}`);
          logger.error(err);
          this.onWalletSignedOut(wallet.id);
        });
      });
    }
    onWalletSignedIn(walletId, {
      accounts,
      contractId,
      methodNames
    }) {
      return __awaiter(this, void 0, void 0, function* () {
        const {
          selectedWalletId,
          rememberRecentWallets
        } = this.store.getState();
        const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
        const contract = {
          contractId,
          methodNames
        };
        if (!accounts.length) {
          const module2 = this.getModule(walletId);
          if (module2.type === "browser") {
            yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);
            yield jsonStorage.setItem(PENDING_CONTRACT, contract);
          }
          return;
        }
        if (selectedWalletId && selectedWalletId !== walletId) {
          yield this.signOutWallet(selectedWalletId);
        }
        let recentlySignedInWallets = [];
        if (rememberRecentWallets === REMEMBER_RECENT_WALLETS_STATE.ENABLED) {
          recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);
        }
        this.store.dispatch({
          type: "WALLET_CONNECTED",
          payload: {
            walletId,
            contract,
            accounts,
            recentlySignedInWallets,
            rememberRecentWallets
          }
        });
        this.emitter.emit("signedIn", {
          walletId,
          contractId,
          methodNames,
          accounts
        });
      });
    }
    onWalletSignedOut(walletId) {
      this.store.dispatch({
        type: "WALLET_DISCONNECTED",
        payload: {
          walletId
        }
      });
      this.emitter.emit("signedOut", {
        walletId
      });
    }
    setupWalletEmitter(module2) {
      const emitter = new EventEmitter2();
      emitter.on("signedOut", () => {
        this.onWalletSignedOut(module2.id);
      });
      emitter.on("signedIn", (event) => {
        this.onWalletSignedIn(module2.id, event);
      });
      emitter.on("accountsChanged", ({
        accounts
      }) => __awaiter(this, void 0, void 0, function* () {
        this.emitter.emit("accountsChanged", {
          walletId: module2.id,
          accounts
        });
        if (!accounts.length) {
          return this.signOutWallet(module2.id);
        }
        this.store.dispatch({
          type: "ACCOUNTS_CHANGED",
          payload: {
            walletId: module2.id,
            accounts
          }
        });
      }));
      emitter.on("networkChanged", ({
        networkId
      }) => {
        this.emitter.emit("networkChanged", {
          walletId: module2.id,
          networkId
        });
      });
      emitter.on("uriChanged", ({
        uri
      }) => {
        this.emitter.emit("uriChanged", {
          walletId: module2.id,
          uri
        });
      });
      return emitter;
    }
    validateSignMessageParams({
      message,
      nonce,
      recipient
    }) {
      if (!message || message.trim() === "") {
        throw new Error("Invalid message. It must be a non-empty string.");
      }
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {
        throw new Error("Invalid nonce. It must be a Buffer with a length of 32 bytes.");
      }
      if (!recipient || recipient.trim() === "") {
        throw new Error("Invalid recipient. It must be a non-empty string.");
      }
    }
    decorateWallet(wallet) {
      const _signIn = wallet.signIn;
      const _signOut = wallet.signOut;
      const _signMessage = wallet.signMessage;
      wallet.signIn = (params) => __awaiter(this, void 0, void 0, function* () {
        const accounts = yield _signIn(params);
        const {
          contractId,
          methodNames = []
        } = params;
        yield this.onWalletSignedIn(wallet.id, {
          accounts,
          contractId,
          methodNames
        });
        return accounts;
      });
      wallet.signOut = () => __awaiter(this, void 0, void 0, function* () {
        yield _signOut();
        this.onWalletSignedOut(wallet.id);
      });
      wallet.signMessage = (params) => __awaiter(this, void 0, void 0, function* () {
        if (_signMessage === void 0) {
          throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);
        }
        this.validateSignMessageParams(params);
        return yield _signMessage(params);
      });
      return wallet;
    }
    setupInstance(module2) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!module2.metadata.available) {
          const message = module2.type === "injected" ? "not installed" : "not available";
          throw Error(`${module2.metadata.name} is ${message}`);
        }
        const wallet = Object.assign({
          id: module2.id,
          type: module2.type,
          metadata: module2.metadata
        }, yield module2.init({
          id: module2.id,
          type: module2.type,
          metadata: module2.metadata,
          options: this.options,
          store: this.store.toReadOnly(),
          provider: this.provider,
          emitter: this.setupWalletEmitter(module2),
          logger: new Logger(module2.id),
          storage: new JsonStorage(this.storage, [PACKAGE_NAME, module2.id])
        }));
        return this.decorateWallet(wallet);
      });
    }
    getModule(id7) {
      return this.modules.find((x) => x.id === id7);
    }
    getWallet(id7) {
      return __awaiter(this, void 0, void 0, function* () {
        const module2 = this.getModule(id7);
        if (!module2) {
          return null;
        }
        const {
          selectedWalletId
        } = this.store.getState();
        if (!module2.metadata.available && selectedWalletId) {
          this.onWalletSignedOut(selectedWalletId);
          return null;
        }
        return yield module2.wallet();
      });
    }
    setup() {
      return __awaiter(this, void 0, void 0, function* () {
        const modules = [];
        for (let i = 0; i < this.factories.length; i += 1) {
          const module2 = yield this.factories[i]({
            options: this.options
          }).catch((err) => {
            logger.log("Failed to setup module");
            logger.error(err);
            return null;
          });
          if (!module2) {
            continue;
          }
          if (modules.some((x) => x.id === module2.id)) {
            continue;
          }
          modules.push({
            id: module2.id,
            type: module2.type,
            metadata: module2.metadata,
            wallet: () => __awaiter(this, void 0, void 0, function* () {
              let instance = this.instances[module2.id];
              if (instance) {
                return instance;
              }
              instance = yield this.setupInstance(module2);
              this.instances[module2.id] = instance;
              return instance;
            })
          });
        }
        this.modules = modules;
        const {
          accounts,
          contract,
          selectedWalletId,
          recentlySignedInWallets,
          rememberRecentWallets
        } = yield this.resolveStorageState();
        this.store.dispatch({
          type: "SETUP_WALLET_MODULES",
          payload: {
            modules,
            accounts,
            contract,
            selectedWalletId,
            recentlySignedInWallets,
            rememberRecentWallets
          }
        });
        for (let i = 0; i < this.modules.length; i++) {
          if (this.modules[i].type !== "instant-link") {
            continue;
          }
          const wallet = yield this.modules[i].wallet();
          if (!wallet.metadata.runOnStartup) {
            continue;
          }
          try {
            yield wallet.signIn({
              contractId: wallet.getContractId()
            });
          } catch (err) {
            logger.error("Failed to sign in to wallet. " + err);
          }
        }
      });
    }
  };
  var getNetworkPreset = (networkId, fallbackRpcUrls) => {
    switch (networkId) {
      case "mainnet":
        return {
          networkId,
          nodeUrl: (fallbackRpcUrls === null || fallbackRpcUrls === void 0 ? void 0 : fallbackRpcUrls[0]) || "https://rpc.mainnet.near.org",
          helperUrl: "https://helper.mainnet.near.org",
          explorerUrl: "https://nearblocks.io",
          indexerUrl: "https://api.kitwallet.app"
        };
      case "testnet":
        return {
          networkId,
          nodeUrl: (fallbackRpcUrls === null || fallbackRpcUrls === void 0 ? void 0 : fallbackRpcUrls[0]) || "https://rpc.testnet.near.org",
          helperUrl: "https://helper.testnet.near.org",
          explorerUrl: "https://testnet.nearblocks.io",
          indexerUrl: "https://testnet-api.kitwallet.app"
        };
      default:
        throw Error(`Failed to find config for: '${networkId}'`);
    }
  };
  var resolveNetwork = (network) => {
    return typeof network === "string" ? getNetworkPreset(network) : network;
  };
  var resolveOptions = (params) => {
    const options = {
      languageCode: params.languageCode || void 0,
      network: resolveNetwork(params.network),
      debug: params.debug || false,
      optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,
      randomizeWalletOrder: params.randomizeWalletOrder || false,
      relayerUrl: params.relayerUrl || void 0
    };
    return {
      options,
      storage: params.storage || new WebStorageService()
    };
  };
  var reducer = (state, action) => {
    logger.log("Store Action", action);
    switch (action.type) {
      case "SETUP_WALLET_MODULES": {
        const {
          modules,
          accounts,
          contract,
          selectedWalletId,
          recentlySignedInWallets,
          rememberRecentWallets
        } = action.payload;
        const accountStates = accounts.map((account, i) => {
          return Object.assign(Object.assign({}, account), {
            active: i === 0
          });
        });
        return Object.assign(Object.assign({}, state), {
          modules,
          accounts: accountStates,
          contract,
          selectedWalletId,
          recentlySignedInWallets,
          rememberRecentWallets
        });
      }
      case "WALLET_CONNECTED": {
        const {
          walletId,
          contract,
          accounts,
          recentlySignedInWallets
        } = action.payload;
        if (!accounts.length) {
          return state;
        }
        const activeAccountIndex = state.accounts.findIndex((account) => account.active);
        const accountStates = accounts.map((account, i) => {
          return Object.assign(Object.assign({}, account), {
            active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)
          });
        });
        return Object.assign(Object.assign({}, state), {
          contract,
          accounts: accountStates,
          selectedWalletId: walletId,
          recentlySignedInWallets
        });
      }
      case "WALLET_DISCONNECTED": {
        const {
          walletId
        } = action.payload;
        if (walletId !== state.selectedWalletId) {
          return state;
        }
        return Object.assign(Object.assign({}, state), {
          contract: null,
          accounts: [],
          selectedWalletId: null
        });
      }
      case "ACCOUNTS_CHANGED": {
        const {
          walletId,
          accounts
        } = action.payload;
        if (walletId !== state.selectedWalletId) {
          return state;
        }
        const activeAccount = state.accounts.find((account) => account.active);
        const isActiveAccountRemoved = !accounts.some((account) => account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));
        const accountStates = accounts.map((account, i) => {
          return Object.assign(Object.assign({}, account), {
            active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)
          });
        });
        return Object.assign(Object.assign({}, state), {
          accounts: accountStates
        });
      }
      case "SET_ACTIVE_ACCOUNT": {
        const {
          accountId
        } = action.payload;
        const accountStates = state.accounts.map((account) => {
          return Object.assign(Object.assign({}, account), {
            active: account.accountId === accountId
          });
        });
        return Object.assign(Object.assign({}, state), {
          accounts: accountStates
        });
      }
      case "SET_REMEMBER_RECENT_WALLETS": {
        const {
          selectedWalletId,
          recentlySignedInWallets
        } = state;
        const {
          rememberRecentWallets
        } = action.payload;
        const newRecentWallets = rememberRecentWallets === REMEMBER_RECENT_WALLETS_STATE.ENABLED ? REMEMBER_RECENT_WALLETS_STATE.DISABLED : REMEMBER_RECENT_WALLETS_STATE.ENABLED;
        const newWalletsVal = [...recentlySignedInWallets];
        if (selectedWalletId && !recentlySignedInWallets.includes(selectedWalletId)) {
          newWalletsVal.push(selectedWalletId);
        }
        const newRecentlySignedInWallets = newRecentWallets === REMEMBER_RECENT_WALLETS_STATE.ENABLED ? newWalletsVal : [];
        return Object.assign(Object.assign({}, state), {
          rememberRecentWallets: newRecentWallets,
          recentlySignedInWallets: newRecentlySignedInWallets
        });
      }
      default:
        return state;
    }
  };
  var createStore = (storage) => __awaiter(void 0, void 0, void 0, function* () {
    const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);
    const initialState = {
      modules: [],
      accounts: [],
      contract: yield jsonStorage.getItem(CONTRACT),
      selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),
      recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || [],
      rememberRecentWallets: (yield jsonStorage.getItem(REMEMBER_RECENT_WALLETS)) || ""
    };
    const state$ = new BehaviorSubject(initialState);
    const actions$ = new Subject();
    actions$.pipe(scan(reducer, initialState)).subscribe(state$);
    const syncStorage = (prevState2, state, storageKey, property) => __awaiter(void 0, void 0, void 0, function* () {
      if (state[property] === prevState2[property]) {
        return;
      }
      if (state[property]) {
        yield jsonStorage.setItem(storageKey, state[property]);
        return;
      }
      yield jsonStorage.removeItem(storageKey);
    });
    let prevState = state$.getValue();
    state$.subscribe((state) => {
      syncStorage(prevState, state, SELECTED_WALLET_ID, "selectedWalletId");
      syncStorage(prevState, state, CONTRACT, "contract");
      syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, "recentlySignedInWallets");
      syncStorage(prevState, state, REMEMBER_RECENT_WALLETS, "rememberRecentWallets");
      prevState = state;
    });
    return {
      observable: state$,
      getState: () => state$.getValue(),
      dispatch: (action) => actions$.next(action),
      toReadOnly: () => ({
        getState: () => state$.getValue(),
        observable: state$.asObservable()
      })
    };
  });
  var walletSelectorInstance = null;
  var createSelector = (options, store, walletModules, emitter) => {
    return {
      options,
      store: store.toReadOnly(),
      wallet: (id7) => __awaiter(void 0, void 0, void 0, function* () {
        const {
          selectedWalletId
        } = store.getState();
        const wallet = yield walletModules.getWallet(id7 || selectedWalletId);
        if (!wallet) {
          if (id7) {
            throw new Error("Invalid wallet id");
          }
          throw new Error("No wallet selected");
        }
        return wallet;
      }),
      setActiveAccount: (accountId) => {
        const {
          accounts
        } = store.getState();
        if (!accounts.some((account) => account.accountId === accountId)) {
          throw new Error("Invalid account id");
        }
        store.dispatch({
          type: "SET_ACTIVE_ACCOUNT",
          payload: {
            accountId
          }
        });
      },
      setRememberRecentWallets: () => {
        const {
          rememberRecentWallets
        } = store.getState();
        store.dispatch({
          type: "SET_REMEMBER_RECENT_WALLETS",
          payload: {
            rememberRecentWallets
          }
        });
      },
      isSignedIn() {
        const {
          accounts
        } = store.getState();
        return Boolean(accounts.length);
      },
      on: (eventName, callback) => {
        return emitter.on(eventName, callback);
      },
      off: (eventName, callback) => {
        emitter.off(eventName, callback);
      }
    };
  };
  var setupWalletSelector = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const {
      options,
      storage
    } = resolveOptions(params);
    Logger.debug = options.debug;
    const emitter = new EventEmitter2();
    const store = yield createStore(storage);
    const network = yield getNetworkPreset(options.network.networkId, params.fallbackRpcUrls);
    const rpcProviderUrls = params.fallbackRpcUrls && params.fallbackRpcUrls.length > 0 ? params.fallbackRpcUrls : [network.nodeUrl];
    const walletModules = new WalletModules({
      factories: params.modules,
      storage,
      options,
      store,
      emitter,
      provider: new Provider(rpcProviderUrls)
    });
    yield walletModules.setup();
    if (params.allowMultipleSelectors) {
      return createSelector(options, store, walletModules, emitter);
    }
    if (!walletSelectorInstance) {
      walletSelectorInstance = createSelector(options, store, walletModules, emitter);
    }
    return walletSelectorInstance;
  });
  var aFunction = aFunction$5;
  var toObject$4 = toObject$7;
  var IndexedObject$1 = indexedObject;
  var toLength$8 = toLength$b;
  var createMethod$1 = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      aFunction(callbackfn);
      var O = toObject$4(that);
      var self2 = IndexedObject$1(O);
      var length = toLength$8(O.length);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError("Reduce of empty array with no initial value");
        }
      }
      for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
      return memo;
    };
  };
  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
    left: createMethod$1(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
    right: createMethod$1(true)
  };
  var fails$6 = fails$h;
  var arrayMethodIsStrict$1 = function(METHOD_NAME, argument) {
    var method2 = [][METHOD_NAME];
    return !!method2 && fails$6(function() {
      method2.call(null, argument || function() {
        throw 1;
      }, 1);
    });
  };
  var $$3 = _export;
  var $reduce = arrayReduce.left;
  var arrayMethodIsStrict = arrayMethodIsStrict$1;
  var arrayMethodUsesToLength = arrayMethodUsesToLength$2;
  var STRICT_METHOD = arrayMethodIsStrict("reduce");
  var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
  $$3({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
    reduce: function reduce(callbackfn) {
      return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var anObject$1 = anObject$b;
  var regexpFlags$1 = function() {
    var that = anObject$1(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var regexpStickyHelpers = {};
  var fails$5 = fails$h;
  function RE(s, f) {
    return RegExp(s, f);
  }
  regexpStickyHelpers.UNSUPPORTED_Y = fails$5(function() {
    var re = RE("a", "y");
    re.lastIndex = 2;
    return re.exec("abcd") != null;
  });
  regexpStickyHelpers.BROKEN_CARET = fails$5(function() {
    var re = RE("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") != null;
  });
  var regexpFlags = regexpFlags$1;
  var stickyHelpers = regexpStickyHelpers;
  var nativeExec = RegExp.prototype.exec;
  var nativeReplace = String.prototype.replace;
  var patchedExec = nativeExec;
  var UPDATES_LAST_INDEX_WRONG = (function() {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, "a");
    nativeExec.call(re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();
  var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
  var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
  if (PATCH) {
    patchedExec = function exec3(str) {
      var re = this;
      var lastIndex, reCopy, match5, i;
      var sticky = UNSUPPORTED_Y && re.sticky;
      var flags6 = regexpFlags.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;
      if (sticky) {
        flags6 = flags6.replace("y", "");
        if (flags6.indexOf("g") === -1) {
          flags6 += "g";
        }
        strCopy = String(str).slice(re.lastIndex);
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags6);
      }
      if (NPCG_INCLUDED) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags6);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
      match5 = nativeExec.call(sticky ? reCopy : re, strCopy);
      if (sticky) {
        if (match5) {
          match5.input = match5.input.slice(charsAdded);
          match5[0] = match5[0].slice(charsAdded);
          match5.index = re.lastIndex;
          re.lastIndex += match5[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match5) {
        re.lastIndex = re.global ? match5.index + match5[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match5 && match5.length > 1) {
        nativeReplace.call(match5[0], reCopy, function() {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === void 0) match5[i] = void 0;
          }
        });
      }
      return match5;
    };
  }
  var regexpExec = patchedExec;
  var $$2 = _export;
  var exec = regexpExec;
  $$2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
    exec
  });
  var arrayBufferNative = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined";
  var toInteger$2 = toInteger$5;
  var toLength$7 = toLength$b;
  var toIndex$2 = function(it) {
    if (it === void 0) return 0;
    var number = toInteger$2(it);
    var length = toLength$7(number);
    if (number !== length) throw RangeError("Wrong length or index");
    return length;
  };
  var Infinity2 = 1 / 0;
  var abs = Math.abs;
  var pow = Math.pow;
  var floor2 = Math.floor;
  var log2 = Math.log;
  var LN2 = Math.LN2;
  var pack = function(number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number);
    if (number != number || number === Infinity2) {
      mantissa = number != number ? 1 : 0;
      exponent = eMax;
    } else {
      exponent = floor2(log2(number) / LN2);
      if (number * (c = pow(2, -exponent)) < 1) {
        exponent--;
        c *= 2;
      }
      if (exponent + eBias >= 1) {
        number += rt / c;
      } else {
        number += rt * pow(2, 1 - eBias);
      }
      if (number * c >= 2) {
        exponent++;
        c /= 2;
      }
      if (exponent + eBias >= eMax) {
        mantissa = 0;
        exponent = eMax;
      } else if (exponent + eBias >= 1) {
        mantissa = (number * c - 1) * pow(2, mantissaLength);
        exponent = exponent + eBias;
      } else {
        mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
        exponent = 0;
      }
    }
    for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8) ;
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8) ;
    buffer[--index] |= sign * 128;
    return buffer;
  };
  var unpack = function(buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8) ;
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8) ;
    if (exponent === 0) {
      exponent = 1 - eBias;
    } else if (exponent === eMax) {
      return mantissa ? NaN : sign ? -Infinity2 : Infinity2;
    } else {
      mantissa = mantissa + pow(2, mantissaLength);
      exponent = exponent - eBias;
    }
    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
  };
  var ieee754 = {
    pack,
    unpack
  };
  var toObject$3 = toObject$7;
  var toAbsoluteIndex$1 = toAbsoluteIndex$3;
  var toLength$6 = toLength$b;
  var arrayFill$1 = function fill3(value) {
    var O = toObject$3(this);
    var length = toLength$6(O.length);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex$1(argumentsLength > 1 ? arguments[1] : void 0, length);
    var end = argumentsLength > 2 ? arguments[2] : void 0;
    var endPos = end === void 0 ? length : toAbsoluteIndex$1(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };
  var global$5 = global$n;
  var DESCRIPTORS$2 = descriptors;
  var NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$a;
  var redefineAll = redefineAll$2;
  var fails$4 = fails$h;
  var anInstance$1 = anInstance$3;
  var toInteger$1 = toInteger$5;
  var toLength$5 = toLength$b;
  var toIndex$1 = toIndex$2;
  var IEEE754 = ieee754;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var setPrototypeOf$3 = objectSetPrototypeOf;
  var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var defineProperty$1 = objectDefineProperty.f;
  var arrayFill = arrayFill$1;
  var setToStringTag = setToStringTag$4;
  var InternalStateModule$1 = internalState;
  var getInternalState$1 = InternalStateModule$1.get;
  var setInternalState$1 = InternalStateModule$1.set;
  var ARRAY_BUFFER2 = "ArrayBuffer";
  var DATA_VIEW = "DataView";
  var PROTOTYPE = "prototype";
  var WRONG_LENGTH$1 = "Wrong length";
  var WRONG_INDEX = "Wrong index";
  var NativeArrayBuffer = global$5[ARRAY_BUFFER2];
  var $ArrayBuffer = NativeArrayBuffer;
  var $DataView = global$5[DATA_VIEW];
  var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
  var ObjectPrototype$1 = Object.prototype;
  var RangeError$2 = global$5.RangeError;
  var packIEEE754 = IEEE754.pack;
  var unpackIEEE754 = IEEE754.unpack;
  var packInt8 = function(number) {
    return [number & 255];
  };
  var packInt16 = function(number) {
    return [number & 255, number >> 8 & 255];
  };
  var packInt32 = function(number) {
    return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
  };
  var unpackInt32 = function(buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
  };
  var packFloat32 = function(number) {
    return packIEEE754(number, 23, 4);
  };
  var packFloat64 = function(number) {
    return packIEEE754(number, 52, 8);
  };
  var addGetter$1 = function(Constructor, key) {
    defineProperty$1(Constructor[PROTOTYPE], key, { get: function() {
      return getInternalState$1(this)[key];
    } });
  };
  var get3 = function(view, count, index, isLittleEndian) {
    var intIndex = toIndex$1(index);
    var store = getInternalState$1(view);
    if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
    var bytes = getInternalState$1(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack2 = bytes.slice(start, start + count);
    return isLittleEndian ? pack2 : pack2.reverse();
  };
  var set = function(view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex$1(index);
    var store = getInternalState$1(view);
    if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
    var bytes = getInternalState$1(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack2 = conversion(+value);
    for (var i = 0; i < count; i++) bytes[start + i] = pack2[isLittleEndian ? i : count - i - 1];
  };
  if (!NATIVE_ARRAY_BUFFER$1) {
    $ArrayBuffer = function ArrayBuffer2(length) {
      anInstance$1(this, $ArrayBuffer, ARRAY_BUFFER2);
      var byteLength3 = toIndex$1(length);
      setInternalState$1(this, {
        bytes: arrayFill.call(new Array(byteLength3), 0),
        byteLength: byteLength3
      });
      if (!DESCRIPTORS$2) this.byteLength = byteLength3;
    };
    $DataView = function DataView2(buffer, byteOffset, byteLength3) {
      anInstance$1(this, $DataView, DATA_VIEW);
      anInstance$1(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = getInternalState$1(buffer).byteLength;
      var offset = toInteger$1(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError$2("Wrong offset");
      byteLength3 = byteLength3 === void 0 ? bufferLength - offset : toLength$5(byteLength3);
      if (offset + byteLength3 > bufferLength) throw RangeError$2(WRONG_LENGTH$1);
      setInternalState$1(this, {
        buffer,
        byteLength: byteLength3,
        byteOffset: offset
      });
      if (!DESCRIPTORS$2) {
        this.buffer = buffer;
        this.byteLength = byteLength3;
        this.byteOffset = offset;
      }
    };
    if (DESCRIPTORS$2) {
      addGetter$1($ArrayBuffer, "byteLength");
      addGetter$1($DataView, "buffer");
      addGetter$1($DataView, "byteLength");
      addGetter$1($DataView, "byteOffset");
    }
    redefineAll($DataView[PROTOTYPE], {
      getInt8: function getInt8(byteOffset) {
        return get3(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get3(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset) {
        var bytes = get3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset) {
        var bytes = get3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset) {
        return unpackInt32(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
      },
      getUint32: function getUint32(byteOffset) {
        return unpackInt32(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset) {
        return unpackIEEE754(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
      },
      getFloat64: function getFloat64(byteOffset) {
        return unpackIEEE754(get3(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
      },
      setInt8: function setInt8(byteOffset, value) {
        set(this, 1, byteOffset, packInt8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set(this, 1, byteOffset, packInt8, value);
      },
      setInt16: function setInt16(byteOffset, value) {
        set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
      },
      setUint16: function setUint16(byteOffset, value) {
        set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
      },
      setInt32: function setInt32(byteOffset, value) {
        set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
      },
      setUint32: function setUint32(byteOffset, value) {
        set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
      },
      setFloat32: function setFloat32(byteOffset, value) {
        set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
      },
      setFloat64: function setFloat64(byteOffset, value) {
        set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
      }
    });
  } else {
    if (!fails$4(function() {
      NativeArrayBuffer(1);
    }) || !fails$4(function() {
      new NativeArrayBuffer(-1);
    }) || fails$4(function() {
      new NativeArrayBuffer();
      new NativeArrayBuffer(1.5);
      new NativeArrayBuffer(NaN);
      return NativeArrayBuffer.name != ARRAY_BUFFER2;
    })) {
      $ArrayBuffer = function ArrayBuffer2(length) {
        anInstance$1(this, $ArrayBuffer);
        return new NativeArrayBuffer(toIndex$1(length));
      };
      ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
      for (keys14 = getOwnPropertyNames$1(NativeArrayBuffer), j = 0; keys14.length > j; ) {
        if (!((key = keys14[j++]) in $ArrayBuffer)) {
          createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);
        }
      }
      ArrayBufferPrototype.constructor = $ArrayBuffer;
    }
    if (setPrototypeOf$3 && getPrototypeOf$1($DataViewPrototype) !== ObjectPrototype$1) {
      setPrototypeOf$3($DataViewPrototype, ObjectPrototype$1);
    }
    testView = new $DataView(new $ArrayBuffer(2));
    nativeSetInt8 = $DataViewPrototype.setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
      setInt8: function setInt8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      }
    }, { unsafe: true });
  }
  var ArrayBufferPrototype;
  var keys14;
  var j;
  var key;
  var testView;
  var nativeSetInt8;
  setToStringTag($ArrayBuffer, ARRAY_BUFFER2);
  setToStringTag($DataView, DATA_VIEW);
  var arrayBuffer = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
  };
  var $$1 = _export;
  var fails$3 = fails$h;
  var ArrayBufferModule$1 = arrayBuffer;
  var anObject = anObject$b;
  var toAbsoluteIndex = toAbsoluteIndex$3;
  var toLength$4 = toLength$b;
  var speciesConstructor = speciesConstructor$2;
  var ArrayBuffer$3 = ArrayBufferModule$1.ArrayBuffer;
  var DataView$2 = ArrayBufferModule$1.DataView;
  var nativeArrayBufferSlice = ArrayBuffer$3.prototype.slice;
  var INCORRECT_SLICE = fails$3(function() {
    return !new ArrayBuffer$3(2).slice(1, void 0).byteLength;
  });
  $$1({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
    slice: function slice3(start, end) {
      if (nativeArrayBufferSlice !== void 0 && end === void 0) {
        return nativeArrayBufferSlice.call(anObject(this), start);
      }
      var length = anObject(this).byteLength;
      var first = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
      var result = new (speciesConstructor(this, ArrayBuffer$3))(toLength$4(fin - first));
      var viewSource = new DataView$2(this);
      var viewTarget = new DataView$2(result);
      var index = 0;
      while (first < fin) {
        viewTarget.setUint8(index++, viewSource.getUint8(first++));
      }
      return result;
    }
  });
  var typedArrayConstructor = { exports: {} };
  var NATIVE_ARRAY_BUFFER = arrayBufferNative;
  var DESCRIPTORS$1 = descriptors;
  var global$4 = global$n;
  var isObject$3 = isObject$c;
  var has$1 = has$c;
  var classof$2 = classof$8;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$a;
  var redefine = redefine$5.exports;
  var defineProperty2 = objectDefineProperty.f;
  var getPrototypeOf = objectGetPrototypeOf;
  var setPrototypeOf$2 = objectSetPrototypeOf;
  var wellKnownSymbol$1 = wellKnownSymbol$h;
  var uid = uid$3;
  var Int8Array$3 = global$4.Int8Array;
  var Int8ArrayPrototype = Int8Array$3 && Int8Array$3.prototype;
  var Uint8ClampedArray = global$4.Uint8ClampedArray;
  var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
  var TypedArray$1 = Int8Array$3 && getPrototypeOf(Int8Array$3);
  var TypedArrayPrototype$1 = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
  var ObjectPrototype = Object.prototype;
  var isPrototypeOf = ObjectPrototype.isPrototypeOf;
  var TO_STRING_TAG = wellKnownSymbol$1("toStringTag");
  var TYPED_ARRAY_TAG$1 = uid("TYPED_ARRAY_TAG");
  var NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER && !!setPrototypeOf$2 && classof$2(global$4.opera) !== "Opera";
  var TYPED_ARRAY_TAG_REQIRED = false;
  var NAME;
  var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };
  var isView = function isView2(it) {
    var klass = classof$2(it);
    return klass === "DataView" || has$1(TypedArrayConstructorsList, klass);
  };
  var isTypedArray$1 = function(it) {
    return isObject$3(it) && has$1(TypedArrayConstructorsList, classof$2(it));
  };
  var aTypedArray$4 = function(it) {
    if (isTypedArray$1(it)) return it;
    throw TypeError("Target is not a typed array");
  };
  var aTypedArrayConstructor$2 = function(C) {
    if (setPrototypeOf$2) {
      if (isPrototypeOf.call(TypedArray$1, C)) return C;
    } else for (var ARRAY in TypedArrayConstructorsList) if (has$1(TypedArrayConstructorsList, NAME)) {
      var TypedArrayConstructor = global$4[ARRAY];
      if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
        return C;
      }
    }
    throw TypeError("Target is not a typed array constructor");
  };
  var exportTypedArrayMethod$4 = function(KEY, property, forced) {
    if (!DESCRIPTORS$1) return;
    if (forced) for (var ARRAY in TypedArrayConstructorsList) {
      var TypedArrayConstructor = global$4[ARRAY];
      if (TypedArrayConstructor && has$1(TypedArrayConstructor.prototype, KEY)) {
        delete TypedArrayConstructor.prototype[KEY];
      }
    }
    if (!TypedArrayPrototype$1[KEY] || forced) {
      redefine(TypedArrayPrototype$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype[KEY] || property);
    }
  };
  var exportTypedArrayStaticMethod$1 = function(KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!DESCRIPTORS$1) return;
    if (setPrototypeOf$2) {
      if (forced) for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global$4[ARRAY];
        if (TypedArrayConstructor && has$1(TypedArrayConstructor, KEY)) {
          delete TypedArrayConstructor[KEY];
        }
      }
      if (!TypedArray$1[KEY] || forced) {
        try {
          return redefine(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8Array$3[KEY] || property);
        } catch (error2) {
        }
      } else return;
    }
    for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global$4[ARRAY];
      if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
        redefine(TypedArrayConstructor, KEY, property);
      }
    }
  };
  for (NAME in TypedArrayConstructorsList) {
    if (!global$4[NAME]) NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
  }
  if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || typeof TypedArray$1 != "function" || TypedArray$1 === Function.prototype) {
    TypedArray$1 = function TypedArray2() {
      throw TypeError("Incorrect invocation");
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
      if (global$4[NAME]) setPrototypeOf$2(global$4[NAME], TypedArray$1);
    }
  }
  if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype) {
    TypedArrayPrototype$1 = TypedArray$1.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
      if (global$4[NAME]) setPrototypeOf$2(global$4[NAME].prototype, TypedArrayPrototype$1);
    }
  }
  if (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {
    setPrototypeOf$2(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
  }
  if (DESCRIPTORS$1 && !has$1(TypedArrayPrototype$1, TO_STRING_TAG)) {
    TYPED_ARRAY_TAG_REQIRED = true;
    defineProperty2(TypedArrayPrototype$1, TO_STRING_TAG, { get: function() {
      return isObject$3(this) ? this[TYPED_ARRAY_TAG$1] : void 0;
    } });
    for (NAME in TypedArrayConstructorsList) if (global$4[NAME]) {
      createNonEnumerableProperty$1(global$4[NAME], TYPED_ARRAY_TAG$1, NAME);
    }
  }
  var arrayBufferViewCore = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG$1,
    aTypedArray: aTypedArray$4,
    aTypedArrayConstructor: aTypedArrayConstructor$2,
    exportTypedArrayMethod: exportTypedArrayMethod$4,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,
    isView,
    isTypedArray: isTypedArray$1,
    TypedArray: TypedArray$1,
    TypedArrayPrototype: TypedArrayPrototype$1
  };
  var global$3 = global$n;
  var fails$2 = fails$h;
  var checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;
  var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var ArrayBuffer$2 = global$3.ArrayBuffer;
  var Int8Array$2 = global$3.Int8Array;
  var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$2(function() {
    Int8Array$2(1);
  }) || !fails$2(function() {
    new Int8Array$2(-1);
  }) || !checkCorrectnessOfIteration(function(iterable) {
    new Int8Array$2();
    new Int8Array$2(null);
    new Int8Array$2(1.5);
    new Int8Array$2(iterable);
  }, true) || fails$2(function() {
    return new Int8Array$2(new ArrayBuffer$2(2), 1, void 0).length !== 1;
  });
  var toInteger = toInteger$5;
  var toPositiveInteger$1 = function(it) {
    var result = toInteger(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
  };
  var toPositiveInteger = toPositiveInteger$1;
  var toOffset$2 = function(it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError("Wrong offset");
    return offset;
  };
  var toObject$2 = toObject$7;
  var toLength$3 = toLength$b;
  var getIteratorMethod = getIteratorMethod$2;
  var isArrayIteratorMethod = isArrayIteratorMethod$2;
  var bind$1 = functionBindContext;
  var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
  var typedArrayFrom$2 = function from3(source) {
    var O = toObject$2(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
    var mapping = mapfn !== void 0;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next3;
    if (iteratorMethod != void 0 && !isArrayIteratorMethod(iteratorMethod)) {
      iterator = iteratorMethod.call(O);
      next3 = iterator.next;
      O = [];
      while (!(step = next3.call(iterator)).done) {
        O.push(step.value);
      }
    }
    if (mapping && argumentsLength > 2) {
      mapfn = bind$1(mapfn, arguments[2], 2);
    }
    length = toLength$3(O.length);
    result = new (aTypedArrayConstructor$1(this))(length);
    for (i = 0; length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };
  var classof$1 = classofRaw$1;
  var isArray$1 = Array.isArray || function isArray4(arg) {
    return classof$1(arg) == "Array";
  };
  var isObject$2 = isObject$c;
  var isArray5 = isArray$1;
  var wellKnownSymbol = wellKnownSymbol$h;
  var SPECIES = wellKnownSymbol("species");
  var arraySpeciesCreate$1 = function(originalArray, length) {
    var C;
    if (isArray5(originalArray)) {
      C = originalArray.constructor;
      if (typeof C == "function" && (C === Array || isArray5(C.prototype))) C = void 0;
      else if (isObject$2(C)) {
        C = C[SPECIES];
        if (C === null) C = void 0;
      }
    }
    return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
  };
  var bind2 = functionBindContext;
  var IndexedObject = indexedObject;
  var toObject$1 = toObject$7;
  var toLength$2 = toLength$b;
  var arraySpeciesCreate = arraySpeciesCreate$1;
  var push = [].push;
  var createMethod2 = function(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
      var O = toObject$1($this);
      var self2 = IndexedObject(O);
      var boundFunction = bind2(callbackfn, that, 3);
      var length = toLength$2(self2.length);
      var index = 0;
      var create9 = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create9($this, length) : IS_FILTER ? create9($this, 0) : void 0;
      var value, result;
      for (; length > index; index++) if (NO_HOLES || index in self2) {
        value = self2[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result;
          else if (result) switch (TYPE) {
            case 3:
              return true;
            // some
            case 5:
              return value;
            // find
            case 6:
              return index;
            // findIndex
            case 2:
              push.call(target, value);
          }
          else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };
  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    forEach: createMethod2(0),
    // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    map: createMethod2(1),
    // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    filter: createMethod2(2),
    // `Array.prototype.some` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.some
    some: createMethod2(3),
    // `Array.prototype.every` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.every
    every: createMethod2(4),
    // `Array.prototype.find` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    find: createMethod2(5),
    // `Array.prototype.findIndex` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod2(6)
  };
  var isObject$1 = isObject$c;
  var setPrototypeOf$1 = objectSetPrototypeOf;
  var inheritIfRequired$1 = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
      // it can work only with native `setPrototypeOf`
      setPrototypeOf$1 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject$1(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
    ) setPrototypeOf$1($this, NewTargetPrototype);
    return $this;
  };
  var $ = _export;
  var global$2 = global$n;
  var DESCRIPTORS = descriptors;
  var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;
  var ArrayBufferViewCore$4 = arrayBufferViewCore;
  var ArrayBufferModule = arrayBuffer;
  var anInstance = anInstance$3;
  var createPropertyDescriptor = createPropertyDescriptor$4;
  var createNonEnumerableProperty = createNonEnumerableProperty$a;
  var toLength$1 = toLength$b;
  var toIndex = toIndex$2;
  var toOffset$1 = toOffset$2;
  var toPrimitive = toPrimitive$3;
  var has = has$c;
  var classof = classof$8;
  var isObject2 = isObject$c;
  var create2 = objectCreate;
  var setPrototypeOf = objectSetPrototypeOf;
  var getOwnPropertyNames2 = objectGetOwnPropertyNames.f;
  var typedArrayFrom$1 = typedArrayFrom$2;
  var forEach2 = arrayIteration.forEach;
  var setSpecies = setSpecies$2;
  var definePropertyModule = objectDefineProperty;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var InternalStateModule = internalState;
  var inheritIfRequired = inheritIfRequired$1;
  var getInternalState = InternalStateModule.get;
  var setInternalState = InternalStateModule.set;
  var nativeDefineProperty = definePropertyModule.f;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var round = Math.round;
  var RangeError$1 = global$2.RangeError;
  var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
  var DataView$1 = ArrayBufferModule.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;
  var TypedArray = ArrayBufferViewCore$4.TypedArray;
  var TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;
  var aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;
  var isTypedArray = ArrayBufferViewCore$4.isTypedArray;
  var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
  var WRONG_LENGTH = "Wrong length";
  var fromList2 = function(C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };
  var addGetter = function(it, key) {
    nativeDefineProperty(it, key, { get: function() {
      return getInternalState(this)[key];
    } });
  };
  var isArrayBuffer = function(it) {
    var klass;
    return it instanceof ArrayBuffer$1 || (klass = classof(it)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
  };
  var isTypedArrayIndex = function(target, key) {
    return isTypedArray(target) && typeof key != "symbol" && key in target && String(+key) == String(key);
  };
  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor3(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
  };
  var wrappedDefineProperty = function defineProperty3(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject2(descriptor) && has(descriptor, "value") && !has(descriptor, "get") && !has(descriptor, "set") && !descriptor.configurable && (!has(descriptor, "writable") || descriptor.writable) && (!has(descriptor, "enumerable") || descriptor.enumerable)) {
      target[key] = descriptor.value;
      return target;
    }
    return nativeDefineProperty(target, key, descriptor);
  };
  if (DESCRIPTORS) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
      definePropertyModule.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, "buffer");
      addGetter(TypedArrayPrototype, "byteOffset");
      addGetter(TypedArrayPrototype, "byteLength");
      addGetter(TypedArrayPrototype, "length");
    }
    $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    });
    typedArrayConstructor.exports = function(TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
      var GETTER = "get" + TYPE;
      var SETTER = "set" + TYPE;
      var NativeTypedArrayConstructor = global$2[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};
      var getter = function(that, index) {
        var data7 = getInternalState(that);
        return data7.view[GETTER](index * BYTES + data7.byteOffset, true);
      };
      var setter = function(that, index, value) {
        var data7 = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
        data7.view[SETTER](index * BYTES + data7.byteOffset, value, true);
      };
      var addElement = function(that, index) {
        nativeDefineProperty(that, index, {
          get: function() {
            return getter(this, index);
          },
          set: function(value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };
      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function(that, data7, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength3, length;
          if (!isObject2(data7)) {
            length = toIndex(data7);
            byteLength3 = length * BYTES;
            buffer = new ArrayBuffer$1(byteLength3);
          } else if (isArrayBuffer(data7)) {
            buffer = data7;
            byteOffset = toOffset$1(offset, BYTES);
            var $len = data7.byteLength;
            if ($length === void 0) {
              if ($len % BYTES) throw RangeError$1(WRONG_LENGTH);
              byteLength3 = $len - byteOffset;
              if (byteLength3 < 0) throw RangeError$1(WRONG_LENGTH);
            } else {
              byteLength3 = toLength$1($length) * BYTES;
              if (byteLength3 + byteOffset > $len) throw RangeError$1(WRONG_LENGTH);
            }
            length = byteLength3 / BYTES;
          } else if (isTypedArray(data7)) {
            return fromList2(TypedArrayConstructor, data7);
          } else {
            return typedArrayFrom$1.call(TypedArrayConstructor, data7);
          }
          setInternalState(that, {
            buffer,
            byteOffset,
            byteLength: byteLength3,
            length,
            view: new DataView$1(buffer)
          });
          while (index < length) addElement(that, index++);
        });
        if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create2(TypedArrayPrototype);
      } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1) {
        TypedArrayConstructor = wrapper(function(dummy, data7, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          return inheritIfRequired((function() {
            if (!isObject2(data7)) return new NativeTypedArrayConstructor(toIndex(data7));
            if (isArrayBuffer(data7)) return $length !== void 0 ? new NativeTypedArrayConstructor(data7, toOffset$1(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data7, toOffset$1(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data7);
            if (isTypedArray(data7)) return fromList2(TypedArrayConstructor, data7);
            return typedArrayFrom$1.call(TypedArrayConstructor, data7);
          })(), dummy, TypedArrayConstructor);
        });
        if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach2(getOwnPropertyNames2(NativeTypedArrayConstructor), function(key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }
      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
      }
      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }
      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
      $({
        global: true,
        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
        sham: !NATIVE_ARRAY_BUFFER_VIEWS
      }, exported);
      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }
      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }
      setSpecies(CONSTRUCTOR_NAME);
    };
  } else typedArrayConstructor.exports = function() {
  };
  var createTypedArrayConstructor = typedArrayConstructor.exports;
  createTypedArrayConstructor("Uint8", function(init3) {
    return function Uint8Array2(data7, byteOffset, length) {
      return init3(this, data7, byteOffset, length);
    };
  });
  var ArrayBufferViewCore$3 = arrayBufferViewCore;
  var $fill = arrayFill$1;
  var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
  var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;
  exportTypedArrayMethod$3("fill", function fill4(value) {
    return $fill.apply(aTypedArray$3(this), arguments);
  });
  var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;
  var exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;
  var typedArrayFrom = typedArrayFrom$2;
  exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
  var ArrayBufferViewCore$2 = arrayBufferViewCore;
  var toLength = toLength$b;
  var toOffset = toOffset$2;
  var toObject = toObject$7;
  var fails$1 = fails$h;
  var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
  var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;
  var FORCED$1 = fails$1(function() {
    new Int8Array(1).set({});
  });
  exportTypedArrayMethod$2("set", function set2(arrayLike) {
    aTypedArray$2(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError("Wrong length");
    while (index < len) this[offset + index] = src[index++];
  }, FORCED$1);
  var ArrayBufferViewCore$1 = arrayBufferViewCore;
  var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
  var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;
  var $sort = [].sort;
  exportTypedArrayMethod$1("sort", function sort(comparefn) {
    return $sort.call(aTypedArray$1(this), comparefn);
  });
  var global$1 = global$n;
  var ArrayBufferViewCore = arrayBufferViewCore;
  var fails = fails$h;
  var Int8Array$1 = global$1.Int8Array;
  var aTypedArray = ArrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
  var $toLocaleString = [].toLocaleString;
  var $slice = [].slice;
  var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails(function() {
    $toLocaleString.call(new Int8Array$1(1));
  });
  var FORCED = fails(function() {
    return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
  }) || !fails(function() {
    Int8Array$1.prototype.toLocaleString.call([1, 2]);
  });
  exportTypedArrayMethod("toLocaleString", function toLocaleString() {
    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
  }, FORCED);
  var modal$b = {
    wallet: {
      connectYourWallet: "Connect Your Wallet",
      whatIsAWallet: "What is a Wallet?",
      secureAndManage: "Secure & Manage Your Digital Assets",
      safelyStore: "Safely store and transfer your crypto and NFTs.",
      logInToAny: "Log In to Any NEAR App",
      noNeedToCreate: "No need to create new accounts or credentials. Connect your wallet and you are good to go!",
      getAWallet: "Get a Wallet",
      useAWallet: "Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.",
      connectionFailed: "Connection Failed",
      connectionSuccessful: "Connection Successful",
      rememberWallet: "Remember wallets",
      connected: "Connected",
      connectingTo: "Connecting to",
      connectingMessage: {
        injected: "Confirm the connection in the extension window",
        browser: "Confirm the connection in the wallet after redirect",
        hardware: "Confirm the connection in the ledger device",
        bridge: "Confirm the connection in the wallet"
      }
    },
    ledger: {
      connectWithLedger: "Connect with Ledger",
      makeSureYourLedger: "Make sure your Ledger is connected securely, and that the NEAR app is open on your device",
      "continue": "Continue",
      specifyHDPath: "Specify HD Path",
      enterYourPreferredHDPath: "Enter your preferred HD path, then scan for any active accounts.",
      scan: "Scan",
      retry: "Retry",
      ledgerIsNotAvailable: "Ledger is not available",
      accessDeniedToUseLedgerDevice: "Access denied to use Ledger device",
      noAccountsFound: "No Accounts Found",
      selectYourAccounts: "Select Your Accounts",
      connecting1Account: "Connecting 1 Account",
      cantFindAnyAccount: "Can't find any account associated with this Ledger. Please create a new NEAR account on",
      orConnectAnAnotherLedger: "or connect an another Ledger.",
      connecting: "Connecting",
      ofAccounts: "of Accounts",
      failedToAutomatically: "Failed to automatically find account id. Provide it manually:",
      overviewTheListOfAuthorized: "Overview the list of authorized account(s), complete sign in by clicking the button below.",
      finish: "Finish"
    },
    install: {
      youllNeedToInstall: "You'll need to install",
      toContinueAfterInstalling: "to continue. After installing",
      refreshThePage: "refresh the page.",
      open: "Open"
    },
    qr: {
      copiedToClipboard: "Copied to clipboard",
      failedToCopy: "Failed to copy to clipboard",
      scanWithYourMobile: "Scan with Your Mobile Device",
      copyToClipboard: " Copy to clipboard",
      preferTheOfficial: "Prefer the official dialogue of",
      open: "Open"
    },
    walletTypes: {
      hardware: "Hardware Wallet",
      browser: "Browser Wallet",
      injected: "Wallet Extension",
      bridge: "Bridge Wallet",
      mobile: "Mobile Wallet",
      "instant-link": "Instant Wallet"
    },
    exportAccounts: {
      chooseAWallet: "Choose a Wallet",
      transferYourAccounts: "Transfer Your Accounts",
      selectAWallet: "Select a wallet that fits your needs and supports your connected accounts.",
      selectYourAccounts: "Select Your Accounts",
      afterDecide: "After you decide on a wallet, you can select which accounts you want to transfer.",
      disclaimer: "You won\u2019t be able to transfer accounts that have never been funded or used on NEAR.",
      warning: "does not support account export at this time. Please select another wallet.",
      walletTypes: {
        hardware: "Hardware Wallet",
        browser: "Browser Wallet",
        injected: "Wallet Extension",
        bridge: "Bridge Wallet",
        mobile: "Mobile Wallet"
      },
      selectAccounts: {
        title: "Select Accounts to Transfer",
        button: "Continue",
        deselectAll: "Deselect All",
        selectAll: "Select All",
        unavailable: "Transfer Unavailable",
        error: "Account does not exist",
        warningLedger: "Ledger support required",
        noBalance: "Account not funded"
      },
      getPassphrase: {
        title: "Copy Temporary Password",
        desc: "You\u2019ll need to enter this password when you begin exporting your accounts to a different wallet.",
        button: "Continue",
        transferButton: "Transfer Accounts",
        label: "Click to Copy",
        checkLabel: "I copied or wrote down the password"
      },
      complete: {
        title: "Complete the Transfer",
        descOne: "You will now be redirected to the wallet you selected to complete the transfer.",
        descTwo: "Once import part of process is completed from selected wallet, press button to complete the transfer process.",
        startOverButton: "Start Over",
        button: "Complete"
      }
    }
  };
  var component$2 = {
    clickToCopy: {
      label: "Copied",
      tooltip: "Click to copy"
    }
  };
  var en = {
    modal: modal$b,
    component: component$2
  };
  var modal$a = {
    wallet: {
      connectYourWallet: "Conecta Tu Billetera",
      whatIsAWallet: "\xBFQue es una Billetera?",
      secureAndManage: "Resguarda y Administrar Tus Activos Digitales",
      safelyStore: "Almacena de forma segura y transfiere tus cryptos y NFT's",
      logInToAny: "Inicie sesi\xF3n en Cualquier Aplicacion NEAR",
      noNeedToCreate: "No es necesario crear nuevas cuentas o credenciales, \xA1Conecta tu billetera y listo!",
      getAWallet: "Obten una Billetera",
      useAWallet: "Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesi\xF3n en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contrase\xF1as",
      connectionFailed: "Conexi\xF3n Fallida",
      connectionSuccessful: "Conexi\xF3n Existosa",
      rememberWallet: "Recordar las carteras",
      connected: "Conectado",
      connectingTo: "Conectando a ",
      connectingMessage: {
        injected: "Confirme la conexi\xF3n en la ventana de extensi\xF3n",
        browser: "Confirme la conexi\xF3n en la billetera despu\xE9s de la redirecci\xF3n",
        hardware: "Confirme la conexi\xF3n en el dispositivo de libro mayor",
        bridge: "Confirmar la conexi\xF3n en la billetera"
      }
    },
    ledger: {
      connectWithLedger: "Conectar con Ledger",
      makeSureYourLedger: "Aseg\xFArese de que su ledger est\xE1 conectada de forma segura y que la aplicacion NEAR est\xE9 abierta en su dispositivo",
      "continue": "Continuar",
      specifyHDPath: "Especifique la ruta HD",
      enterYourPreferredHDPath: "Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.",
      scan: "Escanear",
      retry: "Reintentar",
      ledgerIsNotAvailable: "El Ledger no est\xE1 disponible",
      accessDeniedToUseLedgerDevice: "Acceso denegado para usar el dispositivo ledger",
      noAccountsFound: "No se encontraron cuentas",
      selectYourAccounts: "Selecciona tus cuentas",
      connecting1Account: "Conectando a 1 cuenta",
      cantFindAnyAccount: "No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR",
      orConnectAnAnotherLedger: "o conecta otro ledger",
      connecting: "Conectando",
      ofAccounts: "de Cuentas",
      failedToAutomatically: "No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:",
      overviewTheListOfAuthorized: "Revise la lista de las cuentas autorizadas,Complete el inicio de sesi\xF3n haciedo click a countinuacion.",
      finish: "Finalizar"
    },
    install: {
      youllNeedToInstall: "Tendr\xE1s que instalar",
      toContinueAfterInstalling: "Para continuar, Despues de instalar",
      refreshThePage: "Recarga la pagina",
      open: "Abrir"
    },
    qr: {
      copiedToClipboard: "Copiado al Portapapeles",
      failedToCopy: "Fall\xF3 la copia al Portapapeles",
      scanWithYourMobile: "Busca con tu dispositivo movil",
      copyToClipboard: " Copiar al Portapapeles",
      preferTheOfficial: "\xBFPrefires el di\xE1logo oficial de",
      open: "Abrir"
    },
    walletTypes: {
      hardware: "Cartera de Hardware",
      browser: "Cartera de Navegador",
      injected: "Extensi\xF3n de Cartera",
      bridge: "Cartera de Puente",
      mobile: "Cartera M\xF3vil",
      "instant-link": "Cartera Instant\xE1nea"
    }
  };
  var es = {
    modal: modal$a
  };
  var modal$9 = {
    wallet: {
      connectYourWallet: "\u8FDE\u63A5\u4F60\u7684\u94B1\u5305",
      whatIsAWallet: "\u4EC0\u4E48\u662F\u94B1\u5305\uFF1F",
      secureAndManage: "\u4FDD\u62A4\u548C\u7BA1\u7406\u4F60\u7684\u6570\u5B57\u8D44\u4EA7",
      safelyStore: "\u5B89\u5168\u5B58\u50A8\u548C\u8F6C\u79FB\u4F60\u7684\u52A0\u5BC6\u8D27\u5E01\u548CNFT",
      logInToAny: "\u767B\u5F55\u4EFB\u4F55 NEAR \u5E94\u7528",
      noNeedToCreate: "\u4E0D\u9700\u8981\u521B\u5EFA\u65B0\u8D26\u6237\u6216\u5BC6\u7801\u3002\u8FDE\u63A5\u4F60\u7684\u94B1\u5305\uFF0C\u5373\u53EF\u5F00\u59CB\u4F7F\u7528\uFF01",
      getAWallet: "\u83B7\u53D6\u65B0\u8D26\u6237",
      useAWallet: "\u4F7F\u7528\u94B1\u5305\u6765\u4FDD\u62A4\u548C\u7BA1\u7406\u4F60\u7684 NEAR \u8D44\u4EA7\uFF0C\u65E0\u9700\u7528\u6237\u540D\u548C\u5BC6\u7801\u5373\u53EF\u767B\u5F55\u4EFB\u4F55 NEAR \u5E94\u7528",
      connectionFailed: "\u8FDE\u63A5\u5931\u8D25",
      connectionSuccessful: "\u8FDE\u63A5\u6210\u529F",
      rememberWallet: "\u8BB0\u4F4F\u94B1\u5305\u9009\u62E9",
      connected: "\u5DF2\u8FDE\u63A5",
      connectingTo: "\u6B63\u5728\u8FDE\u63A5"
    },
    ledger: {
      connectWithLedger: "\u8FDE\u63A5 Ledger",
      makeSureYourLedger: "\u786E\u4FDD\u4F60\u7684 Ledger \u5DF2\u7ECF\u5B89\u5168\u8FDE\u63A5\uFF0C\u5E76\u4E14 NEAR \u5E94\u7528\u5DF2\u7ECF\u5728\u4F60\u8BBE\u5907\u4E0A\u6253\u5F00",
      "continue": "\u7EE7\u7EED",
      specifyHDPath: "\u6307\u5B9A HD \u8DEF\u5F84",
      enterYourPreferredHDPath: "\u8F93\u5165\u4F60\u504F\u597D\u7684 HD \u8DEF\u5F84\uFF0C\u7136\u540E\u4E3A\u4EFB\u610F\u6D3B\u8DC3\u8D26\u6237\u626B\u7801",
      scan: "\u626B\u7801",
      retry: "\u91CD\u8BD5",
      ledgerIsNotAvailable: "Ledger \u4E0D\u53EF\u7528",
      accessDeniedToUseLedgerDevice: "\u8BBF\u95EE Ledger \u8BBE\u5907\u88AB\u62D2\u7EDD",
      noAccountsFound: "\u6CA1\u6709\u627E\u5230\u8D26\u6237",
      selectYourAccounts: "\u9009\u62E9\u4F60\u7684\u8D26\u6237",
      connecting1Account: "\u6B63\u5728\u8FDE\u63A51\u4E2A\u8D26\u6237",
      cantFindAnyAccount: "\u6CA1\u6709\u627E\u5230\u4EFB\u4F55\u4E0E\u8FD9\u4E2A Ledger \u76F8\u5173\u8054\u7684\u8D26\u6237\u3002\u8BF7\u521B\u5EFA\u65B0\u8D26\u6237\u4E8E",
      "orConnectAnAnotherLedger.": "\u6216\u8FDE\u63A5\u53E6\u4E00\u4E2A Ledger",
      connecting: "\u6B63\u5728\u8FDE\u63A5",
      ofAccounts: "\u4E2A\u8D26\u6237",
      failedToAutomatically: "\u65E0\u6CD5\u81EA\u52A8\u627E\u5230\u8D26\u6237ID\uFF0C\u8BF7\u4E3B\u52A8\u63D0\u4F9B\uFF1A",
      overviewTheListOfAuthorized: "\u8BF7\u67E5\u770B\u5DF2\u6388\u6743\u7684\u8D26\u6237\u5217\u8868\uFF0C\u70B9\u51FB\u4EE5\u4E0B\u6309\u94AE\u5B8C\u6210\u767B\u5F55",
      finish: "\u5B8C\u6210"
    },
    install: {
      youllNeedToInstall: "\u4F60\u5C06\u9700\u8981\u5B89\u88C5",
      toContinueAfterInstalling: "\u4EE5\u7EE7\u7EED\u3002\u5B89\u88C5\u5B8C",
      refreshThePage: "\u8BF7\u5237\u65B0\u9875\u9762",
      open: "\u6253\u5F00"
    },
    qr: {
      copiedToClipboard: "\u590D\u5236\u5230\u4E86\u526A\u8D34\u677F",
      failedToCopy: "\u590D\u5236\u5230\u526A\u8D34\u677F\u5931\u8D25",
      scanWithYourMobile: "\u7528\u4F60\u7684\u79FB\u52A8\u8BBE\u5907\u626B\u7801",
      copyToClipboard: " \u590D\u5236\u5230\u526A\u8D34\u677F",
      preferTheOfficial: "\u5E0C\u671B\u4F7F\u7528\u5B98\u65B9\u5BF9\u8BDD\u6846\u4E8E",
      open: "\u6253\u5F00"
    },
    walletTypes: {
      hardware: "\u786C\u4EF6\u94B1\u5305",
      browser: "\u6D4F\u89C8\u5668\u94B1\u5305",
      injected: "\u94B1\u5305\u6269\u5C55",
      bridge: "\u6865\u63A5\u94B1\u5305",
      mobile: "\u79FB\u52A8\u94B1\u5305",
      "instant-link": "\u5373\u65F6\u94B1\u5305"
    }
  };
  var zh = {
    modal: modal$9
  };
  var modal$8 = {
    wallet: {
      connectYourWallet: "\u0421\u0432\u044A\u0440\u0436\u0435\u0442\u0435 \u0432\u0430\u0448\u0438\u044F \u041F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      whatIsAWallet: "\u041A\u0430\u043A\u0432\u043E \u0435 \u041F\u043E\u0440\u0442\u0444\u0435\u0439\u043B?",
      secureAndManage: "\u0417\u0430\u0449\u0438\u0442\u0435\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u044F\u0432\u0430\u0439\u0442\u0435 \u0434\u0438\u0433\u0438\u0442\u0430\u043B\u043D\u0438\u0442\u0435 \u0441\u0438 \u0430\u043A\u0442\u0438\u0432\u0438",
      safelyStore: "\u0421\u044A\u0445\u0440\u0430\u043D\u044F\u0432\u0430\u0439\u0442\u0435 \u0438 \u043F\u0440\u0435\u0445\u0432\u044A\u0440\u043B\u044F\u0439\u0442\u0435 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E \u0432\u0430\u0448\u0438\u0442\u0435 \u043A\u0440\u0438\u043F\u0442\u043E \u0438 NFT.",
      logInToAny: "\u0418\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u0439\u0442\u0435 \u0432\u0441\u044F\u043A\u043E \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 NEAR",
      noNeedToCreate: "\u041D\u044F\u043C\u0430 \u043D\u0443\u0436\u0434\u0430 \u0434\u0430 \u0441\u044A\u0437\u0434\u0430\u0432\u0430\u0442\u0435 \u043D\u043E\u0432\u0438 \u043F\u0440\u043E\u0444\u0438\u043B\u0438. \u0421\u0432\u044A\u0440\u0436\u0435\u0442\u0435 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B\u0430 \u0441\u0438 \u0438 \u0441\u0442\u0435 \u0433\u043E\u0442\u043E\u0432\u0438!",
      getAWallet: "\u0421\u044A\u0437\u0434\u0430\u0439\u0442\u0435 \u041F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      useAWallet: "\u0418\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u0439\u0442\u0435 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B\u0430, \u0437\u0430 \u0434\u0430 \u0437\u0430\u0449\u0438\u0442\u0438\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u044F\u0432\u0430\u0442\u0435 \u0430\u043A\u0442\u0438\u0432\u0438\u0442\u0435 \u0441\u0438 \u043D\u0430 NEAR \u043A\u0430\u043A\u0442\u043E \u0438 \u0434\u0430 \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u0442\u0435 \u0432\u0441\u044F\u043A\u043E \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 NEAR \u0431\u0435\u0437 \u043D\u0443\u0436\u0434\u0430 \u043E\u0442 \u043F\u043E\u0442\u0440\u0435\u0431\u0438\u0442\u0435\u043B\u0441\u043A\u0438 \u0438\u043C\u0435\u043D\u0430 \u0438 \u043F\u0430\u0440\u043E\u043B\u0438.",
      connectionFailed: "\u0421\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u043D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u043E",
      connectionSuccessful: "\u0421\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u0443\u0441\u043F\u0435\u0448\u043D\u043E",
      rememberWallet: "\u0417\u0430\u043F\u0430\u0437\u0438 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B\u0438\u0442\u0435",
      connected: "\u0421\u0432\u044A\u0440\u0437\u0430\u043D",
      connectingTo: "\u0421\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435 \u043A\u044A\u043C",
      connectingMessage: {
        injected: "\u041F\u043E\u0442\u0432\u044A\u0440\u0434\u0435\u0442\u0435 \u0441\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u0432 \u043F\u0440\u043E\u0437\u043E\u0440\u0435\u0446\u0430 \u043D\u0430 \u0440\u0430\u0437\u0448\u0438\u0440\u0435\u043D\u0438\u0435\u0442\u043E",
        browser: "\u041F\u043E\u0442\u0432\u044A\u0440\u0434\u0435\u0442\u0435 \u0441\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u0432 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B\u0430 \u0441\u043B\u0435\u0434 \u043F\u0440\u0435\u043D\u0430\u0441\u043E\u0447\u0432\u0430\u043D\u0435\u0442\u043E",
        hardware: "\u041F\u043E\u0442\u0432\u044A\u0440\u0434\u0435\u0442\u0435 \u0441\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u0432 \u0445\u0430\u0440\u0434\u0443\u0435\u0440\u043D\u0438\u044F \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
        bridge: "\u041F\u043E\u0442\u0432\u044A\u0440\u0434\u0435\u0442\u0435 \u0432\u0440\u044A\u0437\u043A\u0430\u0442\u0430 \u0432 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B\u0430"
      }
    },
    ledger: {
      connectWithLedger: "\u0421\u0432\u044A\u0440\u0436\u0435\u0442\u0435 \u0441\u0435 \u0441 Ledger",
      makeSureYourLedger: "\u0423\u0432\u0435\u0440\u0435\u0442\u0435 \u0441\u0435, \u0447\u0435 \u0432\u0430\u0448\u0438\u044F\u0442 Ledger \u0435 \u0441\u0432\u044A\u0440\u0437\u0430\u043D \u0438 \u0447\u0435 \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435\u0442\u043E NEAR \u0435 \u043E\u0442\u0432\u043E\u0440\u0435\u043D\u043E \u043Da \u043D\u0435\u0433\u043E.",
      "continue": "\u041F\u0440\u043E\u0434\u044A\u043B\u0436\u0435\u0442\u0435",
      specifyHDPath: "\u041F\u043E\u0441\u043E\u0447\u0435\u0442\u0435 HD \u043F\u044A\u0442",
      enterYourPreferredHDPath: "\u0412\u044A\u0432\u0435\u0434\u0435\u0442\u0435 \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D\u0438\u044F HD \u043F\u044A\u0442, \u0441\u043B\u0435\u0434 \u043A\u043E\u0435\u0442\u043E \u0441\u043A\u0430\u043D\u0438\u0440\u0430\u0439\u0442\u0435 \u0437\u0430 \u0430\u043A\u0442\u0438\u0432\u043D\u0438 \u0430\u043A\u0430\u0443\u043D\u0442\u0438.",
      scan: "\u0421\u043A\u0430\u043D\u0438\u0440\u0430\u0439\u0442\u0435",
      retry: "\u041E\u043F\u0438\u0442\u0430\u0439\u0442\u0435 \u043E\u0442\u043D\u043E\u0432\u043E",
      ledgerIsNotAvailable: "Ledger \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E\u0442\u043E \u043D\u0435 \u0435 \u0434\u043E\u0441\u0442\u044A\u043F\u043D\u043E",
      accessDeniedToUseLedgerDevice: "\u0414\u043E\u0441\u0442\u044A\u043F\u044A\u0442 \u0437\u0430 \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u043D\u0435 \u043D\u0430 Ledger \u0435 \u043E\u0442\u043A\u0430\u0437\u0430\u043D",
      noAccountsFound: "\u041D\u044F\u043C\u0430 \u043D\u0430\u043C\u0435\u0440\u0435\u043D\u0438 \u043F\u0440\u043E\u0444\u0438\u043B\u0438",
      selectYourAccounts: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0432\u0430\u0448\u0438\u0442\u0435 \u043F\u0440\u043E\u0444\u0438\u043B\u0438",
      connecting1Account: "\u0421\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435 \u043D\u0430 1 \u043F\u0440\u043E\u0444\u0438\u043B",
      cantFindAnyAccount: "\u041D\u044F\u043C\u0430 \u043D\u0430\u043C\u0435\u0440\u0435\u043D\u0438 \u043F\u0440\u043E\u0444\u0438\u043B\u0438, \u0441\u044A\u0432\u0440\u0437\u0430\u043D\u0438 \u0441 \u0442\u043E\u0437\u0438 Ledger. \u041C\u043E\u043B\u044F, \u0441\u044A\u0437\u0434\u0430\u0439\u0442\u0435 \u043D\u043E\u0432 NEAR \u043F\u0440\u043E\u0444\u0438\u043B \u043D\u0430",
      orConnectAnAnotherLedger: "\u0438\u043B\u0438 \u0441\u0432\u044A\u0440\u0436\u0435\u0442\u0435 \u0434\u0440\u0443\u0433 Ledger.",
      connecting: "\u0421\u0432\u044A\u0440\u0437\u0432\u0430\u043D\u0435",
      ofAccounts: "\u043E\u0442 \u043F\u0440\u043E\u0444\u0438\u043B\u0438",
      failedToAutomatically: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u043D\u043E\u0442\u043E \u043D\u0430\u043C\u0438\u0440\u0430\u043D\u0435 \u043D\u0430 \u043F\u0440\u043E\u0444\u0438\u043B\u0430 \u043D\u0435 \u0431\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E. \u0412\u044A\u0432\u0435\u0434\u0435\u0442\u0435 \u0433\u043E \u0440\u044A\u0447\u043D\u043E:",
      overviewTheListOfAuthorized: "\u041F\u0440\u0435\u0433\u043B\u0435\u0434\u0430\u0439\u0442\u0435 \u0441\u043F\u0438\u0441\u044A\u043A\u0430 \u0441 \u0443\u043F\u044A\u043B\u043D\u043E\u043C\u043E\u0449\u0435\u043D\u0438 \u043F\u0440\u043E\u0444\u0438\u043B\u0438, \u0437\u0430\u0432\u044A\u0440\u0448\u0435\u0442\u0435 \u0432\u043B\u0438\u0437\u0430\u043D\u0435\u0442\u043E, \u043A\u0430\u0442\u043E \u0449\u0440\u0430\u043A\u043D\u0435\u0442\u0435 \u0432\u044A\u0440\u0445\u0443 \u0431\u0443\u0442\u043E\u043D\u0430 \u043F\u043E-\u0434\u043E\u043B\u0443..",
      finish: "\u0417\u0430\u0432\u044A\u0440\u0448\u0435\u0442\u0435"
    },
    install: {
      youllNeedToInstall: "\u0429\u0435 \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u0442\u0435",
      toContinueAfterInstalling: "\u0437\u0430 \u0434\u0430 \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435. \u0421\u043B\u0435\u0434 \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u043D\u0435",
      refreshThePage: "\u043F\u0440\u0435\u0437\u0430\u0440\u0435\u0434\u0435\u0442\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430\u0442\u0430.",
      open: "\u041E\u0442\u0432\u043E\u0440\u0435\u0442\u0435"
    },
    qr: {
      copiedToClipboard: "\u041A\u043E\u043F\u0438\u0440\u0430\u043D\u043E \u0432 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u0430",
      failedToCopy: "\u041D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043A\u043E\u043F\u0438\u0440\u0430\u043D\u0435 \u0432 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u0430",
      scanWithYourMobile: " \u0421\u043A\u0430\u043D\u0438\u0440\u0430\u0439\u0442\u0435 \u0441 \u043C\u043E\u0431\u0438\u043B\u043D\u043E\u0442\u043E \u0441\u0438 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E",
      copyToClipboard: " \u041A\u043E\u043F\u0438\u0440\u0430\u0439\u0442\u0435 \u0432 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u0430",
      preferTheOfficial: "\u041F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D \u0435\u0437\u0438\u043A \u0437\u0430 \u043A\u043E\u0440\u0435\u0441\u043F\u043E\u043D\u0434\u0435\u043D\u0446\u0438\u044F",
      open: "\u041E\u0442\u0432\u043E\u0440\u0435\u0442\u0435"
    },
    walletTypes: {
      hardware: "\u0425\u0430\u0440\u0434\u0443\u0435\u0440\u0435\u043D \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      browser: "\u041F\u043E\u0440\u0442\u0444\u0435\u0439\u043B \u0432 \u0431\u0440\u0430\u0443\u0437\u044A\u0440\u0430",
      injected: "\u0420\u0430\u0437\u0448\u0438\u0440\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      bridge: "\u041C\u043E\u0441\u0442\u043E\u0432 \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      mobile: "\u041C\u043E\u0431\u0438\u043B\u0435\u043D \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B",
      "instant-link": "\u041C\u0438\u0433\u043D\u043E\u0432\u0435\u043D \u043F\u043E\u0440\u0442\u0444\u0435\u0439\u043B"
    }
  };
  var bg = {
    modal: modal$8
  };
  var modal$7 = {
    wallet: {
      connectYourWallet: "\uC9C0\uAC11 \uC5F0\uACB0\uD558\uAE30",
      whatIsAWallet: "\uC9C0\uAC11\uC740 \uBB34\uC2A8 \uC5ED\uD560\uC744 \uD558\uB098\uC694?",
      secureAndManage: "\uB2F9\uC2E0\uC758 \uB514\uC9C0\uD138 \uC790\uC0B0\uC744 \uBCF4\uD638\uD558\uACE0 \uAD00\uB9AC\uD569\uB2C8\uB2E4.",
      safelyStore: "\uC554\uD638\uD654\uD3D0\uC640 NFT\uB97C \uC548\uC804\uD558\uAC8C \uC800\uC7A5\uD558\uACE0 \uC804\uC1A1\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      logInToAny: "NEAR App\uC5D0 \uB85C\uADF8\uC778\uD569\uB2C8\uB2E4.",
      noNeedToCreate: "\uC0C8\uB85C\uC6B4 \uACC4\uC815\uC774\uB098 \uBE44\uBC00\uBC88\uD638\uB97C \uB9CC\uB4E4 \uD544\uC694 \uC5C6\uC774 \uC9C0\uAC11\uC744 \uC5F0\uACB0\uD55C \uD6C4 \uBC14\uB85C \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      getAWallet: "\uC9C0\uAC11 \uAC00\uC838\uC624\uAE30",
      useAWallet: "\uC9C0\uAC11\uC744 \uC0AC\uC6A9\uD558\uC5EC NEAR \uC790\uC0B0\uC744 \uBCF4\uD638\xB7\uAD00\uB9AC\uD558\uACE0, \uC544\uC774\uB514\uC640 \uBE44\uBC00\uBC88\uD638 \uC5C6\uC774 NEAR \uC571\uC5D0 \uB85C\uADF8\uC778\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      connectionFailed: "\uC5F0\uACB0 \uC2E4\uD328",
      connectionSuccessful: "\uC5F0\uACB0 \uC131\uACF5",
      rememberWallet: "\uC9C0\uAC11\uB4E4 \uAE30\uC5B5\uD558\uAE30",
      connected: "Connected",
      connectingTo: "\uC5F0\uACB0 \uC911: ",
      connectingMessage: {
        injected: "\uC775\uC2A4\uD150\uC158 \uCC3D\uC5D0\uC11C \uC5F0\uACB0\uC744 \uD655\uC778\uD558\uC138\uC694",
        browser: "\uB9AC\uB2E4\uC774\uB809\uD2B8 \uB41C \uC9C0\uAC11\uC5D0\uC11C \uC5F0\uACB0\uC744 \uD655\uC778\uD558\uC138\uC694",
        hardware: "Ledger \uAE30\uAE30\uC5D0\uC11C \uC5F0\uACB0\uC744 \uD655\uC778\uD558\uC138\uC694",
        bridge: "\uC9C0\uAC11\uC5D0\uC11C \uC5F0\uACB0 \uD655\uC778"
      }
    },
    ledger: {
      connectWithLedger: "Ledger \uC5F0\uACB0\uD558\uAE30",
      makeSureYourLedger: "Ledger\uAC00 \uC548\uC804\uD558\uAC8C \uC5F0\uACB0\uB418\uC5B4 \uC788\uACE0, NEAR \uC571\uC774 \uC5F4\uB824 \uC788\uB294 \uC9C0 \uD655\uC778\uD558\uC138\uC694",
      "continue": "\uACC4\uC18D\uD558\uAE30",
      specifyHDPath: "HD Path \uC9C0\uC815\uD558\uAE30",
      enterYourPreferredHDPath: "\uC6D0\uD558\uB294 HD Path\uB97C \uC120\uD0DD\uD558\uACE0, \uD65C\uC131\uD654\uB41C \uACC4\uC815\uC774 \uC788\uB294 \uC9C0 \uAC80\uC0C9\uD558\uC138\uC694",
      scan: "\uAC80\uC0C9",
      retry: "\uB2E4\uC2DC \uC2DC\uB3C4",
      ledgerIsNotAvailable: "Ledger\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4",
      accessDeniedToUseLedgerDevice: "Ledger \uAE30\uAE30 \uC811\uADFC \uAD8C\uD55C\uC774 \uAC70\uBD80\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
      noAccountsFound: "\uACC4\uC815\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4",
      selectYourAccounts: "\uACC4\uC815 \uC120\uD0DD\uD558\uAE30",
      connecting1Account: "\uD558\uB098\uC758 \uACC4\uC815\uC5D0 \uC5F0\uACB0",
      cantFindAnyAccount: "Ledger\uC640 \uC5F0\uACB0\uB41C \uACC4\uC815\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC0C8\uB85C\uC6B4 \uACC4\uC815\uC744 \uC0DD\uC131\uD558\uAC70\uB098 ",
      orConnectAnAnotherLedger: "\uB2E4\uB978 Ledger\uB97C \uC5F0\uACB0\uD558\uC138\uC694",
      connecting: "\uACC4\uC815 \uC5F0\uACB0\uD558\uAE30: ",
      ofAccounts: "\uAC1C \uACC4\uC815\uC744 \uCC3E\uC558\uC2B5\uB2C8\uB2E4",
      failedToAutomatically: "\uACC4\uC815 ID\uB97C \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4. \uC218\uB3D9\uC73C\uB85C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
      overviewTheListOfAuthorized: "\uC778\uC99D\uB41C \uACC4\uC815 \uBAA9\uB85D\uC744 \uD655\uC778\uD55C \uD6C4 \uC544\uB798 \uBC84\uD2BC\uC744 \uD074\uB9AD\uD558\uC5EC \uB85C\uADF8\uC778\uC744 \uC644\uB8CC\uD558\uC138\uC694",
      finish: "\uC644\uB8CC"
    },
    walletTypes: {
      hardware: "\uD558\uB4DC\uC6E8\uC5B4 \uC9C0\uAC11",
      browser: "\uBE0C\uB77C\uC6B0\uC800 \uC9C0\uAC11",
      injected: "\uC9C0\uAC11 \uD655\uC7A5",
      bridge: "\uBE0C\uB9AC\uC9C0 \uC9C0\uAC11",
      mobile: "\uBAA8\uBC14\uC77C \uC9C0\uAC11",
      "instant-link": "\uC778\uC2A4\uD134\uD2B8 \uC9C0\uAC11"
    },
    install: {
      youllNeedToInstall: "\uB2E4\uC74C \uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8\uC744 \uC124\uCE58\uD574\uC8FC\uC138\uC694:",
      toContinueAfterInstalling: ". \uC124\uCE58 \uC644\uB8CC \uD6C4 \uD398\uC774\uC9C0 \uC0C8\uB85C \uACE0\uCE68\uC774 \uD544\uC694\uD569\uB2C8\uB2E4. ",
      refreshThePage: "\uC0C8\uB85C \uACE0\uCE68",
      open: "Open"
    },
    qr: {
      copiedToClipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC \uC644\uB8CC",
      failedToCopy: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC \uC2E4\uD328",
      scanWithYourMobile: "\uBAA8\uBC14\uC77C \uC7A5\uCE58\uB97C \uC0AC\uC6A9\uD558\uC5EC \uC2A4\uCE94\uD574\uC8FC\uC138\uC694",
      copyToClipboard: " \uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uD558\uAE30",
      preferTheOfficial: "\uB2E4\uC74C \uD504\uB85C\uADF8\uB7A8\uC5D0\uC11C \uC81C\uACF5\uD558\uB294 \uACF5\uC2DD \uD504\uB85C\uC138\uC2A4\uB97C \uC120\uD638\uD558\uC2ED\uB2C8\uAE4C: ",
      open: "Open"
    }
  };
  var ko = {
    modal: modal$7
  };
  var modal$6 = {
    wallet: {
      connectYourWallet: "K\u1EBFt n\u1ED1i v\xED c\u1EE7a b\u1EA1n",
      whatIsAWallet: "V\xED l\xE0 g\xEC?",
      secureAndManage: "B\u1EA3o m\u1EADt & Qu\u1EA3n l\xFD t\xE0i s\u1EA3n s\u1ED1 c\u1EE7a b\u1EA1n",
      safelyStore: "L\u01B0u tr\u1EEF v\xE0 chuy\u1EC3n ti\u1EC1n \u0111i\u1EC7n t\u1EED v\xE0 NFT c\u1EE7a b\u1EA1n m\u1ED9t c\xE1ch an to\xE0n.",
      logInToAny: "\u0110\u0103ng nh\u1EADp v\xE0o b\u1EA5t k\u1EF3 \u1EE9ng d\u1EE5ng tr\xEAn NEAR",
      noNeedToCreate: "Kh\xF4ng c\u1EA7n t\u1EA1o t\xE0i kho\u1EA3n ho\u1EB7c th\xF4ng tin \u0111\u0103ng nh\u1EADp m\u1EDBi. K\u1EBFt n\u1ED1i v\xED c\u1EE7a b\u1EA1n v\xE0 b\u1EAFt \u0111\u1EA7u!",
      getAWallet: "T\u1EA1o V\xED",
      useAWallet: "S\u1EED d\u1EE5ng v\xED \u0111\u1EC3 b\u1EA3o m\u1EADt v\xE0 qu\u1EA3n l\xFD t\xE0i s\u1EA3n tr\xEAn NEAR c\u1EE7a b\u1EA1n v\xE0 \u0111\u0103ng nh\u1EADp v\xE0o b\u1EA5t k\u1EF3 \u1EE9ng d\u1EE5ng NEAR n\xE0o, kh\xF4ng c\u1EA7n t\xEAn ng\u01B0\u1EDDi d\xF9ng v\xE0 m\u1EADt kh\u1EA9u.",
      connectionFailed: "K\u1EBFt n\u1ED1i th\u1EA5t b\u1EA1i",
      connectionSuccessful: "K\u1EBFt n\u1ED1i th\xE0nh c\xF4ng",
      rememberWallet: "Ghi nh\u1EDB l\u1EF1a ch\u1ECDn v\xED",
      connected: "\u0110\xE3 k\u1EBFt n\u1ED1i",
      connectingTo: "\u0110ang k\u1EBFt n\u1ED1i t\u1EDBi",
      connectingMessage: {
        injected: "X\xE1c nh\u1EADn k\u1EBFt n\u1ED1i trong c\u1EEDa s\u1ED5 ti\u1EC7n \xEDch m\u1EDF r\u1ED9ng",
        browser: "X\xE1c nh\u1EADn k\u1EBFt n\u1ED1i trong v\xED sau khi \u0111\u01B0\u1EE3c chuy\u1EC3n h\u01B0\u1EDBng",
        hardware: "X\xE1c nh\u1EADn k\u1EBFt n\u1ED1i v\u1EDBi v\xED l\u1EA1nh",
        bridge: "X\xE1c nh\u1EADn k\u1EBFt n\u1ED1i trong v\xED"
      }
    },
    ledger: {
      connectWithLedger: "K\u1EBFt n\u1ED1i v\xED Ledger",
      makeSureYourLedger: "\u0110\u1EA3m b\u1EA3o Ledger c\u1EE7a b\u1EA1n \u0111\u01B0\u1EE3c k\u1EBFt n\u1ED1i an to\xE0n v\xE0 \u1EE9ng d\u1EE5ng NEAR \u0111ang m\u1EDF s\u1EB5n tr\xEAn thi\u1EBFt b\u1ECB",
      "continue": "Ti\u1EBFp t\u1EE5c",
      specifyHDPath: "Ch\u1EC9 \u0111\u1ECBnh HD Path",
      enterYourPreferredHDPath: "Nh\u1EADp HD Path c\u1EE7a b\u1EA1n, sau \u0111\xF3 qu\xE9t t\xECm c\xE1c t\xE0i kho\u1EA3n ho\u1EA1t \u0111\u1ED9ng",
      scan: "Qu\xE9t",
      retry: "Th\u1EED l\u1EA1i",
      ledgerIsNotAvailable: "Ledger kh\xF4ng kh\u1EA3 d\u1EE5ng",
      accessDeniedToUseLedgerDevice: "Truy c\u1EADp Ledger b\u1ECB t\u1EEB ch\u1ED1i",
      noAccountsFound: "Kh\xF4ng t\xECm th\u1EA5y t\xE0i kho\u1EA3n",
      selectYourAccounts: "Ch\u1ECDn t\xE0i kho\u1EA3n c\u1EE7a b\u1EA1n",
      connecting1Account: "\u0110ang k\u1EBFt n\u1ED1i 1 t\xE0i kho\u1EA3n",
      cantFindAnyAccount: "Kh\xF4ng th\u1EC3 t\xECm th\u1EA5y b\u1EA5t k\u1EF3 t\xE0i kho\u1EA3n n\xE0o \u0111\u01B0\u1EE3c li\xEAn k\u1EBFt v\u1EDBi Ledger n\xE0y. Vui l\xF2ng t\u1EA1o m\u1ED9t t\xE0i kho\u1EA3n NEAR m\u1EDBi",
      orConnectAnAnotherLedger: "ho\u1EB7c k\u1EBFt n\u1ED1i v\u1EDBi v\xED Ledger kh\xE1c.",
      connecting: "\u0110ang k\u1EBFt n\u1ED1i",
      ofAccounts: "c\u1EE7a t\xE0i kho\u1EA3n",
      failedToAutomatically: "Kh\xF4ng th\u1EC3 t\u1EF1 \u0111\u1ED9ng t\xECm id t\xE0i kho\u1EA3n. Nh\u1EADp th\u1EE7 c\xF4ng:",
      overviewTheListOfAuthorized: "T\u1ED5ng quan danh s\xE1ch c\xE1c t\xE0i kho\u1EA3n \u0111\u01B0\u1EE3c \u1EE7y quy\u1EC1n, ho\xE0n t\u1EA5t \u0111\u0103ng nh\u1EADp b\u1EB1ng c\xE1ch b\u1EA5m v\xE0o n\xFAt b\xEAn d\u01B0\u1EDBi.",
      finish: "Ho\xE0n th\xE0nh"
    },
    install: {
      youllNeedToInstall: "B\u1EA1n s\u1EBD c\u1EA7n c\xE0i \u0111\u1EB7t",
      toContinueAfterInstalling: "\u0111\u1EC3 b\u1EAFt \u0111\u1EA7u. Sau khi c\xE0i \u0111\u1EB7t xong",
      refreshThePage: "T\u1EA3i l\u1EA1i trang.",
      open: "M\u1EDF"
    },
    qr: {
      copiedToClipboard: "\u0110\xE3 sao ch\xE9p v\xE0o b\u1EA3ng ghi t\u1EA1m",
      failedToCopy: "Sao ch\xE9p v\xE0o b\u1EA3ng ghi t\u1EA1m th\u1EA5t b\u1EA1i",
      scanWithYourMobile: "Qu\xE9t v\u1EDBi \u0111i\u1EC7n tho\u1EA1i c\u1EE7a b\u1EA1n",
      copyToClipboard: " Sao ch\xE9p v\xE0o b\u1EA3ng ghi t\u1EA1m",
      preferTheOfficial: "Dialogue ch\xEDnh th\u1EE9c c\u1EE7a",
      open: "M\u1EDF"
    },
    walletTypes: {
      hardware: "V\xED l\u1EA1nh",
      browser: "V\xED tr\xECnh duy\u1EC7t",
      injected: "V\xED ti\u1EC7n \xEDch m\u1EDF r\u1ED9ng",
      bridge: "V\xED C\u1EA7u",
      mobile: "V\xED Mobile",
      "instant-link": "V\xED t\u1EE9c th\xEC"
    },
    exportAccounts: {
      chooseAWallet: "Ch\u1ECDn v\xED",
      transferYourAccounts: "Chuy\u1EC3n t\xE0i kho\u1EA3n",
      selectAWallet: "Ch\u1ECDn v\xED ph\xF9 h\u1EE3p v\u1EDBi nhu c\u1EA7u c\u1EE7a b\u1EA1n, v\xED \u0111\u01B0\u1EE3c ch\u1ECDn c\u1EA7n h\u1ED7 tr\u1EE3 c\xE1c t\xE0i kho\u1EA3n \u0111ang s\u1EED d\u1EE5ng.",
      selectYourAccounts: "Ch\u1ECDn t\xE0i kho\u1EA3n",
      afterDecide: "Sau khi ch\u1ECDn \u0111\u01B0\u1EE3c t\xE0i kho\u1EA3n b\u1EA1n c\xF3 chuy\u1EC3n.",
      disclaimer: "B\u1EA1n kh\xF4ng th\u1EC3 chuy\u1EC3n t\xE0i kho\u1EA3n n\u1EBFu t\xE0i kho\u1EA3n \u0111\xF3 ch\u01B0a \u0111\u01B0\u1EE3c nh\u1EADn ti\u1EC1n ho\u1EB7c ch\u01B0a ph\xE1t sinh giao d\u1ECBch tr\xEAn NEAR.",
      warning: "kh\xF4ng h\u1ED7 tr\u1EE3 xu\u1EA5t t\xE0i kho\u1EA3n. Vui l\xF2ng ch\u1ECDn v\xED kh\xE1c.",
      walletTypes: {
        hardware: "V\xED l\u1EA1nh",
        browser: "V\xED tr\xECnh duy\u1EC7t",
        injected: "V\xED ti\u1EC7n \xEDch m\u1EDF r\u1ED9ng",
        bridge: "V\xED C\u1EA7u",
        mobile: "V\xED Mobile"
      },
      selectAccounts: {
        title: "Ch\u1ECDn t\xE0i kho\u1EA3n \u0111\u1EC3 chuy\u1EC3n",
        button: "L\u1EA5y c\u1EE5m m\u1EADt kh\u1EA9u",
        deselectAll: "B\u1ECF ch\u1ECDn t\u1EA5t c\u1EA3",
        selectAll: "Ch\u1ECDn t\u1EA5t c\u1EA3",
        unavailable: "Chuy\u1EC3n kh\xF4ng kh\u1EA3 d\u1EE5ng",
        error: "T\xE0i kho\u1EA3n kh\xF4ng t\u1ED3n t\u1EA1i",
        warningLedger: "Y\xEAu c\u1EA7u h\u1ED7 tr\u1EE3 Ledger",
        noBalance: "T\xE0i kho\u1EA3n tr\u1ED1ng"
      },
      getPassphrase: {
        title: "Sao ch\xE9p m\u1EADt kh\u1EA9u t\u1EA1m th\u1EDDi",
        desc: "B\u1EA1n s\u1EBD c\u1EA7n nh\u1EADp m\u1EADt kh\u1EA9u khi b\u1EAFt \u0111\u1EA7u xu\u1EA5t c\xE1c kho\u1EA3n t\u1EDBi v\xED kh\xE1c.",
        button: "Ti\u1EBFp t\u1EE5c",
        label: "B\u1EA5m \u0111\u1EC3 sao ch\xE9p",
        checkLabel: "T\xF4i \u0111\xE3 ch\xE9p ho\u1EB7c ghi l\u1EA1i m\u1EADt kh\u1EA9u"
      },
      complete: {
        title: "Ho\xE0n th\xE0nh chuy\u1EC3n",
        descOne: "B\u1EA1n s\u1EBD \u0111\u01B0\u1EE3c chuy\u1EC3n h\u01B0\u1EDBng t\u1EDBi t\xE0i kho\u1EA3n \u0111\xE3 ch\u1ECDn \u0111\u1EC3 ho\xE0n t\u1EA5t qu\xE1 tr\xECnh.",
        descTwo: "Sau khi nh\u1EADp, nh\u1EA5n n\xFAt \u0111\u1EC3 ho\xE0n t\u1EA5t quy tr\xECnh chuy\u1EC3n.",
        button: "Ho\xE0n th\xE0nh"
      }
    }
  };
  var component$1 = {
    clickToCopy: {
      label: "\u0110\xE3 sao ch\xE9p",
      tooltip: "B\u1EA5m \u0111\u1EC3 sao ch\xE9p"
    }
  };
  var vi = {
    modal: modal$6,
    component: component$1
  };
  var modal$5 = {
    wallet: {
      connectYourWallet: "\u0905\u092A\u0928\u093E \u0935\u0949\u0932\u0947\u091F (Wallet) \u0915\u0928\u0947\u0915\u094D\u091F \u0915\u0930\u0947\u0902\u0964",
      whatIsAWallet: "\u0935\u0949\u0932\u0947\u091F \u0915\u094D\u092F\u093E \u0939\u0948?",
      secureAndManage: "\u0938\u0941\u0930\u0915\u094D\u0937\u093F\u0924 \u0914\u0930 \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0947\u0902\u0964",
      safelyStore: "\u0905\u092A\u0928\u0940 \u0915\u094D\u0930\u093F\u092A\u094D\u091F\u094B\u0915\u0930\u0947\u0902\u0938\u0940 \u0914\u0930 \u090F\u0928\u090F\u092B\u091F\u0940 \u0915\u094B \u0938\u0941\u0930\u0915\u094D\u0937\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u0938\u094D\u091F\u094B\u0930 \u0914\u0930 \u091F\u094D\u0930\u093E\u0902\u0938\u092B\u0930 \u0915\u0930\u0947\u0902\u0964",
      logInToAny: "NEAR \u092A\u0930 \u0915\u093F\u0938\u0940 \u092D\u0940 \u0910\u092A \u092E\u0947\u0902 \u0938\u093E\u0907\u0928 \u0907\u0928 \u0915\u0930\u0947\u0902\u0964",
      noNeedToCreate: "\u0928\u090F \u0916\u093E\u0924\u0947 \u092F\u093E \u0932\u0949\u0917\u093F\u0928 \u092C\u0928\u093E\u0928\u0947 \u0915\u0940 \u0906\u0935\u0936\u094D\u092F\u0915\u0924\u093E \u0928\u0939\u0940\u0902 \u0939\u0948\u0964 \u0905\u092A\u0928\u093E \u0935\u0949\u0932\u0947\u091F(NEAR Wallet)\u0915\u0928\u0947\u0915\u094D\u091F \u0915\u0930\u0947\u0902 \u0914\u0930 \u0906\u0930\u0902\u092D \u0915\u0930\u0947\u0902\u0964",
      getAWallet: "\u090F\u0915 \u0935\u0949\u0932\u0947\u091F \u092C\u0928\u093E\u090F\u0901\u0964",
      useAWallet: "\u0905\u092A\u0928\u0940 NEAR \u0938\u0902\u092A\u0924\u094D\u0924\u093F\u092F\u094B\u0902 \u0915\u094B \u0938\u0941\u0930\u0915\u094D\u0937\u093F\u0924 \u0914\u0930 \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0935\u0949\u0932\u0947\u091F \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902 \u0914\u0930 \u0915\u093F\u0938\u0940 \u092D\u0940 NEAR \u0910\u092A (app) \u092E\u0947\u0902 \u0932\u0949\u0917 \u0907\u0928 \u0915\u0930\u0947\u0902, \u0915\u093F\u0938\u0940 \u0909\u092A\u092F\u094B\u0917\u0915\u0930\u094D\u0924\u093E (user) \u0928\u093E\u092E \u0914\u0930 \u092A\u093E\u0938\u0935\u0930\u094D\u0921 \u0915\u0940 \u0906\u0935\u0936\u094D\u092F\u0915\u0924\u093E \u0928\u0939\u0940\u0902 \u0939\u0948\u0964",
      connectionFailed: "\u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0935\u093F\u092B\u0932|",
      connectionSuccessful: "\u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0938\u092B\u0932|",
      rememberWallet: "\u0935\u0949\u0932\u0947\u091F\u094B\u0902 \u0915\u094B \u092F\u093E\u0926 \u0930\u0916\u0947\u0902",
      connected: "\u0935\u0949\u0932\u0947\u091F \u091C\u0941\u095C \u0917\u092F\u093E|",
      connectingTo: "\u0935\u0949\u0932\u0947\u091F \u091C\u0941\u095C \u0930\u0939\u093E \u0939\u0947|",
      connectingMessage: {
        injected: "\u090F\u0915\u094D\u0938\u091F\u0947\u0902\u0936\u0928 \u0935\u093F\u0902\u0921\u094B \u092E\u0947\u0902 \u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0915\u0940 \u092A\u0941\u0937\u094D\u091F\u093F \u0915\u0930\u0947\u0902|",
        browser: "\u0930\u0940\u0921\u093E\u092F\u0930\u0947\u0915\u094D\u091F \u0939\u094B\u0928\u0947 \u0915\u0947 \u092C\u093E\u0926 \u0935\u0949\u0932\u0947\u091F \u092E\u0947\u0902 \u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0915\u0940 \u092A\u0941\u0937\u094D\u091F\u093F \u0915\u0930\u0947\u0902|",
        hardware: "\u0915\u094B\u0932\u094D\u0921 \u0935\u0949\u0932\u0947\u091F \u0915\u0947 \u0938\u093E\u0925 \u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0915\u0940 \u092A\u0941\u0937\u094D\u091F\u093F \u0915\u0930\u0947\u0902|"
      }
    },
    ledger: {
      connectWithLedger: "\u0932\u0947\u091C\u0930(Ledger)\u0935\u0949\u0932\u0947\u091F \u0915\u0928\u0947\u0915\u094D\u091F \u0915\u0930\u0947\u0902|",
      makeSureYourLedger: "\u0938\u0941\u0928\u093F\u0936\u094D\u091A\u093F\u0924 \u0915\u0930\u0947\u0902 \u0915\u093F \u0906\u092A\u0915\u093E \u0932\u0947\u091C\u0930 \u0938\u0941\u0930\u0915\u094D\u0937\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u091C\u0941\u0921\u093C\u093E \u0939\u0941\u0906 \u0939\u0948 \u0914\u0930 NEAR \u0910\u092A \u0906\u092A\u0915\u0947 \u0921\u093F\u0935\u093E\u0907\u0938 (Device)\u092A\u0930 \u092A\u0939\u0932\u0947 \u0938\u0947 \u0939\u0940 \u0916\u0941\u0932\u093E \u0939\u0948|",
      "continue": "\u091C\u093E\u0930\u0940 \u0930\u0916\u0947|",
      specifyHDPath: "\u0939\u093E\u0930\u094D\u0921 \u0921\u093F\u0938\u094D\u0915(Hard Disk)\u092A\u0925(Path)\u0928\u093F\u0930\u094D\u0927\u093E\u0930\u093F\u0924 \u0915\u0930\u0947|",
      enterYourPreferredHDPath: "\u0905\u092A\u0928\u093E \u090F\u091A\u0921\u0940 \u092A\u0925 \u0926\u0930\u094D\u091C \u0915\u0930\u0947\u0902, \u092B\u093F\u0930 \u0938\u0915\u094D\u0930\u093F\u092F \u0916\u093E\u0924\u094B\u0902 \u0915\u0947 \u0932\u093F\u090F \u0938\u094D\u0915\u0948\u0928 \u0915\u0930\u0947\u0902|",
      scan: "\u0938\u094D\u0915\u0948\u0928 \u0915\u0930\u0947|",
      retry: "\u0926\u094B\u092C\u093E\u0930\u093E \u092A\u094D\u0930\u092F\u093E\u0938 \u0915\u0930\u0947|",
      ledgerIsNotAvailable: "\u0932\u0947\u091C\u0930 \u0909\u092A\u0932\u092C\u094D\u0927 \u0928\u0939\u0940\u0902 \u0939\u0948|",
      accessDeniedToUseLedgerDevice: "\u0932\u0947\u091C\u0930 \u0921\u093F\u0935\u093E\u0907\u0938 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u092A\u094D\u0930\u0935\u0947\u0936 \u0928\u093F\u0937\u0947\u0927|",
      noAccountsFound: "\u0916\u093E\u0924\u093E \u0928\u0939\u0940\u0902 \u092E\u093F\u0932\u093E|",
      selectYourAccounts: "\u0905\u092A\u0928\u0947 \u0916\u093E\u0924\u0947 \u091A\u0941\u0928\u0947\u0902|",
      connecting1Account: "\u090F\u0915 \u0916\u093E\u0924\u093E \u0915\u0928\u0947\u0915\u094D\u091F \u0939\u094B \u0930\u0939\u093E \u0939\u0948|",
      cantFindAnyAccount: "\u0907\u0938 \u0932\u0947\u091C\u0930 \u0938\u0947 \u091C\u0941\u0921\u093C\u093E \u0915\u094B\u0908 \u0916\u093E\u0924\u093E \u0928\u0939\u0940\u0902 \u092E\u093F\u0932\u093E\u0964 \u0915\u0943\u092A\u092F\u093E \u090F\u0915 \u0928\u092F\u093E NEAR \u0916\u093E\u0924\u093E \u092C\u0928\u093E\u090F\u0901|",
      orConnectAnAnotherLedger: "\u0905\u0925\u0935\u093E \u0926\u0942\u0938\u0930\u0947 \u0932\u0947\u091C\u0930 \u0935\u0949\u0932\u0947\u091F \u0938\u0947 \u0915\u0928\u0947\u0915\u094D\u091F \u0915\u0930\u0947\u0902\u0964",
      connecting: "\u091C\u0941\u095C \u0930\u0939\u093E \u0939\u0947|",
      ofAccounts: "\u0916\u093E\u0924\u093E \u0905\u092C \u091C\u0941\u095C\u093E \u0928\u0939\u0940\u0902 \u0939\u0947|",
      failedToAutomatically: "\u0916\u093E\u0924\u093E \u0906\u0908\u0921\u0940 \u0938\u094D\u0935\u091A\u093E\u0932\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u0916\u094B\u091C\u0928\u0947 \u092E\u0947\u0902 \u0905\u0938\u092E\u0930\u094D\u0925\u0964 \u092E\u0948\u0928\u094D\u092F\u0941\u0905\u0932 (Manuall) \u0930\u0942\u092A \u0938\u0947 \u0915\u094B\u0936\u093F\u0936 \u0915\u0930\u0947\u0902|",
      overviewTheListOfAuthorized: "\u0905\u0935\u0932\u094B\u0915\u0928 \u0905\u0927\u093F\u0915\u0943\u0924 \u0915\u0940 \u0938\u0942\u091A\u0940, \u0928\u0940\u091A\u0947 \u0926\u093F\u090F \u0917\u090F \u092C\u091F\u0928 \u092A\u0930 \u0915\u094D\u0932\u093F\u0915 \u0915\u0930\u0915\u0947 \u0932\u0949\u0917\u093F\u0928 \u092A\u0942\u0930\u093E \u0915\u0930\u0947\u0902\u0964",
      finish: "\u0938\u092E\u093E\u092A\u094D\u0924|"
    },
    install: {
      youllNeedToInstall: "\u0906\u092A\u0915\u094B \u0907\u0902\u0938\u094D\u091F\u0949\u0932 \u0915\u0930\u0928\u093E \u0939\u094B\u0917\u093E|",
      toContinueAfterInstalling: "\u0907\u0902\u0938\u094D\u091F\u0949\u0932 \u0915\u0930\u0928\u0947 \u0915\u0947 \u092C\u093E\u0926 \u091C\u093E\u0930\u0940 \u0930\u0916\u0947|",
      refreshThePage: "\u092A\u0941\u0928: \u0932\u094B\u0921 \u0915\u0930\u0947\u0902\u0964",
      open: "\u0916\u094B\u0932\u0947|"
    },
    qr: {
      copiedToClipboard: "\u0915\u094D\u0932\u093F\u092A\u092C\u094B\u0930\u094D\u0921(Clipboard)\u092A\u0930 \u0915\u0949\u092A\u0940 \u0915\u093F\u092F\u093E \u0917\u092F\u093E|",
      failedToCopy: "\u0915\u094D\u0932\u093F\u092A\u092C\u094B\u0930\u094D\u0921 \u092A\u0930 \u0915\u0949\u092A\u0940 \u0915\u0930\u0928\u093E \u0935\u093F\u092B\u0932 \u0930\u0939\u093E|",
      scanWithYourMobile: "\u0905\u092A\u0928\u0947 \u092B\u094B\u0928 (Mobile)\u0938\u0947 \u0938\u094D\u0915\u0948\u0928 \u0915\u0930\u0947\u0902|",
      copyToClipboard: " \u0915\u094D\u0932\u093F\u092A\u092C\u094B\u0930\u094D\u0921 \u092A\u0930 \u0915\u0949\u092A\u0940 \u0915\u0930\u0947\u0902|",
      preferTheOfficial: "\u0906\u0927\u093F\u0915\u093E\u0930\u093F\u0915 \u0938\u0902\u0935\u093E\u0926 \u0915\u094B \u092A\u094D\u0930\u093E\u0925\u092E\u093F\u0915\u0924\u093E \u0926\u0947\u0902|",
      open: "\u0916\u094B\u0932\u0947|"
    },
    walletTypes: {
      hardware: "\u0939\u093E\u0930\u094D\u0921\u0935\u0947\u092F\u0930 \u0935\u0949\u0932\u0947\u091F",
      browser: "\u092C\u094D\u0930\u093E\u0909\u091C\u093C\u0930 \u0935\u0949\u0932\u0947\u091F",
      injected: "\u0935\u0949\u0932\u0947\u091F \u090F\u0915\u094D\u0938\u091F\u0947\u0902\u0936\u0928",
      bridge: "\u092C\u094D\u0930\u093F\u091C \u0935\u0949\u0932\u0947\u091F",
      mobile: "\u092E\u094B\u092C\u093E\u0907\u0932 \u0935\u0949\u0932\u0947\u091F",
      "instant-link": "\u0907\u0902\u0938\u094D\u091F\u0947\u0902\u091F \u0935\u0949\u0932\u0947\u091F"
    }
  };
  var hi = {
    modal: modal$5
  };
  var modal$4 = {
    wallet: {
      connectYourWallet: "\u0635\u0644 \u0645\u062D\u0641\u0638\u062A\u0643",
      whatIsAWallet: "\u0645\u0627 \u0647\u064A \u0627\u0644\u0645\u062D\u0641\u0638\u0629\u061F",
      secureAndManage: "\u062A\u0623\u0645\u064A\u0646 \u0648\u0625\u062F\u0627\u0631\u0629 \u0627\u0644\u0645\u0645\u062A\u0644\u0643\u0627\u062A \u0627\u0644\u0631\u0642\u0645\u064A\u0629 \u0627\u0644\u062E\u0627\u0635\u0629 \u0628\u0643",
      safelyStore: "\u0642\u0645 \u0628\u062A\u062E\u0632\u064A\u0646 \u0648 \u0627\u0631\u0633\u0627\u0644 \u0639\u0645\u0644\u0627\u062A\u0643 \u0648 \u0623\u0635\u0648\u0644\u0643 \u0627\u0644\u0631\u0642\u0645\u064A\u0629 \u0628\u0623\u0645\u0627\u0646",
      logInToAny: "\u0633\u062C\u0644 \u0627\u0644\u062F\u062E\u0648\u0644 \u0625\u0644\u0649 \u0623\u064A \u062A\u0637\u0628\u064A\u0642 \u064A\u0633\u062A\u062E\u062F\u0645 \u0646\u064A\u0631",
      noNeedToCreate: ".\u0644\u0627 \u062F\u0627\u0639\u064A \u0644\u0625\u0646\u0634\u0627\u0621 \u062D\u0633\u0627\u0628 \u062C\u062F\u064A\u062F. \u0641\u0642\u0637 \u0642\u0645 \u0628\u062A\u0648\u0635\u064A\u0644 \u0645\u062D\u0641\u0638\u062A\u0643 \u0648\u0627\u0646\u0637\u0644\u0642",
      getAWallet: "\u0627\u062D\u0635\u0644 \u0639\u0644\u0649 \u0645\u062D\u0641\u0638\u0629",
      useAWallet: "\u0627\u0633\u062A\u062E\u062F\u0645 \u0645\u062D\u0641\u0638\u0629 \u0644\u062A\u0623\u0645\u064A\u0646 \u0648\u0625\u062F\u0627\u0631\u0629 \u0623\u0635\u0648\u0644 \u0646\u064A\u0631 \u0627\u0644\u062E\u0627\u0635\u0629 \u0628\u0643\u060C \u0648\u0627\u062F\u062E\u0644 \u0644\u0623\u064A \u062A\u0637\u0628\u064A\u0642 \u064A\u0633\u062A\u062E\u062F\u0645 \u0646\u064A\u0631 \u062F\u0648\u0646 \u0627\u0644\u062D\u0627\u062C\u0629 \u0625\u0644\u0649 \u0627\u0633\u0645 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645 \u0648\u0643\u0644\u0645\u0629\u0627\u0644\u0645\u0631\u0648\u0631",
      connectionFailed: "\u0627\u062A\u0635\u0627\u0644 \u0641\u0627\u0634\u0644",
      connectionSuccessful: "\u0627\u062A\u0635\u0627\u0644 \u0646\u0627\u062C\u062D",
      rememberWallet: "\u062A\u0630\u0643\u0631 \u0627\u0644\u0645\u062D\u0627\u0641\u0638",
      connected: "\u0645\u062A\u0635\u0644",
      connectingTo: "\u062C\u0627\u0631\u064A \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628",
      connectingMessage: {
        injected: "\u0648\u0627\u0641\u0642 \u0639\u0644\u0649 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0641\u064A \u0646\u0627\u0641\u0630\u0629 \u0627\u0644\u0625\u0636\u0627\u0641\u0629",
        browser: "\u0648\u0627\u0641\u0642 \u0639\u0644\u0649 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0641\u064A \u0627\u0644\u0645\u062D\u0641\u0638\u0629 \u0628\u0639\u062F \u0625\u0639\u0627\u062F\u0629 \u062A\u0648\u062C\u064A\u0647",
        hardware: "\u0648\u0627\u0641\u0642 \u0639\u0644\u0649 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0641\u064A \u062C\u0647\u0627\u0632 \u0644\u064A\u062F\u062C\u0631",
        bridge: "\u0648\u0627\u0641\u0642 \u0639\u0644\u0649 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0641\u064A \u0627\u0644\u0645\u062D\u0641\u0638\u0629"
      }
    },
    ledger: {
      connectWithLedger: "\u0627\u062A\u0635\u0644 \u0645\u0639 \u0644\u064A\u062F\u062C\u0631",
      makeSureYourLedger: "\u062A\u0623\u0643\u062F \u0623\u0646 \u0644\u064A\u062F\u062C\u0631 \u0645\u062A\u0635\u0644 \u0628\u0623\u0645\u0627\u0646, \u0648 \u0623\u0646 \u062A\u0637\u0628\u064A\u0642 \u0646\u064A\u0631 \u0645\u0641\u062A\u0648\u062D \u0641\u064A \u062C\u0647\u0627\u0632\u0643",
      "continue": "\u062A\u0627\u0628\u0639",
      specifyHDPath: "\u062D\u062F\u062F \u0645\u0633\u0627\u0631 \u0627\u0644\u062D\u0633\u0627\u0628",
      enterYourPreferredHDPath: "\u0623\u062F\u062E\u0644 \u0645\u0633\u0627\u0631 \u0627\u0644\u062D\u0633\u0627\u0628 \u0627\u0644\u0645\u0641\u0636\u0644\u060C \u062B\u0645 \u0627\u0628\u062D\u062B \u0639\u0646 \u0643\u0644 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0627\u0644\u0646\u0634\u0637\u0629",
      scan: "\u0645\u0633\u062D",
      retry: "\u0623\u0639\u062F \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629",
      ledgerIsNotAvailable: "\u0644\u064A\u062F\u062C\u0631 \u063A\u064A\u0631 \u0645\u062A\u0648\u0641\u0631",
      accessDeniedToUseLedgerDevice: "\u062A\u0645 \u0631\u0641\u0636 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628\u0644\u064A\u062F\u062C\u0631",
      noAccountsFound: "\u0644\u0645 \u064A\u062A\u0645 \u0627\u0644\u0639\u062B\u0648\u0631 \u0639\u0644\u0649 \u0623\u064A \u062D\u0633\u0627\u0628\u0627\u062A",
      selectYourAccounts: "\u062D\u062F\u062F \u062D\u0633\u0627\u0628\u0627\u062A\u0643",
      connecting1Account: "\u062C\u0627\u0631\u064A \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628\u062D\u0633\u0627\u0628 \u0648\u0627\u062D\u062F",
      cantFindAnyAccount: "\u0644\u0627 \u064A\u0645\u0643\u0646 \u0627\u0644\u0639\u062B\u0648\u0631 \u0639\u0644\u0649 \u0623\u064A \u062D\u0633\u0627\u0628 \u0645\u0631\u062A\u0628\u0637 \u0628\u0647\u0630\u0627 \u0644\u064A\u062F\u062C\u0631 \u0627\u0644\u0631\u062C\u0627\u0621 \u0625\u0646\u0634\u0627\u0621 \u062D\u0633\u0627\u0628 \u0646\u064A\u0631 \u062C\u062F\u064A\u062F \u0639\u0644\u0649",
      orConnectAnAnotherLedger: "\u0627\u0648 \u0627\u0631\u0628\u0637 \u062C\u0647\u0627\u0632 \u0644\u064A\u062F\u062C\u0631 \u0622\u062E\u0631",
      connecting: "\u062C\u0627\u0631\u064A \u0627\u0644\u0627\u062A\u0635\u0627\u0644",
      ofAccounts: "\u0645\u0646 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A",
      failedToAutomatically: "\u0641\u0634\u0644 \u0641\u064A \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628\u0627\u0644\u062D\u0633\u0627\u0628 \u062A\u0644\u0642\u0627\u0626\u064A\u0627. \u064A\u0631\u062C\u0649 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628\u0627\u0644\u062D\u0633\u0627\u0628 \u064A\u062F\u0648\u064A\u0627",
      overviewTheListOfAuthorized: "\u0644\u0627\u0626\u062D\u0629 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0627\u0644\u0645\u0635\u0631\u062D \u0628\u0647\u0627, \u0623\u0643\u0645\u0644 \u062A\u0633\u062C\u064A\u0644 \u0627\u0644\u062F\u062E\u0648\u0644 \u0628\u0627\u0644\u0646\u0642\u0631 \u0639\u0644\u0649 \u0627\u0644\u0632\u0631 \u0623\u062F\u0646\u0627\u0647",
      finish: "\u0625\u0646\u0647\u0627\u0621"
    },
    install: {
      youllNeedToInstall: "\u0633\u062A\u062D\u062A\u0627\u062C \u0644\u062A\u062B\u0628\u064A\u062A",
      toContinueAfterInstalling: "\u0644\u0644\u0627\u0633\u062A\u0643\u0645\u0627\u0644. \u0628\u0639\u062F \u0627\u0644\u062A\u062B\u0628\u064A\u062A",
      refreshThePage: "\u0642\u0645 \u0628\u062A\u062D\u062F\u064A\u062B \u0627\u0644\u0635\u0641\u062D\u0629",
      open: "\u0627\u0641\u062A\u062D"
    },
    qr: {
      copiedToClipboard: "\u062A\u0645 \u0627\u0644\u0646\u0633\u062E",
      failedToCopy: "\u0641\u0634\u0644 \u0627\u0644\u0646\u0633\u062E",
      scanWithYourMobile: "\u0627\u0645\u0633\u062D \u0628\u062C\u0647\u0627\u0632\u0643 \u0627\u0644\u0645\u062D\u0645\u0648\u0644",
      copyToClipboard: "\u0646\u0633\u062E",
      preferTheOfficial: "\u062A\u0641\u0636\u0644 \u0627\u0644\u062D\u0648\u0627\u0631 \u0627\u0644\u0631\u0633\u0645\u064A \u0644",
      open: "\u0641\u062A\u062D"
    },
    walletTypes: {
      hardware: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0623\u062C\u0647\u0632\u0629",
      browser: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0645\u062A\u0635\u0641\u062D",
      injected: "\u0645\u0644\u062D\u0642 \u0627\u0644\u0645\u062D\u0641\u0638\u0629",
      bridge: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u062C\u0633\u0631",
      mobile: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u062C\u0648\u0627\u0644",
      "instant-link": "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0631\u0627\u0628\u0637 \u0627\u0644\u0641\u0648\u0631\u064A"
    },
    exportAccounts: {
      afterDecide: "\u0628\u0639\u062F \u0627\u062A\u062E\u0627\u0630 \u0642\u0631\u0627\u0631 \u0628\u0634\u0623\u0646 \u0645\u062D\u0641\u0638\u0629\u060C \u064A\u0645\u0643\u0646\u0643 \u0627\u062E\u062A\u064A\u0627\u0631 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0627\u0644\u062A\u064A \u062A\u0631\u064A\u062F \u0646\u0642\u0644\u0647\u0627.",
      chooseAWallet: "\u0627\u062E\u062A\u0631 \u0645\u062D\u0641\u0638\u0629",
      disclaimer: "\u0644\u0646 \u062A\u062A\u0645\u0643\u0646 \u0645\u0646 \u0646\u0642\u0644 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0627\u0644\u062A\u064A \u0644\u0645 \u064A\u062A\u0645 \u062A\u0645\u0648\u064A\u0644\u0647\u0627 \u0623\u0648 \u0627\u0633\u062A\u062E\u062F\u0627\u0645\u0647\u0627 \u0639\u0644\u0649 NEAR.",
      selectAWallet: "\u0627\u062E\u062A\u0631 \u0645\u062D\u0641\u0638\u0629 \u062A\u0646\u0627\u0633\u0628 \u0627\u062D\u062A\u064A\u0627\u062C\u0627\u062A\u0643 \u0648\u062A\u062F\u0639\u0645 \u062D\u0633\u0627\u0628\u0627\u062A\u0643 \u0627\u0644\u0645\u062A\u0635\u0644\u0629.",
      selectYourAccounts: "\u062D\u062F\u062F \u062D\u0633\u0627\u0628\u0627\u062A\u0643",
      transferYourAccounts: "\u0646\u0642\u0644 \u062D\u0633\u0627\u0628\u0627\u062A\u0643",
      warning: "\u0644\u0627 \u062A\u062F\u0639\u0645 \u062A\u0635\u062F\u064A\u0631 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0641\u064A \u0627\u0644\u0648\u0642\u062A \u0627\u0644\u062D\u0627\u0644\u064A. \u064A\u0631\u062C\u0649 \u0627\u062E\u062A\u064A\u0627\u0631 \u0645\u062D\u0641\u0638\u0629 \u0623\u062E\u0631\u0649.",
      complete: {
        button: "\u0623\u0643\u0645\u0644",
        descOne: "\u0633\u064A\u062A\u0645 \u062A\u0648\u062C\u064A\u0647\u0643 \u0627\u0644\u0622\u0646 \u0625\u0644\u0649 \u0627\u0644\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u062A\u064A \u0627\u062E\u062A\u0631\u062A\u0647\u0627 \u0644\u0625\u0643\u0645\u0627\u0644 \u0627\u0644\u0646\u0642\u0644.",
        descTwo: "\u0628\u0645\u062C\u0631\u062F \u0625\u0643\u0645\u0627\u0644 \u062C\u0632\u0621 \u0627\u0644\u0627\u0633\u062A\u064A\u0631\u0627\u062F \u0645\u0646 \u0627\u0644\u0639\u0645\u0644\u064A\u0629 \u0645\u0646 \u0627\u0644\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0645\u062D\u062F\u062F\u0629\u060C \u0627\u0636\u063A\u0637 \u0639\u0644\u0649 \u0627\u0644\u0632\u0631 \u0644\u0625\u0643\u0645\u0627\u0644 \u0639\u0645\u0644\u064A\u0629 \u0627\u0644\u0646\u0642\u0644.",
        startOverButton: "\u0627\u0628\u062F\u0623 \u0645\u0646 \u062C\u062F\u064A\u062F",
        title: "\u0623\u0643\u0645\u0644 \u0627\u0644\u0646\u0642\u0644"
      },
      getPassphrase: {
        button: "\u062A\u0627\u0628\u0639",
        checkLabel: "\u0644\u0642\u062F \u0642\u0645\u062A \u0628\u0646\u0633\u062E \u0623\u0648 \u0643\u062A\u0627\u0628\u0629 \u0643\u0644\u0645\u0629 \u0627\u0644\u0645\u0631\u0648\u0631",
        desc: "\u0633\u062A\u062D\u062A\u0627\u062C \u0625\u0644\u0649 \u0625\u062F\u062E\u0627\u0644 \u0647\u0630\u0647 \u0627\u0644\u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631\u064A\u0629 \u0639\u0646\u062F \u0628\u062F\u0621 \u062A\u0635\u062F\u064A\u0631 \u062D\u0633\u0627\u0628\u0627\u062A\u0643 \u0625\u0644\u0649 \u0645\u062D\u0641\u0638\u0629 \u0645\u062E\u062A\u0644\u0641\u0629.",
        label: "\u0627\u0646\u0642\u0631 \u0644\u0646\u0633\u062E",
        title: "\u0627\u0646\u0633\u062E \u0643\u0644\u0645\u0629 \u0627\u0644\u0645\u0631\u0648\u0631 \u0627\u0644\u0645\u0624\u0642\u062A\u0629",
        transferButton: "\u0646\u0642\u0644 \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A"
      },
      selectAccounts: {
        button: "\u062A\u0627\u0628\u0639",
        deselectAll: "\u0625\u0644\u063A\u0627\u0621 \u062A\u062D\u062F\u064A\u062F \u0627\u0644\u0643\u0644",
        error: "\u0627\u0644\u062D\u0633\u0627\u0628 \u063A\u064A\u0631 \u0645\u0648\u062C\u0648\u062F",
        noBalance: "\u0627\u0644\u062D\u0633\u0627\u0628 \u063A\u064A\u0631 \u0645\u0645\u0648\u0644",
        selectAll: "\u062A\u062D\u062F\u064A\u062F \u0627\u0644\u0643\u0644",
        title: "\u062D\u062F\u062F \u0627\u0644\u062D\u0633\u0627\u0628\u0627\u062A \u0644\u0646\u0642\u0644\u0647\u0627",
        unavailable: "\u0627\u0644\u0646\u0642\u0644 \u063A\u064A\u0631 \u0645\u062A\u0627\u062D",
        warningLedger: "\u062F\u0639\u0645 Ledger \u0645\u0637\u0644\u0648\u0628"
      },
      walletTypes: {
        bridge: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u062C\u0633\u0631",
        browser: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0645\u062A\u0635\u0641\u062D",
        hardware: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u0623\u062C\u0647\u0632\u0629",
        injected: "\u0645\u0644\u062D\u0642 \u0627\u0644\u0645\u062D\u0641\u0638\u0629",
        mobile: "\u0645\u062D\u0641\u0638\u0629 \u0627\u0644\u062C\u0648\u0627\u0644"
      }
    }
  };
  var component = {
    clickToCopy: {
      label: "\u062A\u0645 \u0627\u0644\u0646\u0633\u062E",
      tooltip: "\u0627\u0646\u0642\u0631 \u0644\u0646\u0633\u062E"
    }
  };
  var ar = {
    modal: modal$4,
    component
  };
  var modal$3 = {
    wallet: {
      connectYourWallet: "Spojite crypto nov\u010Danik!",
      whatIsAWallet: "\u0160to je to crypto nov\u010Danik?",
      secureAndManage: "Osigurajte i upravljajte svojom digitalnom imovinom.",
      safelyStore: "Sigurno pohranite i prebacite svoj crypto i NFT-eve.",
      logInToAny: " Prijavite se u bilo koju NEAR aplikaciju",
      noNeedToCreate: "Nema potrebe za stvaranjem novih naloga ili korisni\u010Dkih podataka. Spojite svoj crypto nov\u010Danik i spremni ste!",
      getAWallet: "Otvorite crypto nov\u010Danik",
      useAWallet: "Koristite crypto nov\u010Danik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisni\u010Dkog imena i lozinke.",
      connectionFailed: "Neuspje\u0161no povezivanje.",
      connectionSuccessful: "Uspje\u0161no povezivanje.",
      rememberWallet: "Zapamti nov\u010Danike",
      connected: "Povezano.",
      connectingTo: "Povezivanje u tijeku",
      connectingMessage: {
        injected: "Potvrdite vezu u eksternom prozoru",
        browser: "Nakon redirekcije, potvrdite vezu u nov\u010Daniku",
        hardware: "Potvrdite vezu sa nov\u010Danikom",
        bridge: "Potvrdite vezu u nov\u010Daniku"
      }
    },
    ledger: {
      connectWithLedger: "Pove\u017Eite se hardverskim nov\u010Danikom",
      makeSureYourLedger: "Osigurajte sigurnu vezu s hardverskim nov\u010Danikom, te da je NEAR aplikacija otvorena na va\u0161em ure\u0111aju",
      "continue": "Nastavite",
      specifyHDPath: "Specificirajte HD putanju",
      enterYourPreferredHDPath: "Upi\u0161ite preferiranu HD putanju, zatim skenirajte aktivne naloge",
      scan: "Skenirajte",
      retry: "Poku\u0161ajte ponovno",
      ledgerIsNotAvailable: "Hardverski nov\u010Danik nije dostupan.",
      accessDeniedToUseLedgerDevice: "Odbijen pristup za kori\u0161tenjem hardverskog nov\u010Danika",
      noAccountsFound: "Nalozi nisu prona\u0111eni",
      selectYourAccounts: "Odaberite svoje naloge",
      connecting1Account: "Povezivanje 1 naloga",
      cantFindAnyAccount: "Nije mogu\u0107e prona\u0107i niti jedan nalog povezan s ovim hardverskim nov\u010Danikom. Molimo vas, kreirajte novi NEAR nalog",
      orConnectAnAnotherLedger: "Ili pove\u017Eite drugi hardverski nov\u010Danik.",
      connecting: "Povezivanje",
      ofAccounts: "naloga",
      failedToAutomatically: "Neuspje\u0161no automatsko pronala\u017Eenje ID naloga. Unesite ru\u010Dno:",
      overviewTheListOfAuthorized: "Pregledajte popis odobrenih naloga, zavr\u0161ite prijavu pritiskom na ni\u017Ee prikazani gumb.",
      finish: "Zavr\u0161ite"
    },
    install: {
      youllNeedToInstall: " Potrebno je instalirati modal",
      toContinueAfterInstalling: "za nastavak. Nakon instalacije",
      refreshThePage: "osvje\u017Eite stranicu.",
      open: "Otvorite QR modal"
    },
    qr: {
      copiedToClipboard: "Kopirano u me\u0111uspremnik",
      failedToCopy: "Neupsje\u0161no kopiranje u me\u0111uspremnik",
      scanWithYourMobile: "Skenirajte svojim mobilnim ure\u0111ajem",
      copyToClipboard: " Kopirajte u me\u0111uspremnik",
      preferTheOfficial: "Odaberite slu\u017Ebeni dijalog",
      open: "Otvorite"
    },
    walletTypes: {
      hardware: "Hardware Wallet",
      browser: "Browser Wallet",
      injected: "Wallet Extension",
      bridge: "Bridge Wallet",
      mobile: "Mobile Wallet",
      "instant-link": "Instant Wallet"
    },
    exportAccounts: {
      chooseAWallet: "Odaberi Wallet",
      transferYourAccounts: "Prenesi svoje naloge",
      selectAWallet: "Odaberite wallet koji odgovara va\u0161im potrebama i podr\u017Eava va\u0161e povezane naloge.",
      selectYourAccounts: "Odaberi svoje naloge",
      afterDecide: "Nakon \u0161to odlu\u010Dite koji wallet koristite, mo\u017Eete odabrati koje ra\u010Dune \u017Eelite prebaciti.",
      disclaimer: "Ne\u0107ete mo\u0107i prebaciti naloge koji nisu nikada bili kori\u0161teni na NEAR-u.",
      warning: "ne podr\u017Eava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.",
      walletTypes: {
        hardware: "Hardware Wallet",
        browser: "Browser Wallet",
        injected: "Wallet Extension",
        bridge: "Bridge Wallet",
        mobile: "Mobile Wallet"
      },
      selectAccounts: {
        title: "Odaberi naloge za prijenos",
        button: "Generiraj lozinku",
        deselectAll: "Makni odabir sa svih",
        selectAll: "Odaberi sve",
        unavailable: "Prijenos nije dostupan",
        error: "Nalog ne postoji",
        warningLedger: "Potrebna ledger podr\u0161ka",
        noBalance: "Nalog nema sredstava"
      },
      getPassphrase: {
        title: "Kopiraj privremenu lozinku",
        desc: "Bit \u0107e potrebno unijeti ovu lozinku na po\u010Detku izvoza naloga na drugi wallet.",
        button: "Nastavi",
        label: "Klikni za kopiju",
        checkLabel: "Kopirao sam ili zapisao lozinku"
      },
      complete: {
        title: "Zavr\u0161i prijenos",
        descOne: "You will now be redirected to the wallet you selected to complete the transfer.",
        descTwo: "Kada je unos s odabranog walleta zavr\u0161en, pritisnite gumb da biste zavr\u0161ili prijenos.",
        button: "Zavr\u0161i"
      }
    }
  };
  var hr = {
    modal: modal$3
  };
  var modal$2 = {
    wallet: {
      connectYourWallet: "\u041F\u043E\u0432\u0440\u0437\u0435\u0442\u0435 \u0433\u043E \u0432\u0430\u0448\u0438\u043E\u0442 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A!",
      whatIsAWallet: "\u0428\u0442\u043E \u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A?",
      secureAndManage: "\u0417\u0430\u0448\u0442\u0438\u0442\u0435\u0442\u0435 \u0433\u0438 \u0438 \u0443\u043F\u0440\u0430\u0432\u0443\u0432\u0430\u0458\u0442\u0435 \u0441\u043E \u0432\u0430\u0448\u0438\u0442\u0435 \u0434\u0438\u0433\u0438\u0442\u0430\u043B\u043D\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430.",
      safelyStore: "\u0411\u0435\u0437\u0431\u0435\u0434\u043D\u043E \u0441\u043A\u043B\u0430\u0434\u0438\u0440\u0430\u0458\u0442\u0435 \u0438 \u0438\u0437\u0432\u0440\u0448\u0443\u0432\u0430\u0458\u0442\u0435 \u0442\u0440\u0430\u043D\u0441\u0430\u043A\u0446\u0438\u0438 \u0441\u043E \u0432\u0430\u0448\u0438\u0442\u0435 \u043A\u0440\u0438\u043F\u0442\u043E \u0438 NFT.",
      logInToAny: "\u041D\u0430\u0458\u0430\u0432\u0435\u0442\u0435 \u0441\u0435 \u043D\u0430 \u043A\u043E\u0458\u0430 \u0431\u0438\u043B\u043E NEAR \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0430",
      noNeedToCreate: "\u041D\u0435\u043C\u0430 \u043F\u043E\u0442\u0440\u0435\u0431\u0430 \u0434\u0430 \u043A\u0440\u0435\u0438\u0440\u0430\u0442\u0435 \u043D\u043E\u0432\u0438 \u0441\u043C\u0435\u0442\u043A\u0438 \u0438\u043B\u0438 \u0438\u043D\u0433\u0435\u0440\u0435\u043D\u0446\u0438\u0438. \u041F\u043E\u0432\u0440\u0437\u0435\u0442\u0435 \u0433\u043E \u0432\u0430\u0448\u0438\u043E\u0442 \u043F\u0430\u0440\u0438\u0447\u043D\u0438\u043A \u0438 \u0441\u0442\u0435 \u043F\u043E\u0434\u0433\u043E\u0442\u0432\u0435\u043D\u0438!",
      getAWallet: "\u041D\u0430\u043F\u0440\u0430\u0432\u0435\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      useAWallet: "\u041A\u043E\u0440\u0438\u0441\u0442\u0435\u0442\u0435 \u043F\u0430\u0440\u0438\u0447\u043D\u0438\u043A \u0437\u0430 \u0434\u0430 \u0433\u0438 \u0437\u0430\u0448\u0442\u0438\u0442\u0438\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u0443\u0432\u0430\u0442\u0435 \u0432\u0430\u0448\u0438\u0442\u0435 NEAR \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0438 \u0434\u0430 \u0441\u0435 \u043D\u0430\u0458\u0430\u0432\u0438\u0442\u0435 \u043D\u0430 \u043A\u043E\u0458\u0430 \u0431\u0438\u043B\u043E NEAR \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0430 \u0431\u0435\u0437 \u043F\u043E\u0442\u0440\u0435\u0431\u0430 \u043E\u0434 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0438\u043C\u0438\u045A\u0430 \u0438 \u043B\u043E\u0437\u0438\u043D\u043A\u0438.",
      connectionFailed: "\u041F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435\u0442\u043E \u043D\u0435 \u0431\u0435\u0448\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E.",
      connectionSuccessful: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u043F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435.",
      rememberWallet: "\u0417\u0430\u043F\u043E\u043C\u043D\u0438 \u043F\u0430\u0440\u0438\u0447\u043D\u0438\u0446\u0438",
      connected: "\u041F\u043E\u0432\u0440\u0437\u0430\u043D\u043E.",
      connectingTo: "\u041F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435 \u0441\u043E",
      connectingMessage: {
        injected: "\u041F\u043E\u0442\u0432\u0440\u0434\u0435\u0442\u0435 \u0433\u043E \u043F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435\u0442\u043E \u0432\u043E \u0435\u043A\u0441\u0442\u0435\u0440\u043D\u0438\u043E\u0442 \u043F\u0440\u043E\u0437\u043E\u0440\u0435\u0446",
        browser: "\u041F\u043E \u043F\u0440\u0435\u0443\u0441\u043C\u0435\u0440\u0443\u0432\u0430\u045A\u0435\u0442\u043E, \u043F\u043E\u0442\u0432\u0440\u0434\u0435\u0442\u0435 \u0433\u043E \u043F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435\u0442\u043E \u043E\u0434 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043E\u043A\u0442",
        hardware: "\u041F\u043E\u0442\u0432\u0440\u0434\u0435\u0442\u0435 \u0433\u043E \u043F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435\u0442\u043E \u0441\u043E \u043B\u0430\u0434\u0435\u043D \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        bridge: "\u041F\u043E\u0442\u0432\u0440\u0434\u0435\u0442\u0435 \u0458\u0430 \u0432\u0440\u0441\u043A\u0430\u0442\u0430 \u0432\u043E \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u043E\u0442"
      }
    },
    ledger: {
      connectWithLedger: "\u041F\u043E\u0432\u0440\u0437\u0435\u0442\u0435 \u0441\u0435 \u0441\u043E \u041B\u0435\u045F\u0435\u0440",
      makeSureYourLedger: "\u041E\u0441\u0438\u0433\u0443\u0440\u0430\u0458\u0442\u0435 \u0441\u0435 \u0434\u0435\u043A\u0430 \u0432\u0430\u0448\u0438\u043E\u0442 \u041B\u0435\u045F\u0435\u0440 \u0435 \u043F\u043E\u0432\u0440\u0437\u0430\u043D \u0431\u0435\u0437\u0431\u0435\u0434\u043D\u043E, \u0438 \u0434\u0435\u043A\u0430 NEAR \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0430\u0442\u0430 \u0435 \u043E\u0442\u0432\u043E\u0440\u0435\u043D\u0430 \u043D\u0430 \u0432\u0430\u0448\u0438\u043E\u0442 \u0443\u0440\u0435\u0434",
      "continue": "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0435\u0442\u0435",
      specifyHDPath: "\u041D\u0430\u0432\u0435\u0434\u0435\u0442\u0435 \u0425\u0414 \u043B\u043E\u043A\u0430\u0446\u0438\u0458\u0430",
      enterYourPreferredHDPath: "\u0412\u043D\u0435\u0441\u0435\u0442\u0435 \u0458\u0430 \u0432\u0430\u0448\u0430\u0442\u0430 \u043F\u0440\u0435\u0444\u0435\u0440\u0438\u0440\u0430\u043D\u0430 \u0425\u0414 \u043B\u043E\u043A\u0430\u0446\u0438\u0458\u0430, \u0430 \u043F\u043E\u0442\u043E\u0430 \u0441\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435 \u0434\u0430 \u0433\u0438 \u043D\u0430\u0458\u0434\u0435\u0442\u0435 \u0430\u043A\u0442\u0438\u0432\u043D\u0438\u0442\u0435 \u0441\u043C\u0435\u0442\u043A\u0438.",
      scan: "\u0421\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435",
      retry: "\u041E\u0431\u0438\u0434\u0435\u0442\u0435 \u0441\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u043D\u043E",
      ledgerIsNotAvailable: "\u041B\u0435\u045F\u0435\u0440\u043E\u0442 \u043D\u0435 \u0435 \u0434\u043E\u0441\u0442\u0430\u043F\u0435\u043D.",
      accessDeniedToUseLedgerDevice: "\u041F\u0440\u0438\u0441\u0442\u0430\u043F\u043E\u0442 \u0437\u0430 \u043A\u043E\u0440\u0438\u0441\u0442\u0435\u045A\u0435 \u043D\u0430 \u041B\u0435\u045F\u0435\u0440 \u0443\u0440\u0435\u0434 \u0435 \u043E\u0434\u0431\u0438\u0435\u043D",
      noAccountsFound: "\u041D\u0435\u043C\u0430 \u043D\u0430\u0458\u0434\u0435\u043D\u0438 \u0441\u043C\u0435\u0442\u043A\u0438",
      selectYourAccounts: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0433\u0438 \u0432\u0430\u0448\u0438\u0442\u0435 \u0441\u043C\u0435\u0442\u043A\u0438",
      connecting1Account: "\u041F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435 \u043D\u0430 \u0435\u0434\u043D\u0430 \u0441\u043C\u0435\u0442\u043A\u0430",
      cantFindAnyAccount: "\u041D\u0435 \u0441\u0435 \u043D\u0430\u0458\u0434\u0435\u043D\u0438 \u0441\u043C\u0435\u0442\u043A\u0438 \u043F\u043E\u0432\u0440\u0437\u0430\u043D\u0438 \u0441\u043E \u043E\u0432\u043E\u0458 \u041B\u0435\u045F\u0435\u0440. \u0412\u0435 \u043C\u043E\u043B\u0438\u043C\u0435 \u043A\u0440\u0435\u0438\u0440\u0430\u0458\u0442\u0435 \u043D\u043E\u0432\u0430 NEAR \u0441\u043C\u0435\u0442\u043A\u0430 ",
      orConnectAnAnotherLedger: "\u0438\u043B\u0438 \u043F\u043E\u0432\u0440\u0437\u0435\u0442\u0435 \u0434\u0440\u0443\u0433 \u041B\u0435\u045F\u0435\u0440.",
      connecting: "\u041F\u043E\u0432\u0440\u0437\u0443\u0432\u0430\u045A\u0435",
      ofAccounts: "\u043D\u0430 \u0441\u043C\u0435\u0442\u043A\u0438",
      failedToAutomatically: "\u041D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0441\u043A\u043E \u0431\u0430\u0440\u0430\u045A\u0435 \u043D\u0430 \u0418\u0414 \u043D\u0430 \u0441\u043C\u0435\u0442\u043A\u0430\u0442\u0430. \u0412\u043D\u0435\u0441\u0435\u0442\u0435 \u0433\u043E \u0440\u0430\u0447\u043D\u043E:",
      overviewTheListOfAuthorized: "\u041F\u0440\u0435\u0433\u043B\u0435\u0434 \u043D\u0430 \u043B\u0438\u0441\u0442\u0430\u0442\u0430 \u043D\u0430 \u043E\u0432\u043B\u0430\u0441\u0442\u0435\u043D\u0438 \u0441\u043C\u0435\u0442\u043A\u0438, \u0437\u0430\u0432\u0440\u0448\u0435\u0442\u0435 \u0441\u0435 \u043D\u0430\u0458\u0430\u0432\u0430\u0442\u0430 \u0441\u043E \u043A\u043B\u0438\u043A\u043D\u0443\u0432\u0430\u045A\u0435 \u043D\u0430 \u043A\u043E\u043F\u0447\u0435\u0442\u043E \u043F\u043E\u0434\u043E\u043B\u0443.",
      finish: "\u0417\u0430\u0432\u0440\u0448\u0435\u0442\u0435"
    },
    install: {
      youllNeedToInstall: "\u0422\u0440\u0435\u0431\u0430 \u0434\u0430 \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u0442\u0435",
      toContinueAfterInstalling: "\u0437\u0430 \u0434\u0430 \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435. \u041F\u043E \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u045A\u0435\u0442\u043E",
      refreshThePage: "\u041E\u0441\u0432\u0435\u0436\u0435\u0442\u0435 \u0458\u0430 \u0441\u0442\u0440\u0430\u043D\u0430\u0442\u0430.",
      open: "\u041E\u0442\u0432\u043E\u0440\u0435\u0442\u0435"
    },
    qr: {
      copiedToClipboard: "\u041A\u043E\u043F\u0438\u0440\u0430\u043D\u043E \u043D\u0430 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u043E\u0442",
      failedToCopy: "\u041D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043A\u043E\u043F\u0438\u0440\u0430\u045A\u0435 \u043D\u0430 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434",
      scanWithYourMobile: "\u0421\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435 \u0441\u043E \u0432\u0430\u0448\u0438\u043E\u0442 \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0441\u043A\u0438 \u0443\u0440\u0435\u0434",
      copyToClipboard: "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u043D\u0430 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434",
      preferTheOfficial: "\u041F\u0440\u0435\u0444\u0435\u0440\u0438\u0440\u0430\u0458\u0442\u0435 \u043E\u0444\u0438\u0446\u0438\u0458\u0430\u043B\u0435\u043D \u0434\u0438\u0430\u043B\u043E\u0433 \u043D\u0430",
      open: "\u041E\u0442\u0432\u043E\u0440\u0435\u0442\u0435"
    },
    walletTypes: {
      hardware: "\u0425\u0430\u0440\u0434\u0432\u0435\u0440\u0441\u043A\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      browser: "\u041D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043D\u0430 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442 \u043F\u0440\u0435\u043B\u0438\u0441\u0442\u0443\u0432\u0430\u0447",
      injected: "\u0415\u043A\u0441\u0442\u0435\u043D\u0437\u0438\u0458\u0430 \u0437\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      bridge: "Bridge \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      mobile: "\u041C\u043E\u0431\u0438\u043B\u0435\u043D \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      "instant-link": "\u0418\u043D\u0441\u0442\u0430\u043D\u0442 \u043F\u0430\u0440\u0438\u0447\u043D\u0438\u043A"
    },
    exportAccounts: {
      chooseAWallet: "\u041E\u0434\u0431\u0435\u0440\u0435\u0442\u0435 \u043F\u0430\u0440\u0438\u0447\u043D\u0438\u043A",
      transferYourAccounts: "\u041F\u0440\u0435\u0444\u0440\u043B\u0435\u0442\u0435 \u0433\u0438 \u0432\u0430\u0448\u0438\u0442\u0435 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438",
      selectAWallet: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435\u043D \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043A\u043E\u0458 \u0433\u0438 \u0437\u0430\u0434\u043E\u0432\u043E\u043B\u0443\u0432\u0430 \u0432\u0430\u0448\u0438\u0442\u0435 \u0431\u0430\u0440\u0430\u043D\u045A\u0430 \u0438 \u0433\u0438 \u043F\u043E\u0434\u0434\u0440\u0436\u0443\u0432\u0430 \u0432\u0430\u0448\u0438\u0442\u0435 \u043F\u043E\u0432\u0440\u0437\u0430\u043D\u0438 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438.",
      selectYourAccounts: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0433\u0438 \u0432\u0430\u0448\u0438\u0442\u0435 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438",
      afterDecide: "\u041E\u0434\u043A\u0430\u043A\u043E \u045C\u0435 \u0438\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A, \u043C\u043E\u0436\u0435\u0442\u0435 \u0434\u0430 \u0438\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u043A\u043E\u0438 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438 \u0441\u0430\u043A\u0430\u0442\u0435 \u0434\u0430 \u0433\u0438 \u043F\u0440\u0435\u0444\u0440\u043B\u0438\u0442\u0435.",
      disclaimer: "\u041D\u0435 \u043C\u043E\u0436\u0435\u0442\u0435 \u0434\u0430 \u043F\u0440\u0444\u0440\u043B\u0430\u0442\u0435 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438 \u043A\u043E\u0438 \u043D\u0438\u043A\u043E\u0433\u0430\u0448 \u043D\u0435 \u0431\u0438\u043B\u0435 \u043D\u0430\u0434\u043E\u043F\u043E\u043B\u043D\u0430\u0442\u0438 \u0438\u043B\u0438 \u043A\u043E\u0440\u0438\u0441\u0442\u0435\u043D\u0438 \u043D\u0430 NEAR.",
      warning: "\u043D\u0435 \u043F\u043E\u0434\u0434\u0440\u0436\u0443\u0432\u0430 \u0438\u0437\u0432\u0435\u0437\u0443\u0432\u0430\u045A\u0435 \u043D\u0430 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438 \u0441\u043C\u0435\u0442\u043A\u0438 \u0432\u043E \u043E\u0432\u043E\u0458 \u043C\u043E\u043C\u0435\u043D\u0442. \u0412\u0435 \u043C\u043E\u043B\u0438\u043C\u0435 \u0438\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0434\u0440\u0443\u0433 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A.",
      walletTypes: {
        hardware: "\u0425\u0430\u0440\u0434\u0432\u0435\u0440\u0441\u043A\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        browser: "\u041D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043D\u0430 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442 \u043F\u0440\u0435\u043B\u0438\u0441\u0442\u0443\u0432\u0430\u0447",
        injected: "\u0415\u043A\u0441\u0442\u0435\u043D\u0437\u0438\u0458\u0430 \u0437\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        bridge: "Bridge \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        mobile: "\u041C\u043E\u0431\u0438\u043B\u0435\u043D \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A"
      },
      selectAccounts: {
        title: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0433\u0438 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438\u0442\u0435 \u0441\u043C\u0435\u0442\u043A\u0438 \u0437\u0430 \u0434\u0430 \u0433\u0438 \u043F\u0440\u0435\u0444\u0440\u043B\u0438\u0442\u0435.",
        button: "\u0414\u043E\u0431\u0438\u0458\u0442\u0435 \u043B\u043E\u0437\u0438\u043D\u043A\u0430",
        deselectAll: "\u041E\u0442\u0441\u0435\u043B\u0435\u043A\u0442\u0438\u0440\u0430\u0458\u0442\u0435 \u0441\u0435",
        selectAll: "\u0418\u0437\u0431\u0435\u0440\u0435\u0442\u0435 \u0441\u0435",
        unavailable: "\u0422\u0440\u0430\u043D\u0441\u0444\u0435\u0440\u043E\u0442 \u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0430\u043F\u0435\u043D",
        error: "\u041A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0430\u0442\u0430 \u0441\u043C\u0435\u0442\u043A\u0430 \u043D\u0435 \u043F\u043E\u0441\u0442\u043E\u0438",
        warningLedger: "\u041F\u043E\u0442\u0440\u0435\u0431\u043D\u0430 \u0435 \u043F\u043E\u0434\u0434\u0440\u0448\u043A\u0430 \u043E\u0434 \u041B\u0435\u045F\u0435\u0440",
        noBalance: "\u0421\u043C\u0435\u0442\u043A\u0430\u0442\u0430 \u043D\u0435 \u0435 \u0444\u0438\u043D\u0430\u043D\u0441\u0438\u0440\u0430\u043D\u0430"
      },
      getPassphrase: {
        title: "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u0458\u0430 \u043F\u0440\u0438\u0432\u0440\u0435\u043C\u0435\u043D\u0430\u0442\u0430 \u043B\u043E\u0437\u0438\u043D\u043A\u0430",
        desc: "\u040C\u0435 \u0442\u0440\u0435\u0431\u0430 \u0434\u0430 \u0458\u0430 \u0432\u043D\u0435\u0441\u0435\u0442\u0435 \u043E\u0432\u0430\u0430 \u043B\u043E\u0437\u0438\u043D\u043A\u0430 \u043A\u043E\u0433\u0430 \u045C\u0435 \u0437\u0430\u043F\u043E\u0447\u043D\u0435\u0442\u0435 \u0434\u0430 \u0433\u0438 \u0438\u0437\u0432\u0435\u0437\u0443\u0432\u0430\u0442\u0435 \u0432\u0430\u0448\u0438\u0442\u0435 \u0441\u043C\u0435\u0442\u043A\u0438 \u043D\u0430 \u0434\u0440\u0443\u0433 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A.",
        button: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0435\u0442\u0435",
        label: "\u041A\u043B\u0438\u043A\u043D\u0435\u0442\u0435 \u0437\u0430 \u0434\u0430 \u043A\u043E\u043F\u0438\u0440\u0430\u0442\u0435",
        checkLabel: "\u0408\u0430 \u043A\u043E\u043F\u0438\u0440\u0430\u0432 \u0438\u043B\u0438 \u0437\u0430\u043F\u0438\u0448\u0430\u0432 \u043B\u043E\u0437\u0438\u043D\u043A\u0430\u0442\u0430"
      },
      complete: {
        title: "\u0417\u0430\u0432\u0440\u0448\u0435\u0442\u0435 \u0433\u043E \u043F\u0440\u0435\u043D\u043E\u0441\u043E\u0442",
        descOne: "\u0421\u0435\u0433\u0430 \u045C\u0435 \u0431\u0438\u0434\u0435\u0442\u0435 \u043F\u0440\u0435\u043D\u0430\u0441\u043E\u0447\u0435\u043D\u0438 \u043D\u0430 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u043E\u0442 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u0437\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430\u045A\u0435 \u043D\u0430 \u043F\u0440\u0435\u043D\u043E\u0441\u043E\u0442.",
        descTwo: "\u041E\u0442\u043A\u0430\u043A\u043E \u045C\u0435 \u0437\u0430\u0432\u0440\u0448\u0438 \u0443\u0432\u043E\u0437\u043E\u0442 \u043E\u0434 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u043E\u0442 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A, \u043F\u0440\u0438\u0442\u0438\u0441\u043D\u0435\u0442\u0435 \u0433\u043E \u043A\u043E\u043F\u0447\u0435\u0442\u043E \u0437\u0430 \u0434\u0430 \u0433\u043E \u0437\u0430\u0432\u0440\u0448\u0438\u0442\u0435 \u043F\u0440\u0435\u043D\u043E\u0441\u043E\u0442.",
        button: "\u0417\u0430\u0432\u0440\u0448\u0435\u0442\u0435"
      }
    }
  };
  var mk = {
    modal: modal$2
  };
  var modal$1 = {
    wallet: {
      connectYourWallet: "Pove\u017Eite svojo denarnico!",
      whatIsAWallet: "Kaj je denarnica?",
      secureAndManage: "Zavarujte in upravljajte svoja digitalna sredstva.",
      safelyStore: "Varno shranjujte in prena\u0161ajte svoje kriptovalute in NFTje.",
      logInToAny: "Prijavite se v katero koli aplikacijo na NEAR",
      noNeedToCreate: "Ni vam treba ustvarjati novih ra\u010Dunov. Pove\u017Eite svojo denarnico in za\u010Dnite!",
      getAWallet: "Ustvarite denarnico",
      useAWallet: "Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR",
      connectionFailed: "Povezava ni bila uspe\u0161na.",
      connectionSuccessful: "Povezava je bila uspe\u0161na.",
      rememberWallet: "Zapomni si denarnice",
      connected: "Va\u0161a denarnica je povezana.",
      connectingTo: "Povezovanje z",
      connectingMessage: {
        injected: "Potrdite povezavo v oknu raz\u0161iritve",
        browser: "Po preusmeritvi potrdite povezavo v denarnici",
        hardware: "Potrdite povezavo s hladno denarnico",
        bridge: "Potrdite povezavo v denarnici"
      }
    },
    ledger: {
      connectWithLedger: "Pove\u017Eite se z Ledger",
      makeSureYourLedger: "Prepri\u010Dajte se, da je va\u0161 Ledger varno povezan in da je aplikacija NEAR odprta v va\u0161i napravi",
      "continue": "Nadaljuj",
      specifyHDPath: "Dolo\u010Dite HD pot",
      enterYourPreferredHDPath: "Vnesite \u017Eeleno HD pot, nato poi\u0161\u010Dite vse aktivne ra\u010Dune.",
      scan: "Skenirajte",
      retry: "Poskusite znova",
      ledgerIsNotAvailable: "Ledger ni na voljo",
      accessDeniedToUseLedgerDevice: "Dostop za uporabo naprave Ledger zavrnjen",
      noAccountsFound: "Ni najdenih ra\u010Dunov",
      selectYourAccounts: "Izberite Va\u0161i ra\u010Duni",
      connecting1Account: "Povezovanje enega ra\u010Duna",
      cantFindAnyAccount: "Ni mogo\u010De najti nobenega ra\u010Duna, povezanega s tem Ledgerjem. Ustvarite nov NEAR ra\u010Dun ",
      orConnectAnAnotherLedger: "ali pove\u017Eite drug Ledger..",
      connecting: "Povezovanje",
      ofAccounts: "ra\u010Dunov",
      failedToAutomatically: "ID-ja ra\u010Duna ni bilo mogo\u010De samodejno najti. Zagotovite ga ro\u010Dno:",
      overviewTheListOfAuthorized: "Oglejte si seznam poobla\u0161\u010Denih ra\u010Dunov, dokon\u010Dajte prijavo s klikom na spodnji gumb.",
      finish: "Kon\u010Dajte"
    },
    install: {
      youllNeedToInstall: "Morali ga boste namestiti",
      toContinueAfterInstalling: "nadaljevati. Po namestitvi",
      refreshThePage: "Osve\u017Eite stran.",
      open: "Odprite"
    },
    qr: {
      copiedToClipboard: "Kopirano v podlo\u017Eni mapi",
      failedToCopy: "Kopiranje v podlo\u017Eni mapi ni uspelo",
      scanWithYourMobile: "Skenirajte s svojo mobilno napravo",
      copyToClipboard: " Kopirajte v podlo\u017Eni mapi",
      preferTheOfficial: "Preferirajte uradno pogovorno okno",
      open: "Odprite"
    },
    walletTypes: {
      hardware: "Hladna denarnica",
      browser: "Denarnica brskalnika",
      injected: "Raz\u0161iritev za denarnico",
      bridge: "Bridge denarnica",
      mobile: "Mobilna denarnica",
      "instant-link": "Takoj\u0161nja denarnica"
    },
    exportAccounts: {
      chooseAWallet: "Izberite denarnico",
      transferYourAccounts: "Prenesite svoje ra\u010Dune",
      selectAWallet: "Izberite denarnico, ki ustreza va\u0161im potrebam in podpira va\u0161e povezane ra\u010Dune.",
      selectYourAccounts: "Izberite va\u0161i ra\u010Duni",
      afterDecide: "Ko se odlo\u010Dite za denarnico, lahko izberete, katere ra\u010Dune \u017Eelite prenesti.",
      disclaimer: "Ne boste mogli prenesti Ra\u010Dunov, ki nikoli niso bili financirani ali uporabljeni na NEAR.",
      warning: "trenutno ne podpira izvoza ra\u010Duna. Izberite drugo denarnico",
      walletTypes: {
        hardware: "Hladna denarnica",
        browser: "Denarnica brskalnika",
        injected: "Raz\u0161iritev za denarnico",
        bridge: "Bridge denarnica",
        mobile: "Mobilna denarnica"
      },
      selectAccounts: {
        title: "Izberite ra\u010Duni za prenos.",
        button: "Pridobite geslo",
        deselectAll: "Prekli\u010Di izbiro vseh",
        selectAll: "Izberi vse",
        unavailable: "Prenos ni na voljo",
        error: "Ra\u010Dun ne obstaja",
        warningLedger: "Potrebna je podpora za Ledger",
        noBalance: "Ra\u010Dun ni financiran"
      },
      getPassphrase: {
        title: "Kopiraj za\u010Dasno geslo",
        desc: "To geslo boste morali vnesti, ko boste za\u010Deli izva\u017Eati svoje ra\u010Dune v drugo denarnico.",
        button: "Nadaljujte",
        label: "Kliknite za kopiranje",
        checkLabel: "Geslo sem kopiral ali zapisal"
      },
      complete: {
        title: "Dokon\u010Dajte prenos",
        descOne: "Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokon\u010Danje prenosa.",
        descTwo: "Ko je uvozni del postopka kon\u010Dan iz izbrane denarnice, pritisnite gumb za dokon\u010Danje postopka prenosa.",
        button: "Kon\u010Dajte"
      }
    }
  };
  var sl = {
    modal: modal$1
  };
  var modal = {
    wallet: {
      connectYourWallet: "\u041F\u043E\u0432\u0435\u0436\u0438\u0442\u0435 \u0441\u0432\u043E\u0458 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A!",
      whatIsAWallet: "\u0428\u0442\u0430 \u0458\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A?",
      secureAndManage: "\u041E\u0431\u0435\u0437\u0431\u0435\u0434\u0438\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u0459\u0430\u0458\u0442\u0435 \u0441\u0432\u043E\u0458\u043E\u043C \u0434\u0438\u0433\u0438\u0442\u0430\u043B\u043D\u043E\u043C \u0438\u043C\u043E\u0432\u0438\u043D\u043E\u043C.",
      safelyStore: "\u0411\u0435\u0437\u0431\u0435\u0434\u043D\u043E \u0447\u0443\u0432\u0430\u0458\u0442\u0435 \u0438 \u043F\u0440\u0435\u043D\u043E\u0441\u0438\u0442\u0435 \u0441\u0432\u043E\u0458\u0435 \u043A\u0440\u0438\u043F\u0442\u043E\u0432\u0430\u043B\u0443\u0442\u0435 \u0438 NFT.",
      logInToAny: "\u041F\u0440\u0438\u0458\u0430\u0432\u0438\u0442\u0435 \u0441\u0435 \u043D\u0430 \u0431\u0438\u043B\u043E \u043A\u043E\u0458\u0443 \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0443 NEAR",
      noNeedToCreate: "\u041D\u0435\u043C\u0430 \u043F\u043E\u0442\u0440\u0435\u0431\u0435 \u0434\u0430 \u043A\u0440\u0435\u0438\u0440\u0430\u0442\u0435 \u043D\u043E\u0432\u0435 \u043D\u0430\u043B\u043E\u0433\u0435 \u0438\u043B\u0438 \u0430\u043A\u0440\u0435\u0434\u0438\u0442\u0438\u0432\u0435. \u041F\u043E\u0432\u0435\u0436\u0438\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u0438 \u0441\u043F\u0440\u0435\u043C\u043D\u0438 \u0441\u0442e!",
      getAWallet: "\u041D\u0430\u0431\u0430\u0432\u0438\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      useAWallet: "\u041A\u043E\u0440\u0438\u0441\u0442\u0438\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u0434\u0430 \u043E\u0431\u0435\u0437\u0431\u0435\u0434\u0438\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u0459\u0430\u0442\u0435 \u0441\u0432\u043E\u0458\u0438\u043C NEAR \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0438\u043C\u0430 \u0438 \u0434\u0430 \u0441\u0435 \u043F\u0440\u0438\u0458\u0430\u0432\u0438\u0442\u0435 \u0443 \u0431\u0438\u043B\u043E \u043A\u043E\u0458\u0443 \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0443 NEAR \u0431\u0435\u0437 \u043F\u043E\u0442\u0440\u0435\u0431\u0435 \u0437\u0430 \u043A\u043E\u0440\u0438\u0441\u043D\u0438\u0447\u043A\u0438\u043C \u0438\u043C\u0435\u043D\u0438\u043C\u0430 \u0438 \u043B\u043E\u0437\u0438\u043D\u043A\u0430\u043C\u0430.",
      connectionFailed: "\u0412\u0435\u0437\u0430 \u043D\u0438\u0458\u0435 \u0443\u0441\u043F\u043E\u0441\u0442\u0430\u0432\u0459\u0435\u043D\u0430.",
      connectionSuccessful: "\u0412\u0435\u0437\u0430 \u0458\u0435 \u0443\u0441\u043F\u0435\u043B\u0430.",
      rememberWallet: "\u0417\u0430\u043F\u0430\u043C\u0442\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u0435",
      connected: "\u041F\u043E\u0432\u0435\u0437\u0430\u043D.",
      connectingTo: "\u041F\u043E\u0432\u0435\u0437\u0438\u0432\u0430\u045A\u0435 \u043D\u0430",
      connectingMessage: {
        injected: "\u041F\u043E\u0442\u0432\u0440\u0434\u0438\u0442\u0435 \u0432\u0435\u0437\u0443 \u0443 \u0441\u043F\u043E\u0459\u043D\u043E\u043C \u043F\u0440\u043E\u0437\u043E\u0440\u0443",
        browser: "\u041D\u0430\u043A\u043E\u043D \u043F\u0440\u0435\u0443\u0441\u043C\u0435\u0440\u0430\u0432\u0430\u045A\u0430, \u043F\u043E\u0442\u0432\u0440\u0434\u0438\u0442\u0435 \u0432\u0435\u0437\u0443 \u0443 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u0443",
        hardware: "\u041F\u043E\u0442\u0432\u0440\u0434\u0438\u0442\u0435 \u0432\u0435\u0437\u0443 \u0441\u0430 \u0445\u043B\u0430\u0434\u043D\u0438\u043C \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u043E\u043C",
        bridge: "\u041F\u043E\u0442\u0432\u0440\u0434\u0438\u0442\u0435 \u0432\u0435\u0437\u0443 \u0441\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u043E\u043C"
      }
    },
    ledger: {
      connectWithLedger: "\u041F\u043E\u0432\u0435\u0436\u0438\u0442\u0435 \u0441\u0435 \u0441\u0430 Ledger",
      makeSureYourLedger: "\u0423\u0432\u0435\u0440\u0438\u0442\u0435 \u0441\u0435 \u0434\u0430 \u0458\u0435 \u0432\u0430\u0448 Ledger \u0431\u0435\u0437\u0431\u0435\u0434\u043D\u043E \u043F\u043E\u0432\u0435\u0437\u0430\u043D \u0438 \u0434\u0430 \u0458\u0435 \u0430\u043F\u043B\u0438\u043A\u0430\u0446\u0438\u0458\u0430 NEAR \u043E\u0442\u0432\u043E\u0440\u0435\u043D\u0430 \u043D\u0430 \u0432\u0430\u0448\u0435\u043C \u0443\u0440\u0435\u0452\u0430\u0458\u0443",
      "continue": "\u041D\u0430\u0441\u0442\u0430\u0432\u0438",
      specifyHDPath: "\u041D\u0430\u0432\u0435\u0434\u0438\u0442\u0435 \u0425\u0414 \u043F\u0443\u0442\u0430\u045A\u0443",
      enterYourPreferredHDPath: "\u0423\u043D\u0435\u0441\u0438\u0442\u0435 \u0436\u0435\u0459\u0435\u043D\u0443 \u0436\u0435\u0459\u0435\u043D\u0443 \u0425\u0414 \u043F\u0443\u0442\u0430\u045A\u0443, \u0430 \u0437\u0430\u0442\u0438\u043C \u0441\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435 \u0441\u0432\u0435 \u0430\u043A\u0442\u0438\u0432\u043D\u0435 \u043D\u0430\u043B\u043E\u0433\u0435.",
      scan: "\u0421\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435",
      retry: "\u041F\u043E\u043A\u0443\u0448\u0430\u0458 \u043F\u043E\u043D\u043E\u0432\u043E",
      ledgerIsNotAvailable: "Ledger \u043D\u0438\u0458\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u0430\u043D.",
      accessDeniedToUseLedgerDevice: "\u041F\u0440\u0438\u0441\u0442\u0443\u043F \u0458\u0435 \u043E\u0434\u0431\u0438\u0458\u0435\u043D \u0437\u0430 \u043A\u043E\u0440\u0438\u0448\u045B\u0435\u045A\u0435 Ledger \u0443\u0440\u0435\u0452\u0430\u0458\u0430",
      noAccountsFound: "\u041D\u0430l\u043E\u0437\u0438 \u043D\u0438\u0441\u0443 \u043F\u0440\u043E\u043D\u0430\u0452\u0435\u043D\u0438",
      selectYourAccounts: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u0412\u0430\u0448 \u043D\u0430l\u043E\u0433",
      connecting1Account: "\u041F\u043E\u0432\u0435\u0437\u0430\u0442\u0438 1 \u043D\u0430l\u043E\u0433",
      cantFindAnyAccount: "\u041D\u0438\u0458\u0435 \u043C\u043E\u0433\u0443\u045B\u0435 \u043F\u0440\u043E\u043D\u0430\u045B\u0438 \u043D\u0438\u0458\u0435\u0434\u0430\u043D \u043D\u0430l\u043E\u0433 \u043F\u043E\u0432\u0435\u0437\u0430\u043D \u0441\u0430 \u043E\u0432\u0438\u043C Ledger-\u043E\u043C. \u041D\u0430\u043F\u0440\u0430\u0432\u0438\u0442\u0435 \u043D\u043E\u0432\u0438 NEAR \u043D\u0430l\u043E\u0433",
      orConnectAnAnotherLedger: "\u0438\u043B\u0438 \u043F\u043E\u0432\u0435\u0436\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u0438 Ledger.",
      connecting: "\u041F\u043E\u0432\u0435\u0437\u0438\u0432\u0430\u045A\u0435",
      ofAccounts: "\u043D\u0430l\u043E\u0433\u0430",
      failedToAutomatically: "\u0410\u0443\u0442\u043E\u043C\u0430\u0442\u0441\u043A\u043E \u043F\u0440\u043E\u043D\u0430\u043B\u0430\u0436\u0435\u045A\u0435 ID-a \u043D\u0430l\u043E\u0433\u0430 \u043D\u0438\u0458\u0435 \u0443\u0441\u043F\u0435\u043B\u043E. \u041D\u0430\u0432\u0435\u0434\u0438\u0442\u0435 \u0433\u0430 \u0440\u0443\u0447\u043D\u043E:",
      overviewTheListOfAuthorized: "\u041F\u0440\u0435\u0433\u043B\u0435\u0434\u0430\u0458\u0442\u0435 \u043B\u0438\u0441\u0442\u0443 \u043E\u0432\u043B\u0430\u0448\u045B\u0435\u043D\u0438\u0445 \u0440\u0430\u0447\u0443\u043D\u0430, \u0437\u0430\u0432\u0440\u0448\u0438\u0442\u0435 \u043F\u0440\u0438\u0458\u0430\u0432\u0443 \u043A\u043B\u0438\u043A\u043E\u043C \u043D\u0430 \u0434\u0443\u0433\u043C\u0435 \u0438\u0441\u043F\u043E\u0434.",
      finish: "\u0417\u0430\u0432\u0440\u0448\u0438"
    },
    install: {
      youllNeedToInstall: "\u041C\u043E\u0440\u0430\u045B\u0435\u0442\u0435 \u0434\u0430 \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u0442\u0435",
      toContinueAfterInstalling: "\u0437\u0430 \u043D\u0430\u0441\u0442\u0430\u0432\u0430\u043A. \u041D\u0430\u043A\u043E\u043D \u0438\u043D\u0441\u0442\u0430\u043B\u0438\u0440\u0430\u045A\u0430",
      refreshThePage: "\u043F\u043E\u043D\u043E\u0432\u043E \u0443\u0447\u0438\u0442\u0430\u0442\u0438 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443.",
      open: "\u041E\u0442\u0432\u043E\u0440\u0438"
    },
    qr: {
      copiedToClipboard: "\u041A\u043E\u043F\u0438\u0440\u0430\u043D\u043E \u0443 \u043C\u0435\u0452\u0443\u0441\u043F\u0440\u0435\u043C\u043D\u0438\u043A",
      failedToCopy: "\u041A\u043E\u043F\u0438\u0440\u0430\u045A\u0435 \u0443 \u043C\u0435\u0452\u0443\u0441\u043F\u0440\u0435\u043C\u043D\u0438\u043A \u043D\u0438\u0458\u0435 \u0443\u0441\u043F\u0435\u043B\u043E",
      scanWithYourMobile: "\u0421\u043A\u0435\u043D\u0438\u0440\u0430\u0458\u0442\u0435 \u043F\u043E\u043C\u043E\u045B\u0443 \u043C\u043E\u0431\u0438\u043B\u043D\u043E\u0433 \u0443\u0440\u0435\u0452\u0430\u0458\u0430",
      copyToClipboard: " \u041A\u043E\u043F\u0438\u0440\u0430\u0458 \u0443 \u043C\u0435\u0452\u0443\u0441\u043F\u0440\u0435\u043C\u043D\u0438\u043A",
      preferTheOfficial: "\u041F\u0440\u0435\u0444\u0435\u0440\u0438\u0440\u0430\u0442\u0435 \u0437\u0432\u0430\u043D\u0438\u0447\u043D\u0438 \u0434\u0438\u0458\u0430\u043B\u043E\u0433 \u043E\u0434",
      open: "\u041E\u0442\u0432\u043E\u0440\u0438"
    },
    walletTypes: {
      hardware: "\u0425\u0430\u0440\u0434\u0432\u0435\u0440\u0441\u043A\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      browser: "\u041D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043F\u0440\u0435\u0442\u0440\u0430\u0436\u0438\u0432\u0430\u0447\u0430,",
      injected: "\u0414\u043E\u0434\u0430\u0442\u0430\u043A \u0437\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A,",
      bridge: "Bridge \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      mobile: "\u041C\u043E\u0431\u0438\u043B\u043D\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      "instant-link": "\u0418\u043D\u0441\u0442\u0430\u043D\u0442 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A"
    },
    exportAccounts: {
      chooseAWallet: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
      transferYourAccounts: "\u041F\u0440\u0435\u043D\u0435\u0441\u0438\u0442\u0435 \u0441\u0432\u043E\u0458\u0435 \u043D\u0430\u043B\u043E\u0433\u0435",
      selectAWallet: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043A\u043E\u0458\u0438 \u043E\u0434\u0433\u043E\u0432\u0430\u0440\u0430 \u0432\u0430\u0448\u0438\u043C \u043F\u043E\u0442\u0440\u0435\u0431\u0430\u043C\u0430 \u0438 \u043A\u043E\u0458\u0438 \u043F\u043E\u0434\u0440\u0436\u0430\u0432\u0430 \u0432\u0430\u0448\u0435 \u043F\u043E\u0432\u0435\u0437\u0430\u043D\u0435 \u043D\u0430\u043B\u043E\u0433\u0435.",
      selectYourAccounts: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0430\u0448\u0435 \u043D\u0430\u043B\u043E\u0433\u0435",
      afterDecide: "\u041D\u0430\u043A\u043E\u043D \u0448\u0442\u043E \u0441\u0435 \u043E\u0434\u043B\u0443\u0447\u0438\u0442\u0435 \u0437\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A, \u043C\u043E\u0436\u0435\u0442\u0435 \u0438\u0437\u0430\u0431\u0440\u0430\u0442\u0438 \u043A\u043E\u0458\u0435 \u043D\u0430\u043B\u043E\u0433\u0435 \u0436\u0435\u043B\u0438\u0442\u0435 \u0434\u0430 \u043F\u0440\u0435\u043D\u0435\u0441\u0435\u0442\u0435.",
      disclaimer: "\u041D\u0435\u045B\u0435\u0442\u0435 \u043C\u043E\u045B\u0438 \u0434\u0430 \u043F\u0440\u0435\u043D\u0435\u0441\u0435\u0442\u0435 \u043D\u0430\u043B\u043E\u0433\u0435 \u043A\u043E\u0458\u0438 \u043D\u0438\u043A\u0430\u0434\u0430 \u043D\u0438\u0441\u0443 \u0431\u0438\u043B\u0438 \u0444\u0438\u043D\u0430\u043D\u0441\u0438\u0440\u0430\u043D\u0438 \u0438\u043B\u0438 \u043A\u043E\u0440\u0438\u0448\u045B\u0435\u043D\u0438 \u043D\u0430  NEAR.",
      warning: "\u0442\u0440\u0435\u043D\u0443\u0442\u043D\u043E \u043D\u0435 \u043F\u043E\u0434\u0440\u0436\u0430\u0432\u0430 \u0438\u0437\u0432\u043E\u0437 \u043D\u0430\u043B\u043E\u0433\u0430. \u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A.",
      walletTypes: {
        hardware: "\u0425\u0430\u0440\u0434\u0432\u0435\u0440\u0441\u043A\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        browser: "\u041D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043F\u0440\u0435\u0442\u0440\u0430\u0436\u0438\u0432\u0430\u0447\u0430,",
        injected: "\u0414\u043E\u0434\u0430\u0442\u0430\u043A \u0437\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A,",
        bridge: "Bridge \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A",
        mobile: "\u041C\u043E\u0431\u0438\u043B\u043D\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A"
      },
      selectAccounts: {
        title: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u043D\u0430\u043B\u043E\u0433\u0435 \u0437\u0430 \u043F\u0440\u0435\u043D\u043E\u0441.",
        button: "\u0414\u043E\u0431\u0438\u0458\u0442\u0435 \u043F\u0440\u0438\u0441\u0442\u0443\u043F\u043D\u0443 \u0444\u0440\u0430\u0437\u0443",
        deselectAll: "\u041F\u043E\u043D\u0438\u0448\u0442\u0438\u0442\u0435 \u0438\u0437\u0431\u043E\u0440",
        selectAll: "\u0418\u0437\u0430\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0432\u0435",
        unavailable: "\u0422\u0440\u0430\u043D\u0441\u0444\u0435\u0440 \u043D\u0438\u0458\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u0430\u043D",
        error: "\u041D\u0430\u043B\u043E\u0433 \u043D\u0435 \u043F\u043E\u0441\u0442\u043E\u0458\u0438",
        warningLedger: "\u041F\u043E\u0442\u0440\u0435\u0431\u043D\u0430 \u043F\u043E\u0434\u0440\u0448\u043A\u0430 \u0437\u0430 Ledger",
        noBalance: "\u041D\u0430\u043B\u043E\u0433 \u043D\u0438\u0458\u0435 \u0444\u0438\u043D\u0430\u043D\u0441\u0438\u0440\u0430\u043D"
      },
      getPassphrase: {
        title: "\u041A\u043E\u043F\u0438\u0440\u0430\u0458 \u043F\u0440\u0438\u0432\u0440\u0435\u043C\u0435\u043D\u0443 \u043B\u043E\u0437\u0438\u043D\u043A\u0443",
        desc: "\u041C\u043E\u0440\u0430\u045B\u0435\u0442\u0435 \u0434\u0430 \u0443\u043D\u0435\u0441\u0435\u0442\u0435 \u043E\u0432\u0443 \u043B\u043E\u0437\u0438\u043D\u043A\u0443 \u043A\u0430\u0434\u0430 \u043F\u043E\u0447\u043D\u0435\u0442\u0435 \u0434\u0430 \u0438\u0437\u0432\u043E\u0437\u0438\u0442\u0435 \u0441\u0432\u043E\u0458\u0435 \u043D\u0430\u043B\u043E\u0433\u0435 \u0443 \u0434\u0440\u0443\u0433\u0438 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A.",
        button: "\u041D\u0430\u0441\u0442\u0430\u0432\u0438\u0442\u0435",
        label: "\u041A\u043B\u0438\u043A\u043D\u0438\u0442\u0435 \u0434\u0430 \u0431\u0438\u0441\u0442\u0435 \u043A\u043E\u043F\u0438\u0440\u0430\u043B\u0438",
        checkLabel: "\u041A\u043E\u043F\u0438\u0440\u0430\u043E \u0441\u0430\u043C \u0438\u043B\u0438 \u0437\u0430\u043F\u0438\u0441\u0430\u043E \u043B\u043E\u0437\u0438\u043D\u043A\u0443"
      },
      complete: {
        title: "\u0414\u043E\u0432\u0440\u0448\u0438\u0442\u0435 \u0442\u0440\u0430\u043D\u0441\u0444\u0435\u0440",
        descOne: "\u0421\u0430\u0434\u0430 \u045B\u0435\u0442\u0435 \u0431\u0438\u0442\u0438 \u043F\u0440\u0435\u0443\u0441\u043C\u0435\u0440\u0435\u043D\u0438 \u043D\u0430 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A \u043A\u043E\u0458\u0438 \u0441\u0442\u0435 \u0438\u0437\u0430\u0431\u0440\u0430\u043B\u0438 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0438\u0442\u0435 \u0442\u0440\u0430\u043D\u0441\u0444\u0435\u0440.",
        descTwo: "\u041A\u0430\u0434\u0430 \u0441\u0435 \u0434\u0435\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0430 \u0443\u0432\u043E\u0437\u0430 \u0437\u0430\u0432\u0440\u0448\u0438 \u0438\u0437 \u0438\u0437\u0430\u0431\u0440\u0430\u043D\u043E\u0433 \u043D\u043E\u0432\u0447\u0430\u043D\u0438\u043A\u0430, \u043F\u0440\u0438\u0442\u0438\u0441\u043D\u0438\u0442\u0435 \u0434\u0443\u0433\u043C\u0435 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0438\u0442\u0435 \u043F\u0440\u043E\u0446\u0435\u0441 \u043F\u0440\u0435\u043D\u043E\u0441\u0430.",
        button: "\u0417\u0430\u0432\u0440\u0448\u0438\u0442\u0435"
      }
    }
  };
  var sr = {
    modal
  };
  var getLanguage = (languageCode) => {
    switch (languageCode) {
      case "en":
        return en;
      case "es":
        return es;
      case "zh":
        return zh;
      case "bg":
        return bg;
      case "ko":
        return ko;
      case "vi":
        return vi;
      case "hi":
        return hi;
      case "ar":
        return ar;
      case "hr":
        return hr;
      case "mk":
        return mk;
      case "sl":
        return sl;
      case "sr":
        return sr;
      default:
        return en;
    }
  };
  var chosenLang;
  var allowOnlyLanguage = (langCode) => {
    chosenLang = langCode;
  };
  var shortenLanguageCode = (lang) => {
    return lang.indexOf("-") !== -1 ? lang.split("-")[0] : lang.split("_")[0];
  };
  var findObjectPropByStringPath = (obj, prop) => {
    if (!obj) {
      return "";
    }
    const _index = prop.indexOf(".");
    if (_index > -1) {
      const currentProp = prop.substring(0, _index);
      const nextProp = prop.substring(_index + 1);
      return findObjectPropByStringPath(obj[currentProp], nextProp);
    }
    return obj[prop];
  };
  var translate = (path7) => {
    let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;
    browserLang = browserLang || window.navigator.language;
    const languageCode = shortenLanguageCode(chosenLang || browserLang);
    const selectedLanguage = getLanguage(languageCode);
    const text = findObjectPropByStringPath(selectedLanguage, path7);
    return text && typeof text === "string" ? text : path7;
  };

  // node_modules/@near-wallet-selector/modal-ui/index.js
  init_process();
  init_buffer();
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var import_client = __toESM(require_client(), 1);
  var import_react = __toESM(require_react(), 1);
  var import_qrcode = __toESM(require_browser5(), 1);
  var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);
  function __awaiter2(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject5) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject5(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject5(e);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var fails$c2 = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var toString6 = {}.toString;
  var classofRaw$12 = function(it) {
    return toString6.call(it).slice(8, -1);
  };
  var fails$b2 = fails$c2;
  var classof$62 = classofRaw$12;
  var split2 = "".split;
  var indexedObject2 = fails$b2(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$62(it) == "String" ? split2.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$32 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject$22 = indexedObject2;
  var requireObjectCoercible$22 = requireObjectCoercible$32;
  var toIndexedObject$42 = function(it) {
    return IndexedObject$22(requireObjectCoercible$22(it));
  };
  var check2 = function(it) {
    return it && it.Math == Math && it;
  };
  var global$j2 = (
    // eslint-disable-next-line no-undef
    check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || check2(typeof self == "object" && self) || check2(typeof commonjsGlobal2 == "object" && commonjsGlobal2) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var shared$22 = { exports: {} };
  var fails$a2 = fails$c2;
  var descriptors2 = !fails$a2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectDefineProperty2 = {};
  var isObject$92 = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var global$i2 = global$j2;
  var isObject$82 = isObject$92;
  var document$22 = global$i2.document;
  var EXISTS2 = isObject$82(document$22) && isObject$82(document$22.createElement);
  var documentCreateElement$12 = function(it) {
    return EXISTS2 ? document$22.createElement(it) : {};
  };
  var DESCRIPTORS$82 = descriptors2;
  var fails$92 = fails$c2;
  var createElement$12 = documentCreateElement$12;
  var ie8DomDefine2 = !DESCRIPTORS$82 && !fails$92(function() {
    return Object.defineProperty(createElement$12("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var isObject$72 = isObject$92;
  var anObject$b2 = function(it) {
    if (!isObject$72(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var isObject$62 = isObject$92;
  var toPrimitive$22 = function(input, PREFERRED_STRING) {
    if (!isObject$62(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$62(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$62(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$62(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var DESCRIPTORS$72 = descriptors2;
  var IE8_DOM_DEFINE$12 = ie8DomDefine2;
  var anObject$a2 = anObject$b2;
  var toPrimitive$12 = toPrimitive$22;
  var nativeDefineProperty2 = Object.defineProperty;
  objectDefineProperty2.f = DESCRIPTORS$72 ? nativeDefineProperty2 : function defineProperty4(O, P, Attributes) {
    anObject$a2(O);
    P = toPrimitive$12(P, true);
    anObject$a2(Attributes);
    if (IE8_DOM_DEFINE$12) try {
      return nativeDefineProperty2(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var createPropertyDescriptor$32 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var DESCRIPTORS$62 = descriptors2;
  var definePropertyModule$42 = objectDefineProperty2;
  var createPropertyDescriptor$22 = createPropertyDescriptor$32;
  var createNonEnumerableProperty$72 = DESCRIPTORS$62 ? function(object, key, value) {
    return definePropertyModule$42.f(object, key, createPropertyDescriptor$22(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var global$h2 = global$j2;
  var createNonEnumerableProperty$62 = createNonEnumerableProperty$72;
  var setGlobal$32 = function(key, value) {
    try {
      createNonEnumerableProperty$62(global$h2, key, value);
    } catch (error2) {
      global$h2[key] = value;
    }
    return value;
  };
  var global$g2 = global$j2;
  var setGlobal$22 = setGlobal$32;
  var SHARED2 = "__core-js_shared__";
  var store$32 = global$g2[SHARED2] || setGlobal$22(SHARED2, {});
  var sharedStore2 = store$32;
  var store$22 = sharedStore2;
  (shared$22.exports = function(key, value) {
    return store$22[key] || (store$22[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var hasOwnProperty4 = {}.hasOwnProperty;
  var has$b2 = function(it, key) {
    return hasOwnProperty4.call(it, key);
  };
  var id2 = 0;
  var postfix2 = Math.random();
  var uid$22 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id2 + postfix2).toString(36);
  };
  var fails$82 = fails$c2;
  var nativeSymbol2 = !!Object.getOwnPropertySymbols && !fails$82(function() {
    return !String(Symbol());
  });
  var NATIVE_SYMBOL$12 = nativeSymbol2;
  var useSymbolAsUid2 = NATIVE_SYMBOL$12 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var global$f2 = global$j2;
  var shared$12 = shared$22.exports;
  var has$a2 = has$b2;
  var uid$12 = uid$22;
  var NATIVE_SYMBOL2 = nativeSymbol2;
  var USE_SYMBOL_AS_UID2 = useSymbolAsUid2;
  var WellKnownSymbolsStore2 = shared$12("wks");
  var Symbol$12 = global$f2.Symbol;
  var createWellKnownSymbol2 = USE_SYMBOL_AS_UID2 ? Symbol$12 : Symbol$12 && Symbol$12.withoutSetter || uid$12;
  var wellKnownSymbol$f2 = function(name) {
    if (!has$a2(WellKnownSymbolsStore2, name)) {
      if (NATIVE_SYMBOL2 && has$a2(Symbol$12, name)) WellKnownSymbolsStore2[name] = Symbol$12[name];
      else WellKnownSymbolsStore2[name] = createWellKnownSymbol2("Symbol." + name);
    }
    return WellKnownSymbolsStore2[name];
  };
  var ceil2 = Math.ceil;
  var floor3 = Math.floor;
  var toInteger$22 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor3 : ceil2)(argument);
  };
  var toInteger$12 = toInteger$22;
  var min$12 = Math.min;
  var toLength$32 = function(argument) {
    return argument > 0 ? min$12(toInteger$12(argument), 9007199254740991) : 0;
  };
  var toInteger2 = toInteger$22;
  var max2 = Math.max;
  var min2 = Math.min;
  var toAbsoluteIndex$12 = function(index, length) {
    var integer = toInteger2(index);
    return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
  };
  var toIndexedObject$32 = toIndexedObject$42;
  var toLength$22 = toLength$32;
  var toAbsoluteIndex2 = toAbsoluteIndex$12;
  var createMethod$12 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$32($this);
      var length = toLength$22(O.length);
      var index = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes2 = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod$12(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$12(false)
  };
  var hiddenKeys$42 = {};
  var has$92 = has$b2;
  var toIndexedObject$22 = toIndexedObject$42;
  var indexOf5 = arrayIncludes2.indexOf;
  var hiddenKeys$32 = hiddenKeys$42;
  var objectKeysInternal2 = function(object, names) {
    var O = toIndexedObject$22(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$92(hiddenKeys$32, key) && has$92(O, key) && result.push(key);
    while (names.length > i) if (has$92(O, key = names[i++])) {
      ~indexOf5(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$32 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$12 = objectKeysInternal2;
  var enumBugKeys$22 = enumBugKeys$32;
  var objectKeys$22 = Object.keys || function keys3(O) {
    return internalObjectKeys$12(O, enumBugKeys$22);
  };
  var DESCRIPTORS$52 = descriptors2;
  var definePropertyModule$32 = objectDefineProperty2;
  var anObject$92 = anObject$b2;
  var objectKeys$12 = objectKeys$22;
  var objectDefineProperties2 = DESCRIPTORS$52 ? Object.defineProperties : function defineProperties3(O, Properties) {
    anObject$92(O);
    var keys14 = objectKeys$12(Properties);
    var length = keys14.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$32.f(O, key = keys14[index++], Properties[key]);
    return O;
  };
  var global$e2 = global$j2;
  var path$12 = global$e2;
  var path2 = path$12;
  var global$d2 = global$j2;
  var aFunction$7 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$52 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction$7(path2[namespace]) || aFunction$7(global$d2[namespace]) : path2[namespace] && path2[namespace][method2] || global$d2[namespace] && global$d2[namespace][method2];
  };
  var getBuiltIn$42 = getBuiltIn$52;
  var html$22 = getBuiltIn$42("document", "documentElement");
  var shared2 = shared$22.exports;
  var uid2 = uid$22;
  var keys4 = shared2("keys");
  var sharedKey$32 = function(key) {
    return keys4[key] || (keys4[key] = uid2(key));
  };
  var anObject$82 = anObject$b2;
  var defineProperties4 = objectDefineProperties2;
  var enumBugKeys$12 = enumBugKeys$32;
  var hiddenKeys$22 = hiddenKeys$42;
  var html$12 = html$22;
  var documentCreateElement2 = documentCreateElement$12;
  var sharedKey$22 = sharedKey$32;
  var GT2 = ">";
  var LT2 = "<";
  var PROTOTYPE2 = "prototype";
  var SCRIPT2 = "script";
  var IE_PROTO$12 = sharedKey$22("IE_PROTO");
  var EmptyConstructor2 = function() {
  };
  var scriptTag2 = function(content) {
    return LT2 + SCRIPT2 + GT2 + content + LT2 + "/" + SCRIPT2 + GT2;
  };
  var NullProtoObjectViaActiveX2 = function(activeXDocument5) {
    activeXDocument5.write(scriptTag2(""));
    activeXDocument5.close();
    var temp = activeXDocument5.parentWindow.Object;
    activeXDocument5 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame2 = function() {
    var iframe = documentCreateElement2("iframe");
    var JS = "java" + SCRIPT2 + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html$12.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag2("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument2;
  var NullProtoObject2 = function() {
    try {
      activeXDocument2 = document.domain && new ActiveXObject("htmlfile");
    } catch (error2) {
    }
    NullProtoObject2 = activeXDocument2 ? NullProtoObjectViaActiveX2(activeXDocument2) : NullProtoObjectViaIFrame2();
    var length = enumBugKeys$12.length;
    while (length--) delete NullProtoObject2[PROTOTYPE2][enumBugKeys$12[length]];
    return NullProtoObject2();
  };
  hiddenKeys$22[IE_PROTO$12] = true;
  var objectCreate2 = Object.create || function create3(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor2[PROTOTYPE2] = anObject$82(O);
      result = new EmptyConstructor2();
      EmptyConstructor2[PROTOTYPE2] = null;
      result[IE_PROTO$12] = O;
    } else result = NullProtoObject2();
    return Properties === void 0 ? result : defineProperties4(result, Properties);
  };
  var wellKnownSymbol$e2 = wellKnownSymbol$f2;
  var create$12 = objectCreate2;
  var definePropertyModule$22 = objectDefineProperty2;
  var UNSCOPABLES2 = wellKnownSymbol$e2("unscopables");
  var ArrayPrototype$12 = Array.prototype;
  if (ArrayPrototype$12[UNSCOPABLES2] == void 0) {
    definePropertyModule$22.f(ArrayPrototype$12, UNSCOPABLES2, {
      configurable: true,
      value: create$12(null)
    });
  }
  var addToUnscopables$22 = function(key) {
    ArrayPrototype$12[UNSCOPABLES2][key] = true;
  };
  var iterators2 = {};
  var store$12 = sharedStore2;
  var functionToString2 = Function.toString;
  if (typeof store$12.inspectSource != "function") {
    store$12.inspectSource = function(it) {
      return functionToString2.call(it);
    };
  }
  var inspectSource$32 = store$12.inspectSource;
  var global$c2 = global$j2;
  var inspectSource$22 = inspectSource$32;
  var WeakMap$12 = global$c2.WeakMap;
  var nativeWeakMap2 = typeof WeakMap$12 === "function" && /native code/.test(inspectSource$22(WeakMap$12));
  var NATIVE_WEAK_MAP2 = nativeWeakMap2;
  var global$b2 = global$j2;
  var isObject$52 = isObject$92;
  var createNonEnumerableProperty$52 = createNonEnumerableProperty$72;
  var objectHas2 = has$b2;
  var sharedKey$12 = sharedKey$32;
  var hiddenKeys$12 = hiddenKeys$42;
  var WeakMap3 = global$b2.WeakMap;
  var set$12;
  var get4;
  var has$82;
  var enforce2 = function(it) {
    return has$82(it) ? get4(it) : set$12(it, {});
  };
  var getterFor2 = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$52(it) || (state = get4(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP2) {
    store = new WeakMap3();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set$12 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get4 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$82 = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey$12("state");
    hiddenKeys$12[STATE] = true;
    set$12 = function(it, metadata) {
      createNonEnumerableProperty$52(it, STATE, metadata);
      return metadata;
    };
    get4 = function(it) {
      return objectHas2(it, STATE) ? it[STATE] : {};
    };
    has$82 = function(it) {
      return objectHas2(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState2 = {
    set: set$12,
    get: get4,
    has: has$82,
    enforce: enforce2,
    getterFor: getterFor2
  };
  var objectGetOwnPropertyDescriptor2 = {};
  var objectPropertyIsEnumerable2 = {};
  var nativePropertyIsEnumerable2 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$22 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG2 = getOwnPropertyDescriptor$22 && !nativePropertyIsEnumerable2.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable2.f = NASHORN_BUG2 ? function propertyIsEnumerable2(V) {
    var descriptor = getOwnPropertyDescriptor$22(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable2;
  var DESCRIPTORS$42 = descriptors2;
  var propertyIsEnumerableModule$12 = objectPropertyIsEnumerable2;
  var createPropertyDescriptor$12 = createPropertyDescriptor$32;
  var toIndexedObject$12 = toIndexedObject$42;
  var toPrimitive2 = toPrimitive$22;
  var has$72 = has$b2;
  var IE8_DOM_DEFINE2 = ie8DomDefine2;
  var nativeGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor2.f = DESCRIPTORS$42 ? nativeGetOwnPropertyDescriptor2 : function getOwnPropertyDescriptor4(O, P) {
    O = toIndexedObject$12(O);
    P = toPrimitive2(P, true);
    if (IE8_DOM_DEFINE2) try {
      return nativeGetOwnPropertyDescriptor2(O, P);
    } catch (error2) {
    }
    if (has$72(O, P)) return createPropertyDescriptor$12(!propertyIsEnumerableModule$12.f.call(O, P), O[P]);
  };
  var redefine$52 = { exports: {} };
  var global$a2 = global$j2;
  var createNonEnumerableProperty$42 = createNonEnumerableProperty$72;
  var has$62 = has$b2;
  var setGlobal$12 = setGlobal$32;
  var inspectSource$12 = inspectSource$32;
  var InternalStateModule$22 = internalState2;
  var getInternalState$22 = InternalStateModule$22.get;
  var enforceInternalState2 = InternalStateModule$22.enforce;
  var TEMPLATE2 = String(String).split("String");
  (redefine$52.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$62(value, "name")) createNonEnumerableProperty$42(value, "name", key);
      enforceInternalState2(value).source = TEMPLATE2.join(typeof key == "string" ? key : "");
    }
    if (O === global$a2) {
      if (simple) O[key] = value;
      else setGlobal$12(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$42(O, key, value);
  })(Function.prototype, "toString", function toString7() {
    return typeof this == "function" && getInternalState$22(this).source || inspectSource$12(this);
  });
  var objectGetOwnPropertyNames2 = {};
  var internalObjectKeys2 = objectKeysInternal2;
  var enumBugKeys2 = enumBugKeys$32;
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames2.f = Object.getOwnPropertyNames || function getOwnPropertyNames3(O) {
    return internalObjectKeys2(O, hiddenKeys2);
  };
  var objectGetOwnPropertySymbols2 = {};
  objectGetOwnPropertySymbols2.f = Object.getOwnPropertySymbols;
  var getBuiltIn$32 = getBuiltIn$52;
  var getOwnPropertyNamesModule2 = objectGetOwnPropertyNames2;
  var getOwnPropertySymbolsModule$12 = objectGetOwnPropertySymbols2;
  var anObject$72 = anObject$b2;
  var ownKeys$12 = getBuiltIn$32("Reflect", "ownKeys") || function ownKeys3(it) {
    var keys14 = getOwnPropertyNamesModule2.f(anObject$72(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$12.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has$52 = has$b2;
  var ownKeys4 = ownKeys$12;
  var getOwnPropertyDescriptorModule2 = objectGetOwnPropertyDescriptor2;
  var definePropertyModule$12 = objectDefineProperty2;
  var copyConstructorProperties$2 = function(target, source) {
    var keys14 = ownKeys4(source);
    var defineProperty14 = definePropertyModule$12.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule2.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has$52(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$72 = fails$c2;
  var replacement2 = /#|\.prototype\./;
  var isForced$22 = function(feature, detection) {
    var value = data2[normalize2(feature)];
    return value == POLYFILL2 ? true : value == NATIVE2 ? false : typeof detection == "function" ? fails$72(detection) : !!detection;
  };
  var normalize2 = isForced$22.normalize = function(string) {
    return String(string).replace(replacement2, ".").toLowerCase();
  };
  var data2 = isForced$22.data = {};
  var NATIVE2 = isForced$22.NATIVE = "N";
  var POLYFILL2 = isForced$22.POLYFILL = "P";
  var isForced_12 = isForced$22;
  var global$92 = global$j2;
  var getOwnPropertyDescriptor$12 = objectGetOwnPropertyDescriptor2.f;
  var createNonEnumerableProperty$32 = createNonEnumerableProperty$72;
  var redefine$42 = redefine$52.exports;
  var setGlobal2 = setGlobal$32;
  var copyConstructorProperties$12 = copyConstructorProperties$2;
  var isForced$12 = isForced_12;
  var _export2 = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$92;
    } else if (STATIC) {
      target = global$92[TARGET] || setGlobal2(TARGET, {});
    } else {
      target = (global$92[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$12(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced$12(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties$12(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$32(sourceProperty, "sham", true);
      }
      redefine$42(target, key, sourceProperty, options);
    }
  };
  var requireObjectCoercible$12 = requireObjectCoercible$32;
  var toObject$42 = function(argument) {
    return Object(requireObjectCoercible$12(argument));
  };
  var fails$62 = fails$c2;
  var correctPrototypeGetter2 = !fails$62(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  var has$42 = has$b2;
  var toObject$32 = toObject$42;
  var sharedKey2 = sharedKey$32;
  var CORRECT_PROTOTYPE_GETTER2 = correctPrototypeGetter2;
  var IE_PROTO2 = sharedKey2("IE_PROTO");
  var ObjectPrototype2 = Object.prototype;
  var objectGetPrototypeOf2 = CORRECT_PROTOTYPE_GETTER2 ? Object.getPrototypeOf : function(O) {
    O = toObject$32(O);
    if (has$42(O, IE_PROTO2)) return O[IE_PROTO2];
    if (typeof O.constructor == "function" && O instanceof O.constructor) {
      return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectPrototype2 : null;
  };
  var getPrototypeOf$12 = objectGetPrototypeOf2;
  var createNonEnumerableProperty$22 = createNonEnumerableProperty$72;
  var has$32 = has$b2;
  var wellKnownSymbol$d2 = wellKnownSymbol$f2;
  var ITERATOR$52 = wellKnownSymbol$d2("iterator");
  var BUGGY_SAFARI_ITERATORS$12 = false;
  var returnThis$22 = function() {
    return this;
  };
  var IteratorPrototype$22;
  var PrototypeOfArrayIteratorPrototype2;
  var arrayIterator2;
  if ([].keys) {
    arrayIterator2 = [].keys();
    if (!("next" in arrayIterator2)) BUGGY_SAFARI_ITERATORS$12 = true;
    else {
      PrototypeOfArrayIteratorPrototype2 = getPrototypeOf$12(getPrototypeOf$12(arrayIterator2));
      if (PrototypeOfArrayIteratorPrototype2 !== Object.prototype) IteratorPrototype$22 = PrototypeOfArrayIteratorPrototype2;
    }
  }
  if (IteratorPrototype$22 == void 0) IteratorPrototype$22 = {};
  if (!has$32(IteratorPrototype$22, ITERATOR$52)) {
    createNonEnumerableProperty$22(IteratorPrototype$22, ITERATOR$52, returnThis$22);
  }
  var iteratorsCore2 = {
    IteratorPrototype: IteratorPrototype$22,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$12
  };
  var defineProperty$32 = objectDefineProperty2.f;
  var has$22 = has$b2;
  var wellKnownSymbol$c2 = wellKnownSymbol$f2;
  var TO_STRING_TAG$32 = wellKnownSymbol$c2("toStringTag");
  var setToStringTag$32 = function(it, TAG, STATIC) {
    if (it && !has$22(it = STATIC ? it : it.prototype, TO_STRING_TAG$32)) {
      defineProperty$32(it, TO_STRING_TAG$32, { configurable: true, value: TAG });
    }
  };
  var IteratorPrototype$12 = iteratorsCore2.IteratorPrototype;
  var create4 = objectCreate2;
  var createPropertyDescriptor2 = createPropertyDescriptor$32;
  var setToStringTag$22 = setToStringTag$32;
  var Iterators$42 = iterators2;
  var returnThis$12 = function() {
    return this;
  };
  var createIteratorConstructor$12 = function(IteratorConstructor, NAME2, next3) {
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    IteratorConstructor.prototype = create4(IteratorPrototype$12, { next: createPropertyDescriptor2(1, next3) });
    setToStringTag$22(IteratorConstructor, TO_STRING_TAG5, false);
    Iterators$42[TO_STRING_TAG5] = returnThis$12;
    return IteratorConstructor;
  };
  var isObject$42 = isObject$92;
  var aPossiblePrototype$12 = function(it) {
    if (!isObject$42(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + " as a prototype");
    }
    return it;
  };
  var anObject$62 = anObject$b2;
  var aPossiblePrototype2 = aPossiblePrototype$12;
  var objectSetPrototypeOf2 = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test5 = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
      setter.call(test5, []);
      CORRECT_SETTER = test5 instanceof Array;
    } catch (error2) {
    }
    return function setPrototypeOf5(O, proto) {
      anObject$62(O);
      aPossiblePrototype2(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  })() : void 0);
  var $$72 = _export2;
  var createIteratorConstructor2 = createIteratorConstructor$12;
  var getPrototypeOf2 = objectGetPrototypeOf2;
  var setPrototypeOf2 = objectSetPrototypeOf2;
  var setToStringTag$12 = setToStringTag$32;
  var createNonEnumerableProperty$12 = createNonEnumerableProperty$72;
  var redefine$32 = redefine$52.exports;
  var wellKnownSymbol$b2 = wellKnownSymbol$f2;
  var Iterators$32 = iterators2;
  var IteratorsCore2 = iteratorsCore2;
  var IteratorPrototype2 = IteratorsCore2.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS2 = IteratorsCore2.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$42 = wellKnownSymbol$b2("iterator");
  var KEYS2 = "keys";
  var VALUES2 = "values";
  var ENTRIES2 = "entries";
  var returnThis2 = function() {
    return this;
  };
  var defineIterator$12 = function(Iterable, NAME2, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED5) {
    createIteratorConstructor2(IteratorConstructor, NAME2, next3);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS2 && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS2:
          return function keys14() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES2:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES2:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$42] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS2 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
      if (IteratorPrototype2 !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype2) {
          if (setPrototypeOf2) {
            setPrototypeOf2(CurrentIteratorPrototype, IteratorPrototype2);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$42] != "function") {
            createNonEnumerableProperty$12(CurrentIteratorPrototype, ITERATOR$42, returnThis2);
          }
        }
        setToStringTag$12(CurrentIteratorPrototype, TO_STRING_TAG5, true);
      }
    }
    if (DEFAULT == VALUES2 && nativeIterator && nativeIterator.name !== VALUES2) {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return nativeIterator.call(this);
      };
    }
    if (IterablePrototype[ITERATOR$42] !== defaultIterator) {
      createNonEnumerableProperty$12(IterablePrototype, ITERATOR$42, defaultIterator);
    }
    Iterators$32[NAME2] = defaultIterator;
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES2),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS2),
        entries: getIterationMethod(ENTRIES2)
      };
      if (FORCED5) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS2 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$32(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $$72({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS2 || INCORRECT_VALUES_NAME }, methods);
    }
    return methods;
  };
  var toIndexedObject2 = toIndexedObject$42;
  var addToUnscopables$12 = addToUnscopables$22;
  var Iterators$22 = iterators2;
  var InternalStateModule$12 = internalState2;
  var defineIterator2 = defineIterator$12;
  var ARRAY_ITERATOR2 = "Array Iterator";
  var setInternalState$12 = InternalStateModule$12.set;
  var getInternalState$12 = InternalStateModule$12.getterFor(ARRAY_ITERATOR2);
  var es_array_iterator2 = defineIterator2(Array, "Array", function(iterated, kind) {
    setInternalState$12(this, {
      type: ARRAY_ITERATOR2,
      target: toIndexedObject2(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState$12(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, "values");
  Iterators$22.Arguments = Iterators$22.Array;
  addToUnscopables$12("keys");
  addToUnscopables$12("values");
  addToUnscopables$12("entries");
  var DESCRIPTORS$32 = descriptors2;
  var fails$52 = fails$c2;
  var objectKeys3 = objectKeys$22;
  var getOwnPropertySymbolsModule2 = objectGetOwnPropertySymbols2;
  var propertyIsEnumerableModule2 = objectPropertyIsEnumerable2;
  var toObject$22 = toObject$42;
  var IndexedObject$12 = indexedObject2;
  var nativeAssign2 = Object.assign;
  var defineProperty$22 = Object.defineProperty;
  var objectAssign2 = !nativeAssign2 || fails$52(function() {
    if (DESCRIPTORS$32 && nativeAssign2({ b: 1 }, nativeAssign2(defineProperty$22({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty$22(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return nativeAssign2({}, A)[symbol] != 7 || objectKeys3(nativeAssign2({}, B)).join("") != alphabet;
  }) ? function assign3(target, source) {
    var T = toObject$22(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule2.f;
    var propertyIsEnumerable7 = propertyIsEnumerableModule2.f;
    while (argumentsLength > index) {
      var S = IndexedObject$12(arguments[index++]);
      var keys14 = getOwnPropertySymbols ? objectKeys3(S).concat(getOwnPropertySymbols(S)) : objectKeys3(S);
      var length = keys14.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys14[j++];
        if (!DESCRIPTORS$32 || propertyIsEnumerable7.call(S, key)) T[key] = S[key];
      }
    }
    return T;
  } : nativeAssign2;
  var $$62 = _export2;
  var assign4 = objectAssign2;
  $$62({ target: "Object", stat: true, forced: Object.assign !== assign4 }, {
    assign: assign4
  });
  var domIterables2 = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var global$82 = global$j2;
  var DOMIterables2 = domIterables2;
  var ArrayIteratorMethods2 = es_array_iterator2;
  var createNonEnumerableProperty2 = createNonEnumerableProperty$72;
  var wellKnownSymbol$a2 = wellKnownSymbol$f2;
  var ITERATOR$32 = wellKnownSymbol$a2("iterator");
  var TO_STRING_TAG$22 = wellKnownSymbol$a2("toStringTag");
  var ArrayValues2 = ArrayIteratorMethods2.values;
  for (COLLECTION_NAME in DOMIterables2) {
    Collection = global$82[COLLECTION_NAME];
    CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR$32] !== ArrayValues2) try {
        createNonEnumerableProperty2(CollectionPrototype, ITERATOR$32, ArrayValues2);
      } catch (error2) {
        CollectionPrototype[ITERATOR$32] = ArrayValues2;
      }
      if (!CollectionPrototype[TO_STRING_TAG$22]) {
        createNonEnumerableProperty2(CollectionPrototype, TO_STRING_TAG$22, COLLECTION_NAME);
      }
      if (DOMIterables2[COLLECTION_NAME]) for (METHOD_NAME in ArrayIteratorMethods2) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods2[METHOD_NAME]) try {
          createNonEnumerableProperty2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods2[METHOD_NAME]);
        } catch (error2) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods2[METHOD_NAME];
        }
      }
    }
  }
  var Collection;
  var CollectionPrototype;
  var METHOD_NAME;
  var COLLECTION_NAME;
  var CloseIcon = () => {
    return (0, import_jsx_runtime.jsxs)("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24",
      fill: "#C1C1C1"
    }, {
      children: [(0, import_jsx_runtime.jsx)("path", {
        d: "M0 0h24v24H0z",
        fill: "none"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
      })]
    }));
  };
  var CloseButton = ({
    onClick
  }) => {
    return (0, import_jsx_runtime.jsx)("button", Object.assign({
      onClick,
      className: "close-button"
    }, {
      children: (0, import_jsx_runtime.jsx)(CloseIcon, {})
    }));
  };
  var ModalHeader = ({
    title: title3,
    onCloseModal
  }) => {
    const additionalClasses = title3 === "Get a Wallet" ? " -open" : "";
    return (0, import_jsx_runtime.jsxs)("div", Object.assign({
      className: "nws-modal-header"
    }, {
      children: [(0, import_jsx_runtime.jsx)("h3", Object.assign({
        className: `middleTitle ${additionalClasses}`
      }, {
        children: title3
      })), (0, import_jsx_runtime.jsx)(CloseButton, {
        onClick: onCloseModal
      })]
    }));
  };
  var BackArrowIcon = () => {
    return (0, import_jsx_runtime.jsx)("svg", Object.assign({
      width: "8",
      height: "14",
      viewBox: "0 0 8 14",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M7 13L1 7L7 1",
        stroke: "#6494EE",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })
    }));
  };
  var BackArrow = ({
    onClick
  }) => {
    return (0, import_jsx_runtime.jsx)("button", Object.assign({
      onClick,
      className: "back-button"
    }, {
      children: (0, import_jsx_runtime.jsx)(BackArrowIcon, {})
    }));
  };
  var WalletNetworkChanged = ({
    selector,
    onBack,
    onCloseModal
  }) => {
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal-header-wrapper"
      }, {
        children: [(0, import_jsx_runtime.jsx)(BackArrow, {
          onClick: onBack
        }), (0, import_jsx_runtime.jsx)(ModalHeader, {
          title: "You Must Change the Network",
          onCloseModal
        })]
      })), (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "switch-network-message-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "content"
        }, {
          children: [(0, import_jsx_runtime.jsxs)("p", {
            children: ["We've detected that you need to change your wallet's network to", (0, import_jsx_runtime.jsx)("strong", Object.assign({
              className: "network-id"
            }, {
              children: ` ${selector.options.network.networkId}`
            })), " ", "for this dApp."]
          }), (0, import_jsx_runtime.jsx)("p", {
            children: "Some wallets may not support changing networks. If you can not change networks you may consider switching to another wallet."
          })]
        }))
      }))]
    });
  };
  var $$52 = _export2;
  var DESCRIPTORS$22 = descriptors2;
  var global$72 = global$j2;
  var has$12 = has$b2;
  var isObject$32 = isObject$92;
  var defineProperty$12 = objectDefineProperty2.f;
  var copyConstructorProperties2 = copyConstructorProperties$2;
  var NativeSymbol = global$72.Symbol;
  if (DESCRIPTORS$22 && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
  NativeSymbol().description !== void 0)) {
    EmptyStringDescriptionStore = {};
    SymbolWrapper = function Symbol2() {
      var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
      var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
      if (description === "") EmptyStringDescriptionStore[result] = true;
      return result;
    };
    copyConstructorProperties2(SymbolWrapper, NativeSymbol);
    symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
    symbolPrototype.constructor = SymbolWrapper;
    symbolToString = symbolPrototype.toString;
    native = String(NativeSymbol("test")) == "Symbol(test)";
    regexp = /^Symbol\((.*)\)[^)]+$/;
    defineProperty$12(symbolPrototype, "description", {
      configurable: true,
      get: function description() {
        var symbol = isObject$32(this) ? this.valueOf() : this;
        var string = symbolToString.call(symbol);
        if (has$12(EmptyStringDescriptionStore, symbol)) return "";
        var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
        return desc === "" ? void 0 : desc;
      }
    });
    $$52({ global: true, forced: true }, {
      Symbol: SymbolWrapper
    });
  }
  var EmptyStringDescriptionStore;
  var SymbolWrapper;
  var symbolPrototype;
  var symbolToString;
  var native;
  var regexp;
  var DESCRIPTORS$12 = descriptors2;
  var fails$42 = fails$c2;
  var has2 = has$b2;
  var defineProperty5 = Object.defineProperty;
  var cache2 = {};
  var thrower2 = function(it) {
    throw it;
  };
  var arrayMethodUsesToLength$22 = function(METHOD_NAME, options) {
    if (has2(cache2, METHOD_NAME)) return cache2[METHOD_NAME];
    if (!options) options = {};
    var method2 = [][METHOD_NAME];
    var ACCESSORS = has2(options, "ACCESSORS") ? options.ACCESSORS : false;
    var argument0 = has2(options, 0) ? options[0] : thrower2;
    var argument1 = has2(options, 1) ? options[1] : void 0;
    return cache2[METHOD_NAME] = !!method2 && !fails$42(function() {
      if (ACCESSORS && !DESCRIPTORS$12) return true;
      var O = { length: -1 };
      if (ACCESSORS) defineProperty5(O, 1, { enumerable: true, get: thrower2 });
      else O[1] = 1;
      method2.call(O, argument0, argument1);
    });
  };
  var $$42 = _export2;
  var $includes2 = arrayIncludes2.includes;
  var addToUnscopables2 = addToUnscopables$22;
  var arrayMethodUsesToLength$12 = arrayMethodUsesToLength$22;
  var USES_TO_LENGTH$12 = arrayMethodUsesToLength$12("indexOf", { ACCESSORS: true, 1: 0 });
  $$42({ target: "Array", proto: true, forced: !USES_TO_LENGTH$12 }, {
    includes: function includes5(el) {
      return $includes2(this, el, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  addToUnscopables2("includes");
  var aFunction$62 = function(it) {
    if (typeof it != "function") {
      throw TypeError(String(it) + " is not a function");
    }
    return it;
  };
  var aFunction$52 = aFunction$62;
  var toObject$12 = toObject$42;
  var IndexedObject2 = indexedObject2;
  var toLength$12 = toLength$32;
  var createMethod3 = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      aFunction$52(callbackfn);
      var O = toObject$12(that);
      var self2 = IndexedObject2(O);
      var length = toLength$12(O.length);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError("Reduce of empty array with no initial value");
        }
      }
      for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
      return memo;
    };
  };
  var arrayReduce2 = {
    // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
    left: createMethod3(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
    right: createMethod3(true)
  };
  var fails$32 = fails$c2;
  var arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {
    var method2 = [][METHOD_NAME];
    return !!method2 && fails$32(function() {
      method2.call(null, argument || function() {
        throw 1;
      }, 1);
    });
  };
  var $$32 = _export2;
  var $reduce2 = arrayReduce2.left;
  var arrayMethodIsStrict$12 = arrayMethodIsStrict$2;
  var arrayMethodUsesToLength2 = arrayMethodUsesToLength$22;
  var STRICT_METHOD$1 = arrayMethodIsStrict$12("reduce");
  var USES_TO_LENGTH2 = arrayMethodUsesToLength2("reduce", { 1: 0 });
  $$32({ target: "Array", proto: true, forced: !STRICT_METHOD$1 || !USES_TO_LENGTH2 }, {
    reduce: function reduce2(callbackfn) {
      return $reduce2(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var $$22 = _export2;
  var aFunction$42 = aFunction$62;
  var toObject2 = toObject$42;
  var fails$22 = fails$c2;
  var arrayMethodIsStrict2 = arrayMethodIsStrict$2;
  var test$1 = [];
  var nativeSort = test$1.sort;
  var FAILS_ON_UNDEFINED = fails$22(function() {
    test$1.sort(void 0);
  });
  var FAILS_ON_NULL = fails$22(function() {
    test$1.sort(null);
  });
  var STRICT_METHOD2 = arrayMethodIsStrict2("sort");
  var FORCED$12 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD2;
  $$22({ target: "Array", proto: true, forced: FORCED$12 }, {
    sort: function sort2(comparefn) {
      return comparefn === void 0 ? nativeSort.call(toObject2(this)) : nativeSort.call(toObject2(this), aFunction$42(comparefn));
    }
  });
  var isObject$22 = isObject$92;
  var classof$52 = classofRaw$12;
  var wellKnownSymbol$92 = wellKnownSymbol$f2;
  var MATCH$12 = wellKnownSymbol$92("match");
  var isRegexp2 = function(it) {
    var isRegExp4;
    return isObject$22(it) && ((isRegExp4 = it[MATCH$12]) !== void 0 ? !!isRegExp4 : classof$52(it) == "RegExp");
  };
  var isRegExp3 = isRegexp2;
  var notARegexp2 = function(it) {
    if (isRegExp3(it)) {
      throw TypeError("The method doesn't accept regular expressions");
    }
    return it;
  };
  var wellKnownSymbol$82 = wellKnownSymbol$f2;
  var MATCH2 = wellKnownSymbol$82("match");
  var correctIsRegexpLogic2 = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (e) {
      try {
        regexp[MATCH2] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (f) {
      }
    }
    return false;
  };
  var $$12 = _export2;
  var notARegExp2 = notARegexp2;
  var requireObjectCoercible2 = requireObjectCoercible$32;
  var correctIsRegExpLogic2 = correctIsRegexpLogic2;
  $$12({ target: "String", proto: true, forced: !correctIsRegExpLogic2("includes") }, {
    includes: function includes6(searchString) {
      return !!~String(requireObjectCoercible2(this)).indexOf(notARegExp2(searchString), arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var WarningIcon = () => {
    return (0, import_jsx_runtime.jsxs)("svg", Object.assign({
      width: "18",
      height: "18",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: [(0, import_jsx_runtime.jsx)("path", {
        d: "M4.95215 16.3536L10.2152 5.85657C10.9531 4.38481 13.0538 4.38519 13.7912 5.85723L19.0494 16.3543C19.7156 17.6841 18.7486 19.25 17.2612 19.25H6.74001C5.25228 19.25 4.28535 17.6835 4.95215 16.3536Z",
        stroke: "#E6B73E",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M12 10V12",
        stroke: "#E6B73E",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M12.5 16C12.5 16.2761 12.2761 16.5 12 16.5C11.7239 16.5 11.5 16.2761 11.5 16C11.5 15.7239 11.7239 15.5 12 15.5C12.2761 15.5 12.5 15.7239 12.5 16Z",
        stroke: "#E6B73E"
      })]
    }));
  };
  var WalletOptions = ({
    selector,
    handleWalletClick
  }) => {
    const [modules, setModules] = (0, import_react.useState)([]);
    const [recentModules, setRecentModules] = (0, import_react.useState)([]);
    const [moreModules, setMoreModules] = (0, import_react.useState)([]);
    const [activeWalletId, setActiveWalletId] = (0, import_react.useState)("");
    (0, import_react.useEffect)(() => {
      const subscription = selector.store.observable.subscribe((state) => {
        const {
          selectedWalletId
        } = selector.store.getState();
        if (selectedWalletId) {
          setActiveWalletId(selectedWalletId);
        }
        const wallets = state.modules.filter((module2) => !(module2.type === "instant-link" && selectedWalletId !== module2.id));
        if (selector.options.optimizeWalletOrder) {
          state.modules.sort((current, next3) => {
            if (current.metadata.deprecated === next3.metadata.deprecated) {
              return 0;
            }
            return current.metadata.deprecated ? 1 : -1;
          });
          state.modules.sort((current, next3) => {
            if (next3.metadata.available === current.metadata.available) {
              return 0;
            }
            return next3.metadata.available ? 1 : -1;
          });
          const moreWallets = [];
          const recentlySignedInWallets = [];
          wallets.forEach((module2) => {
            if (selector.store.getState().recentlySignedInWallets.includes(module2.id)) {
              recentlySignedInWallets.push(module2);
            } else {
              moreWallets.push(module2);
            }
          });
          setRecentModules(recentlySignedInWallets);
          setMoreModules(moreWallets);
        }
        if (selector.options.randomizeWalletOrder) {
          setModules(wallets.sort(() => Math.random() - 0.5));
        } else {
          setModules(wallets);
        }
      });
      return () => subscription.unsubscribe();
    }, []);
    (0, import_react.useEffect)(() => {
      const {
        recentlySignedInWallets
      } = selector.store.getState();
      if (recentlySignedInWallets.length) {
        setActiveWalletId(recentlySignedInWallets[0]);
      }
    }, [selector.store]);
    function renderOptionsList(modulesToRender) {
      return modulesToRender.reduce((result, module2, index) => {
        const {
          selectedWalletId
        } = selector.store.getState();
        const {
          name,
          description,
          iconUrl,
          deprecated
        } = module2.metadata;
        const selected = module2.id === selectedWalletId;
        result.push((0, import_jsx_runtime.jsxs)("li", Object.assign({
          tabIndex: 0,
          className: `single-wallet ${activeWalletId === module2.id ? "selected-wallet" : ""} ${selected ? "connected-wallet" : ""} ${deprecated ? "deprecated-wallet" : ""} sidebar ${module2.id}`,
          onClick: () => {
            if (selector.options.network.networkId === "testnet" && module2.id === "here-wallet") {
              alert("Here Wallet is not supported on testnet");
              return;
            }
            if (module2.id === modulesToRender[index].id) {
              setActiveWalletId(module2.id);
            }
            return handleWalletClick(module2);
          }
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "icon"
          }, {
            children: (0, import_jsx_runtime.jsx)("img", {
              src: iconUrl,
              alt: name
            })
          })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "content"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "title"
            }, {
              children: name
            })), (0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "description"
            }, {
              children: description
            }))]
          })), deprecated && (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "warning-triangle"
          }, {
            children: (0, import_jsx_runtime.jsx)(WarningIcon, {})
          }))]
        }), module2.id));
        return result;
      }, []);
    }
    return (0, import_jsx_runtime.jsx)("div", {
      children: selector.options.optimizeWalletOrder && selector.store.getState().recentlySignedInWallets.length > 0 ? (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "wallet-options-wrapper"
      }, {
        children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "options-list-section-recent"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "options-list-section-header"
          }, {
            children: "Recent"
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "options-list more-options-list-content"
          }, {
            children: renderOptionsList(recentModules)
          }))]
        })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "options-list-section-more"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "options-list-section-header"
          }, {
            children: "More"
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "options-list more-options-list-content"
          }, {
            children: renderOptionsList(moreModules)
          }))]
        }))]
      })) : (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "wallet-options-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "options-list"
        }, {
          children: renderOptionsList(modules)
        }))
      }))
    });
  };
  var ConnectionErrorIcon = () => {
    return (0, import_jsx_runtime.jsxs)("svg", Object.assign({
      width: "21",
      height: "20",
      viewBox: "0 0 21 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: [(0, import_jsx_runtime.jsx)("path", {
        d: "M10.5001 18.3333C15.1025 18.3333 18.8334 14.6023 18.8334 9.99996C18.8334 5.39759 15.1025 1.66663 10.5001 1.66663C5.89771 1.66663 2.16675 5.39759 2.16675 9.99996C2.16675 14.6023 5.89771 18.3333 10.5001 18.3333Z",
        stroke: "#CE5A6F",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M13 7.5L8 12.5",
        stroke: "#CE5A6F",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M8 7.5L13 12.5",
        stroke: "#CE5A6F",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })]
    }));
  };
  var ConnectionSuccessIcon = () => {
    return (0, import_jsx_runtime.jsxs)("svg", Object.assign({
      width: "21",
      height: "20",
      viewBox: "0 0 21 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: [(0, import_jsx_runtime.jsx)("path", {
        d: "M18.8333 9.2333V9.99997C18.8323 11.797 18.2504 13.5455 17.1744 14.9848C16.0984 16.4241 14.586 17.477 12.8628 17.9866C11.1395 18.4961 9.29768 18.4349 7.61202 17.8121C5.92636 17.1894 4.48717 16.0384 3.50909 14.5309C2.53101 13.0233 2.06645 11.24 2.18469 9.4469C2.30293 7.65377 2.99763 5.94691 4.16519 4.58086C5.33275 3.21482 6.91061 2.26279 8.66345 1.86676C10.4163 1.47073 12.2502 1.65192 13.8916 2.3833",
        stroke: "#4FD98F",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M18.8333 3.33337L10.5 11.675L8 9.17504",
        stroke: "#4FD98F",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })]
    }));
  };
  var ConnectionResult = ({
    module: module2,
    message,
    err,
    onRetry
  }) => {
    return (0, import_jsx_runtime.jsx)("div", Object.assign({
      className: "connection connecting-details"
    }, {
      children: err ? (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "error-wrapper"
      }, {
        children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "error"
        }, {
          children: [(0, import_jsx_runtime.jsx)(ConnectionErrorIcon, {}), translate("modal.wallet.connectionFailed")]
        })), (0, import_jsx_runtime.jsx)("p", {
          children: message
        }), (module2 === null || module2 === void 0 ? void 0 : module2.metadata.available) && (0, import_jsx_runtime.jsx)("button", Object.assign({
          onClick: onRetry
        }, {
          children: translate("modal.ledger.retry")
        }))]
      })) : (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "success"
      }, {
        children: [(0, import_jsx_runtime.jsx)(ConnectionSuccessIcon, {}), translate("modal.wallet.connectionSuccessful")]
      }))
    }));
  };
  var AlertMessage = ({
    message,
    module: module2,
    onBack,
    onCloseModal
  }) => {
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
        title: "",
        onCloseModal
      }), (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "alert-message connecting-wrapper connecting-wrapper-err"
      }, {
        children: (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "content"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "icon"
          }, {
            children: (0, import_jsx_runtime.jsx)("img", {
              src: module2 === null || module2 === void 0 ? void 0 : module2.metadata.iconUrl,
              alt: module2 === null || module2 === void 0 ? void 0 : module2.metadata.name
            })
          })), (0, import_jsx_runtime.jsx)("h3", Object.assign({
            className: "connecting-name"
          }, {
            children: module2 === null || module2 === void 0 ? void 0 : module2.metadata.name
          })), (0, import_jsx_runtime.jsx)(ConnectionResult, {
            module: module2,
            message,
            err: message !== null,
            onRetry: () => {
              onBack(true);
            }
          })]
        }))
      }))]
    });
  };
  var global$62 = global$j2;
  var nativePromiseConstructor2 = global$62.Promise;
  var redefine$22 = redefine$52.exports;
  var redefineAll$12 = function(target, src, options) {
    for (var key in src) redefine$22(target, key, src[key], options);
    return target;
  };
  var getBuiltIn$22 = getBuiltIn$52;
  var definePropertyModule2 = objectDefineProperty2;
  var wellKnownSymbol$72 = wellKnownSymbol$f2;
  var DESCRIPTORS2 = descriptors2;
  var SPECIES$22 = wellKnownSymbol$72("species");
  var setSpecies$12 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$22(CONSTRUCTOR_NAME);
    var defineProperty14 = definePropertyModule2.f;
    if (DESCRIPTORS2 && Constructor && !Constructor[SPECIES$22]) {
      defineProperty14(Constructor, SPECIES$22, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  var anInstance$12 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
    }
    return it;
  };
  var iterate$22 = { exports: {} };
  var wellKnownSymbol$62 = wellKnownSymbol$f2;
  var Iterators$12 = iterators2;
  var ITERATOR$22 = wellKnownSymbol$62("iterator");
  var ArrayPrototype2 = Array.prototype;
  var isArrayIteratorMethod$12 = function(it) {
    return it !== void 0 && (Iterators$12.Array === it || ArrayPrototype2[ITERATOR$22] === it);
  };
  var aFunction$32 = aFunction$62;
  var functionBindContext2 = function(fn, that, length) {
    aFunction$32(fn);
    if (that === void 0) return fn;
    switch (length) {
      case 0:
        return function() {
          return fn.call(that);
        };
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var wellKnownSymbol$52 = wellKnownSymbol$f2;
  var TO_STRING_TAG$12 = wellKnownSymbol$52("toStringTag");
  var test2 = {};
  test2[TO_STRING_TAG$12] = "z";
  var toStringTagSupport2 = String(test2) === "[object z]";
  var TO_STRING_TAG_SUPPORT2 = toStringTagSupport2;
  var classofRaw2 = classofRaw$12;
  var wellKnownSymbol$42 = wellKnownSymbol$f2;
  var TO_STRING_TAG2 = wellKnownSymbol$42("toStringTag");
  var CORRECT_ARGUMENTS2 = classofRaw2(/* @__PURE__ */ (function() {
    return arguments;
  })()) == "Arguments";
  var tryGet2 = function(it, key) {
    try {
      return it[key];
    } catch (error2) {
    }
  };
  var classof$42 = TO_STRING_TAG_SUPPORT2 ? classofRaw2 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet2(O = Object(it), TO_STRING_TAG2)) == "string" ? tag : CORRECT_ARGUMENTS2 ? classofRaw2(O) : (result = classofRaw2(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
  };
  var classof$32 = classof$42;
  var Iterators2 = iterators2;
  var wellKnownSymbol$32 = wellKnownSymbol$f2;
  var ITERATOR$12 = wellKnownSymbol$32("iterator");
  var getIteratorMethod$12 = function(it) {
    if (it != void 0) return it[ITERATOR$12] || it["@@iterator"] || Iterators2[classof$32(it)];
  };
  var anObject$52 = anObject$b2;
  var callWithSafeIterationClosing$12 = function(iterator, fn, value, ENTRIES5) {
    try {
      return ENTRIES5 ? fn(anObject$52(value)[0], value[1]) : fn(value);
    } catch (error2) {
      var returnMethod = iterator["return"];
      if (returnMethod !== void 0) anObject$52(returnMethod.call(iterator));
      throw error2;
    }
  };
  var anObject$42 = anObject$b2;
  var isArrayIteratorMethod2 = isArrayIteratorMethod$12;
  var toLength2 = toLength$32;
  var bind$22 = functionBindContext2;
  var getIteratorMethod2 = getIteratorMethod$12;
  var callWithSafeIterationClosing2 = callWithSafeIterationClosing$12;
  var Result2 = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var iterate$12 = iterate$22.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bind$22(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next3, step;
    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod2(iterable);
      if (typeof iterFn != "function") throw TypeError("Target is not iterable");
      if (isArrayIteratorMethod2(iterFn)) {
        for (index = 0, length = toLength2(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject$42(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result2) return result;
        }
        return new Result2(false);
      }
      iterator = iterFn.call(iterable);
    }
    next3 = iterator.next;
    while (!(step = next3.call(iterator)).done) {
      result = callWithSafeIterationClosing2(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == "object" && result && result instanceof Result2) return result;
    }
    return new Result2(false);
  };
  iterate$12.stop = function(result) {
    return new Result2(true, result);
  };
  var wellKnownSymbol$22 = wellKnownSymbol$f2;
  var ITERATOR2 = wellKnownSymbol$22("iterator");
  var SAFE_CLOSING2 = false;
  try {
    called = 0;
    iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING2 = true;
      }
    };
    iteratorWithReturn[ITERATOR2] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error2) {
  }
  var called;
  var iteratorWithReturn;
  var checkCorrectnessOfIteration$12 = function(exec3, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING2) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR2] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec3(object);
    } catch (error2) {
    }
    return ITERATION_SUPPORT;
  };
  var anObject$32 = anObject$b2;
  var aFunction$22 = aFunction$62;
  var wellKnownSymbol$12 = wellKnownSymbol$f2;
  var SPECIES$12 = wellKnownSymbol$12("species");
  var speciesConstructor$12 = function(O, defaultConstructor) {
    var C = anObject$32(O).constructor;
    var S;
    return C === void 0 || (S = anObject$32(C)[SPECIES$12]) == void 0 ? defaultConstructor : aFunction$22(S);
  };
  var getBuiltIn$12 = getBuiltIn$52;
  var engineUserAgent2 = getBuiltIn$12("navigator", "userAgent") || "";
  var userAgent$12 = engineUserAgent2;
  var engineIsIos2 = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent$12);
  var global$52 = global$j2;
  var fails$12 = fails$c2;
  var classof$22 = classofRaw$12;
  var bind$12 = functionBindContext2;
  var html2 = html$22;
  var createElement2 = documentCreateElement$12;
  var IS_IOS$12 = engineIsIos2;
  var location3 = global$52.location;
  var set3 = global$52.setImmediate;
  var clear2 = global$52.clearImmediate;
  var process$32 = global$52.process;
  var MessageChannel3 = global$52.MessageChannel;
  var Dispatch2 = global$52.Dispatch;
  var counter2 = 0;
  var queue4 = {};
  var ONREADYSTATECHANGE2 = "onreadystatechange";
  var defer2;
  var channel2;
  var port2;
  var run2 = function(id7) {
    if (queue4.hasOwnProperty(id7)) {
      var fn = queue4[id7];
      delete queue4[id7];
      fn();
    }
  };
  var runner2 = function(id7) {
    return function() {
      run2(id7);
    };
  };
  var listener2 = function(event) {
    run2(event.data);
  };
  var post2 = function(id7) {
    global$52.postMessage(id7 + "", location3.protocol + "//" + location3.host);
  };
  if (!set3 || !clear2) {
    set3 = function setImmediate2(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue4[++counter2] = function() {
        (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
      };
      defer2(counter2);
      return counter2;
    };
    clear2 = function clearImmediate(id7) {
      delete queue4[id7];
    };
    if (classof$22(process$32) == "process") {
      defer2 = function(id7) {
        process$32.nextTick(runner2(id7));
      };
    } else if (Dispatch2 && Dispatch2.now) {
      defer2 = function(id7) {
        Dispatch2.now(runner2(id7));
      };
    } else if (MessageChannel3 && !IS_IOS$12) {
      channel2 = new MessageChannel3();
      port2 = channel2.port2;
      channel2.port1.onmessage = listener2;
      defer2 = bind$12(port2.postMessage, port2, 1);
    } else if (global$52.addEventListener && typeof postMessage == "function" && !global$52.importScripts && !fails$12(post2) && location3.protocol !== "file:") {
      defer2 = post2;
      global$52.addEventListener("message", listener2, false);
    } else if (ONREADYSTATECHANGE2 in createElement2("script")) {
      defer2 = function(id7) {
        html2.appendChild(createElement2("script"))[ONREADYSTATECHANGE2] = function() {
          html2.removeChild(this);
          run2(id7);
        };
      };
    } else {
      defer2 = function(id7) {
        setTimeout(runner2(id7), 0);
      };
    }
  }
  var task$12 = {
    set: set3,
    clear: clear2
  };
  var global$42 = global$j2;
  var getOwnPropertyDescriptor5 = objectGetOwnPropertyDescriptor2.f;
  var classof$12 = classofRaw$12;
  var macrotask2 = task$12.set;
  var IS_IOS2 = engineIsIos2;
  var MutationObserver2 = global$42.MutationObserver || global$42.WebKitMutationObserver;
  var process$22 = global$42.process;
  var Promise$12 = global$42.Promise;
  var IS_NODE$12 = classof$12(process$22) == "process";
  var queueMicrotaskDescriptor2 = getOwnPropertyDescriptor5(global$42, "queueMicrotask");
  var queueMicrotask3 = queueMicrotaskDescriptor2 && queueMicrotaskDescriptor2.value;
  var flush2;
  var head2;
  var last2;
  var notify$12;
  var toggle2;
  var node2;
  var promise2;
  var then2;
  if (!queueMicrotask3) {
    flush2 = function() {
      var parent2, fn;
      if (IS_NODE$12 && (parent2 = process$22.domain)) parent2.exit();
      while (head2) {
        fn = head2.fn;
        head2 = head2.next;
        try {
          fn();
        } catch (error2) {
          if (head2) notify$12();
          else last2 = void 0;
          throw error2;
        }
      }
      last2 = void 0;
      if (parent2) parent2.enter();
    };
    if (IS_NODE$12) {
      notify$12 = function() {
        process$22.nextTick(flush2);
      };
    } else if (MutationObserver2 && !IS_IOS2) {
      toggle2 = true;
      node2 = document.createTextNode("");
      new MutationObserver2(flush2).observe(node2, { characterData: true });
      notify$12 = function() {
        node2.data = toggle2 = !toggle2;
      };
    } else if (Promise$12 && Promise$12.resolve) {
      promise2 = Promise$12.resolve(void 0);
      then2 = promise2.then;
      notify$12 = function() {
        then2.call(promise2, flush2);
      };
    } else {
      notify$12 = function() {
        macrotask2.call(global$42, flush2);
      };
    }
  }
  var microtask$12 = queueMicrotask3 || function(fn) {
    var task5 = { fn, next: void 0 };
    if (last2) last2.next = task5;
    if (!head2) {
      head2 = task5;
      notify$12();
    }
    last2 = task5;
  };
  var newPromiseCapability$22 = {};
  var aFunction$12 = aFunction$62;
  var PromiseCapability2 = function(C) {
    var resolve5, reject5;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve5 !== void 0 || reject5 !== void 0) throw TypeError("Bad Promise constructor");
      resolve5 = $$resolve;
      reject5 = $$reject;
    });
    this.resolve = aFunction$12(resolve5);
    this.reject = aFunction$12(reject5);
  };
  newPromiseCapability$22.f = function(C) {
    return new PromiseCapability2(C);
  };
  var anObject$22 = anObject$b2;
  var isObject$12 = isObject$92;
  var newPromiseCapability$12 = newPromiseCapability$22;
  var promiseResolve$12 = function(C, x) {
    anObject$22(C);
    if (isObject$12(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$12.f(C);
    var resolve5 = promiseCapability.resolve;
    resolve5(x);
    return promiseCapability.promise;
  };
  var global$32 = global$j2;
  var hostReportErrors$12 = function(a, b) {
    var console2 = global$32.console;
    if (console2 && console2.error) {
      arguments.length === 1 ? console2.error(a) : console2.error(a, b);
    }
  };
  var perform$12 = function(exec3) {
    try {
      return { error: false, value: exec3() };
    } catch (error2) {
      return { error: true, value: error2 };
    }
  };
  var global$22 = global$j2;
  var userAgent2 = engineUserAgent2;
  var process$12 = global$22.process;
  var versions4 = process$12 && process$12.versions;
  var v82 = versions4 && versions4.v8;
  var match2;
  var version4;
  if (v82) {
    match2 = v82.split(".");
    version4 = match2[0] + match2[1];
  } else if (userAgent2) {
    match2 = userAgent2.match(/Edge\/(\d+)/);
    if (!match2 || match2[1] >= 74) {
      match2 = userAgent2.match(/Chrome\/(\d+)/);
      if (match2) version4 = match2[1];
    }
  }
  var engineV8Version2 = version4 && +version4;
  var $2 = _export2;
  var global$12 = global$j2;
  var getBuiltIn2 = getBuiltIn$52;
  var NativePromise2 = nativePromiseConstructor2;
  var redefine$12 = redefine$52.exports;
  var redefineAll2 = redefineAll$12;
  var setToStringTag2 = setToStringTag$32;
  var setSpecies2 = setSpecies$12;
  var isObject3 = isObject$92;
  var aFunction2 = aFunction$62;
  var anInstance2 = anInstance$12;
  var classof2 = classofRaw$12;
  var inspectSource2 = inspectSource$32;
  var iterate2 = iterate$22.exports;
  var checkCorrectnessOfIteration2 = checkCorrectnessOfIteration$12;
  var speciesConstructor2 = speciesConstructor$12;
  var task2 = task$12.set;
  var microtask2 = microtask$12;
  var promiseResolve2 = promiseResolve$12;
  var hostReportErrors2 = hostReportErrors$12;
  var newPromiseCapabilityModule2 = newPromiseCapability$22;
  var perform2 = perform$12;
  var InternalStateModule2 = internalState2;
  var isForced2 = isForced_12;
  var wellKnownSymbol2 = wellKnownSymbol$f2;
  var V8_VERSION2 = engineV8Version2;
  var SPECIES2 = wellKnownSymbol2("species");
  var PROMISE2 = "Promise";
  var getInternalState2 = InternalStateModule2.get;
  var setInternalState2 = InternalStateModule2.set;
  var getInternalPromiseState2 = InternalStateModule2.getterFor(PROMISE2);
  var PromiseConstructor2 = NativePromise2;
  var TypeError$12 = global$12.TypeError;
  var document$12 = global$12.document;
  var process3 = global$12.process;
  var $fetch2 = getBuiltIn2("fetch");
  var newPromiseCapability2 = newPromiseCapabilityModule2.f;
  var newGenericPromiseCapability2 = newPromiseCapability2;
  var IS_NODE2 = classof2(process3) == "process";
  var DISPATCH_EVENT2 = !!(document$12 && document$12.createEvent && global$12.dispatchEvent);
  var UNHANDLED_REJECTION2 = "unhandledrejection";
  var REJECTION_HANDLED2 = "rejectionhandled";
  var PENDING2 = 0;
  var FULFILLED2 = 1;
  var REJECTED2 = 2;
  var HANDLED2 = 1;
  var UNHANDLED2 = 2;
  var Internal2;
  var OwnPromiseCapability2;
  var PromiseWrapper2;
  var nativeThen2;
  var FORCED2 = isForced2(PROMISE2, function() {
    var GLOBAL_CORE_JS_PROMISE = inspectSource2(PromiseConstructor2) !== String(PromiseConstructor2);
    if (!GLOBAL_CORE_JS_PROMISE) {
      if (V8_VERSION2 === 66) return true;
      if (!IS_NODE2 && typeof PromiseRejectionEvent != "function") return true;
    }
    if (V8_VERSION2 >= 51 && /native code/.test(PromiseConstructor2)) return false;
    var promise5 = PromiseConstructor2.resolve(1);
    var FakePromise = function(exec3) {
      exec3(function() {
      }, function() {
      });
    };
    var constructor = promise5.constructor = {};
    constructor[SPECIES2] = FakePromise;
    return !(promise5.then(function() {
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION2 = FORCED2 || !checkCorrectnessOfIteration2(function(iterable) {
    PromiseConstructor2.all(iterable)["catch"](function() {
    });
  });
  var isThenable2 = function(it) {
    var then5;
    return isObject3(it) && typeof (then5 = it.then) == "function" ? then5 : false;
  };
  var notify2 = function(promise5, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask2(function() {
      var value = state.value;
      var ok = state.state == FULFILLED2;
      var index = 0;
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve5 = reaction.resolve;
        var reject5 = reaction.reject;
        var domain2 = reaction.domain;
        var result, then5, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED2) onHandleUnhandled2(promise5, state);
              state.rejection = HANDLED2;
            }
            if (handler === true) result = value;
            else {
              if (domain2) domain2.enter();
              result = handler(value);
              if (domain2) {
                domain2.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject5(TypeError$12("Promise-chain cycle"));
            } else if (then5 = isThenable2(result)) {
              then5.call(result, resolve5, reject5);
            } else resolve5(result);
          } else reject5(value);
        } catch (error2) {
          if (domain2 && !exited) domain2.exit();
          reject5(error2);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled2(promise5, state);
    });
  };
  var dispatchEvent2 = function(name, promise5, reason) {
    var event, handler;
    if (DISPATCH_EVENT2) {
      event = document$12.createEvent("Event");
      event.promise = promise5;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$12.dispatchEvent(event);
    } else event = { promise: promise5, reason };
    if (handler = global$12["on" + name]) handler(event);
    else if (name === UNHANDLED_REJECTION2) hostReportErrors2("Unhandled promise rejection", reason);
  };
  var onUnhandled2 = function(promise5, state) {
    task2.call(global$12, function() {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled2(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform2(function() {
          if (IS_NODE2) {
            process3.emit("unhandledRejection", value, promise5);
          } else dispatchEvent2(UNHANDLED_REJECTION2, promise5, value);
        });
        state.rejection = IS_NODE2 || isUnhandled2(state) ? UNHANDLED2 : HANDLED2;
        if (result.error) throw result.value;
      }
    });
  };
  var isUnhandled2 = function(state) {
    return state.rejection !== HANDLED2 && !state.parent;
  };
  var onHandleUnhandled2 = function(promise5, state) {
    task2.call(global$12, function() {
      if (IS_NODE2) {
        process3.emit("rejectionHandled", promise5);
      } else dispatchEvent2(REJECTION_HANDLED2, promise5, state.value);
    });
  };
  var bind3 = function(fn, promise5, state, unwrap) {
    return function(value) {
      fn(promise5, state, value, unwrap);
    };
  };
  var internalReject2 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED2;
    notify2(promise5, state, true);
  };
  var internalResolve2 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (promise5 === value) throw TypeError$12("Promise can't be resolved itself");
      var then5 = isThenable2(value);
      if (then5) {
        microtask2(function() {
          var wrapper = { done: false };
          try {
            then5.call(
              value,
              bind3(internalResolve2, promise5, wrapper, state),
              bind3(internalReject2, promise5, wrapper, state)
            );
          } catch (error2) {
            internalReject2(promise5, wrapper, error2, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED2;
        notify2(promise5, state, false);
      }
    } catch (error2) {
      internalReject2(promise5, { done: false }, error2, state);
    }
  };
  if (FORCED2) {
    PromiseConstructor2 = function Promise2(executor) {
      anInstance2(this, PromiseConstructor2, PROMISE2);
      aFunction2(executor);
      Internal2.call(this);
      var state = getInternalState2(this);
      try {
        executor(bind3(internalResolve2, this, state), bind3(internalReject2, this, state));
      } catch (error2) {
        internalReject2(this, state, error2);
      }
    };
    Internal2 = function Promise2(executor) {
      setInternalState2(this, {
        type: PROMISE2,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING2,
        value: void 0
      });
    };
    Internal2.prototype = redefineAll2(PromiseConstructor2.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then5(onFulfilled, onRejected) {
        var state = getInternalPromiseState2(this);
        var reaction = newPromiseCapability2(speciesConstructor2(this, PromiseConstructor2));
        reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
        reaction.fail = typeof onRejected == "function" && onRejected;
        reaction.domain = IS_NODE2 ? process3.domain : void 0;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING2) notify2(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability2 = function() {
      var promise5 = new Internal2();
      var state = getInternalState2(promise5);
      this.promise = promise5;
      this.resolve = bind3(internalResolve2, promise5, state);
      this.reject = bind3(internalReject2, promise5, state);
    };
    newPromiseCapabilityModule2.f = newPromiseCapability2 = function(C) {
      return C === PromiseConstructor2 || C === PromiseWrapper2 ? new OwnPromiseCapability2(C) : newGenericPromiseCapability2(C);
    };
    if (typeof NativePromise2 == "function") {
      nativeThen2 = NativePromise2.prototype.then;
      redefine$12(NativePromise2.prototype, "then", function then5(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor2(function(resolve5, reject5) {
          nativeThen2.call(that, resolve5, reject5);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      if (typeof $fetch2 == "function") $2({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch2(input) {
          return promiseResolve2(PromiseConstructor2, $fetch2.apply(global$12, arguments));
        }
      });
    }
  }
  $2({ global: true, wrap: true, forced: FORCED2 }, {
    Promise: PromiseConstructor2
  });
  setToStringTag2(PromiseConstructor2, PROMISE2, false);
  setSpecies2(PROMISE2);
  PromiseWrapper2 = getBuiltIn2(PROMISE2);
  $2({ target: PROMISE2, stat: true, forced: FORCED2 }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject2(r) {
      var capability = newPromiseCapability2(this);
      capability.reject.call(void 0, r);
      return capability.promise;
    }
  });
  $2({ target: PROMISE2, stat: true, forced: FORCED2 }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve2(x) {
      return promiseResolve2(this, x);
    }
  });
  $2({ target: PROMISE2, stat: true, forced: INCORRECT_ITERATION2 }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all2(iterable) {
      var C = this;
      var capability = newPromiseCapability2(C);
      var resolve5 = capability.resolve;
      var reject5 = capability.reject;
      var result = perform2(function() {
        var $promiseResolve = aFunction2(C.resolve);
        var values2 = [];
        var counter5 = 0;
        var remaining = 1;
        iterate2(iterable, function(promise5) {
          var index = counter5++;
          var alreadyCalled = false;
          values2.push(void 0);
          remaining++;
          $promiseResolve.call(C, promise5).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve5(values2);
          }, reject5);
        });
        --remaining || resolve5(values2);
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race2(iterable) {
      var C = this;
      var capability = newPromiseCapability2(C);
      var reject5 = capability.reject;
      var result = perform2(function() {
        var $promiseResolve = aFunction2(C.resolve);
        iterate2(iterable, function(promise5) {
          $promiseResolve.call(C, promise5).then(capability.resolve, reject5);
        });
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    }
  });
  var HardwareWalletAccountsForm = ({
    accounts,
    onSelectedChanged,
    onSubmit,
    onChangeRoute
  }) => {
    return (0, import_jsx_runtime.jsxs)("div", Object.assign({
      className: "choose-ledger-account-form-wrapper"
    }, {
      children: [(0, import_jsx_runtime.jsxs)("p", {
        children: ["We found ", accounts.length, " accounts on your device. Select the account(s) you wish to connect."]
      }), (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "button-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsx)("button", Object.assign({
          onClick: () => {
            onChangeRoute("SpecifyHDPath");
          }
        }, {
          children: "HD.../0"
        }))
      })), (0, import_jsx_runtime.jsx)("form", Object.assign({
        className: "form",
        onSubmit: (e) => {
          onSubmit(accounts, e);
        }
      }, {
        children: (0, import_jsx_runtime.jsxs)("div", {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "nws-form-control"
          }, {
            children: accounts.map((account, index) => (0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "account"
            }, {
              children: [(0, import_jsx_runtime.jsx)("input", {
                onChange: (e) => {
                  onSelectedChanged(index, e.target.checked);
                },
                checked: account.selected,
                type: "checkbox",
                id: account.accountId,
                name: account.accountId,
                value: account.accountId
              }), (0, import_jsx_runtime.jsxs)("label", Object.assign({
                htmlFor: account.accountId
              }, {
                children: [" ", account.accountId]
              })), (0, import_jsx_runtime.jsx)("br", {})]
            }), index))
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "action-buttons"
          }, {
            children: (0, import_jsx_runtime.jsx)("button", Object.assign({
              className: "middleButton",
              type: "submit",
              disabled: !accounts.some((x) => x.selected)
            }, {
              children: "Connect"
            }))
          }))]
        })
      }))]
    }));
  };
  var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgBpVZ9aJVVGH+e55z33bi7zY9hMz+yMAeNoEIq6A9ZRKQWEsQNFIIpsf5Y9E+GsD9iBEEDMUkDa6ShRKKZYIWiRkaKaUGUGCKOTGMF84PNO99773vOefq9720yK5ZzD/dwPt/nd37P17lEk5Qnuz9roUkKT7T5bNe+QjTNLCHv24h1Xgh+OmtwQYPH2jUXwlnW9NRooqePfLS6MmmQ59cdeEGJlkJZA5MGVecoAwghBYZTVY9ftuaDSy8x8w9fbFl95JZAXuw9dmelkvRAyXxS7wMFryG4bIyWZiqzPgMhaFfGfn3NY3AZG9sPf/Dy8HidZvxkZc/h1pqnPlKey6yspMqUd9jVAEYY6RCGDQTwjGDwGTgAlbwRijV1C9vanz577tT+6r+YrOz5rlXFrQ/qZ+FbDxCfXS5oOgxln4v473f3rbgwdn7FK5/MCaH2eAg6X8g3K2iBMTiBkNJVKbod+ze9mgPZsY/UaicYzCE1HgpZc558olCTjTvWLxv9p1n3bV45iO7T5zq3TU9j9xTOLwQ5D9t48aEYrtGj2P/2BpNS78nZJoRdlDsYd8vphz273lqyhW5Rnlnz3hOe6SEwghvxPUMTVfYe2rpuUOqOkZeIxdSbsSJ8eTIAmXy5tftrMPkzi0C4B2ZDNHp+INvLQURkhYiJ6gDGko376DbEJ8k3mcnYBSeSM2ptL/XGsurNnxfnDIQNwCKADO1845Ef6Tbk0M51g4joMgncDyBmkrtsNEMQovcDxGYsGL2yDNAUxPv0VySs4yxhfeYbabJg0Awg+ILylEB6nKMpSOp0WCR1+QSuD4ELljNDEfyRrdXPCU1BTEgD7pyOzVmC2iBm0KgYAMCEeXovoClIjdKiVdQ3FYbzmatxWRqMPcNsDHyfNWskWk5TkJhNEwVyxA6hLL5clLJsW7voFxa6LiR5CCOeWzo3XFxKtyEdy3tnp7VahAoDp6PEVGvJye09l3P7K9k9WQijXBv4B6WG+0pvD0ybFEBHZ6OPh+/OGaBsIvNRAGp/ZHv1jJeon+omszBkFsr3FhsLB7rev3JLQKVSyfjmaW2BJSavDlqR7c5VrR+4AbLttbkXMehH7gjA8gZiD/tq+Or/ABZ3dUW/J62LcPUGcrW8pKSVFAg6cHz3O0l25qZHa/XGwWPg9aAwwzdZAaDX+7tbNsMYf5+bpaUS0dDQEF8rtsUxCbI5e5KRzGhBMiqNxllKju7d8NOYXjseRBytQngcVDL3wD9H+7vf3YS7mnnzqrZpwSxrwkh04cpM5NTMyJdHbIgaESyxJ6tZ5cDbw3qd0tqVCp25Se/4yYdr5/zm/ehjwvpxZHgN0Wlub0/Yt7awdykqRYFHy6NUQVrBd4o6p6ngrVL2Bo8ksuJqoXzq9Ln9m6rj9U74b6Wjo8OeP082aY5NUxRsYzwDkeFsU+MdUU3U4PG0QtbahqhadDMuHTy4fvS/9EwIUpdeuW/ZiShOipFxURRbNdWETFMRZrCFlEZGkuPHdycTafgLExNiI6YfUpcAAAAASUVORK5CYII=";
  var WalletConnecting = ({
    wallet,
    onCloseModal
  }) => {
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
        title: "",
        onCloseModal
      }), (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "connecting-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "content"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "icon"
          }, {
            children: (0, import_jsx_runtime.jsx)("img", {
              src: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.iconUrl,
              alt: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name
            })
          })), (0, import_jsx_runtime.jsx)("h3", Object.assign({
            className: "connecting-name"
          }, {
            children: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name
          })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "connecting-details"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "spinner"
            }, {
              children: (0, import_jsx_runtime.jsx)("img", {
                src: img,
                alt: "loading-icon"
              })
            })), (0, import_jsx_runtime.jsxs)("span", {
              children: [translate("modal.wallet.connectingTo"), " ", wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name, "..."]
            })]
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "connecting-message"
          }, {
            children: (0, import_jsx_runtime.jsx)("span", {
              children: translate(`modal.wallet.connectingMessage.${wallet === null || wallet === void 0 ? void 0 : wallet.type}`)
            })
          }))]
        }))
      }))]
    });
  };
  var LedgerDeviceIcon = () => {
    return (0, import_jsx_runtime.jsxs)("svg", Object.assign({
      width: "317",
      height: "157",
      viewBox: "0 0 317 157",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: [(0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M249.99 16.0994C270.063 -0.864155 289.788 1.58873 301.497 10.7365C307.402 15.3499 311.278 21.6575 312.267 28.1258C313.247 34.5412 311.413 41.2233 305.692 46.8044C297.366 54.9273 286.343 55.3362 273.015 51.5109C261.654 48.25 249.058 42.0377 235.726 35.4627L235.726 35.4626L235.717 35.458C233.367 34.2992 230.995 33.129 228.602 31.9618C212.742 24.2253 196.067 16.6575 179.842 13.8595C163.538 11.0479 147.552 13.0313 133.266 24.522C128.032 28.732 123.478 35.2086 121.716 44.8205C119.961 54.3947 120.992 66.9771 126.703 83.4311C135.432 108.583 132.899 126.677 123.575 138.063C114.217 149.491 97.5614 154.733 76.7887 153.121C55.0043 151.43 29.0621 142.206 3.29867 125.227L0.887817 127.942C27.2472 145.405 53.9251 154.952 76.5105 156.705C97.9028 158.365 115.96 153.035 126.356 140.341C136.785 127.606 139.045 108.029 130.099 82.2524C124.521 66.1801 123.642 54.2493 125.252 45.4687C126.854 36.7258 130.94 31.006 135.519 27.3232C148.794 16.6458 163.649 14.715 179.231 17.4021C194.891 20.1027 211.146 27.4463 227.026 35.1928C229.381 36.3415 231.729 37.5001 234.066 38.6531L234.073 38.6568C247.382 45.223 260.324 51.608 272.024 54.9662C285.819 58.9258 298.493 58.8501 308.202 49.3776C314.764 42.9759 316.974 35.1288 315.82 27.5826C314.675 20.0893 310.237 13.0029 303.71 7.90363C290.555 -2.37382 268.938 -4.62038 247.67 13.3537L249.99 16.0994Z",
        fill: "url(#paint0_linear_3_672)"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M260.264 17.8767L177.605 89.4649L157.679 73.9664L239.23 3.85423L260.264 17.8767Z",
        fill: "#6A7075"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M205.939 54.4577L199.764 50.2636L233.316 20.9053L239.907 25.8395L205.939 54.4577Z",
        fill: "#494E52"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M260.264 17.8757L177.605 89.4639L182.033 98.3202L264.323 26.363L260.264 17.8757Z",
        fill: "#494E52"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M177.236 89.4646L181.295 98.3209L165.059 85.7745L170.963 85.0365L177.236 89.4646Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M93.4708 99.6384L91.9948 110.13L174.653 92.894L164.69 85.7749L93.4708 99.6384Z",
        fill: "#DCDADA"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M93.1157 104.323L94.314 100.129L165.613 86.3483L169.208 89.344L93.1157 104.323Z",
        fill: "#C1C1C1"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M94.2086 99.7963L86.0903 101.272L92.3635 110.129L94.2086 99.7963Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M86.0903 100.907L89.0027 74.1304L178.455 55.2416C184.695 53.9962 195.766 54.7675 197.177 63.7058C198.284 70.717 195.506 73.9943 191.628 77.3592C188.495 80.0671 180.152 82.4646 178.343 82.8944C178.293 82.9064 178.241 82.9188 178.186 82.9319C177.38 83.1245 176.007 83.4525 170.644 84.5088C169.085 84.8158 167.382 85.1501 165.557 85.5078L164.933 85.63C146.312 89.2764 115.528 95.2297 93.9844 99.3849C91.1808 99.9257 88.5337 100.436 86.0903 100.907ZM185.076 75.554C190.748 73.3535 193.99 68.0745 192.318 63.7631C190.645 59.4517 184.691 57.7405 179.019 59.941C173.347 62.1416 170.105 67.4206 171.778 71.732C173.45 76.0434 179.404 77.7546 185.076 75.554Z",
        fill: "#F4F1E8"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M199.764 50.3994L196.768 48.3043L232.194 18.0454L233.316 21.6403L199.764 50.3994Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M239.968 25.9943L232.588 20.4592V17.5071L241.813 24.5183L239.968 25.9943Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("ellipse", {
        cx: "182.084",
        cy: "68.0811",
        rx: "10.242",
        ry: "7.46772",
        transform: "rotate(-23.7949 182.084 68.0811)",
        fill: "#494E52"
      }), (0, import_jsx_runtime.jsx)("ellipse", {
        cx: "182.084",
        cy: "68.0816",
        rx: "6.68462",
        ry: "4.87394",
        transform: "rotate(-23.7949 182.084 68.0816)",
        fill: "#494E52"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M238.725 2.93094L260.368 17.2564L264.865 26.4556L181.615 99.0341L175.16 94.311L92.0028 110.947L85.3267 101.399L88.3269 73.8157L178.118 54.8553L238.725 2.93094ZM178.599 56.2622L89.6786 75.0388L86.9321 100.29C89.0979 99.8725 91.4124 99.4263 93.8446 98.9572C115.388 94.8019 146.171 88.8488 164.791 85.2026L165.415 85.0804C167.24 84.7228 168.943 84.3885 170.501 84.0816C175.853 83.0275 177.219 82.701 178.015 82.5107C178.07 82.4976 178.122 82.4852 178.173 82.4732C179.048 82.2652 181.558 81.5669 184.235 80.5851C186.742 79.6655 189.286 78.5354 190.802 77.3758L191.151 77.0922L191.644 76.6595C193.341 75.147 194.723 73.6739 195.61 71.871C196.571 69.916 196.982 67.5029 196.448 64.1178C195.8 60.0131 192.959 57.7574 189.408 56.6566C185.833 55.5483 181.637 55.6566 178.603 56.2615C178.601 56.2617 178.6 56.262 178.599 56.2622ZM192.631 77.7565L259.555 18.9531L263.042 26.0869L181.808 96.9078L178.132 89.5713L191.724 78.529C191.859 78.4249 191.988 78.32 192.11 78.2144L192.111 78.2136C192.286 78.0617 192.46 77.9094 192.631 77.7565ZM185.491 81.6908C185.24 81.7868 184.99 81.8802 184.743 81.9709C182.013 82.9723 179.447 83.6875 178.514 83.9093C178.463 83.9213 178.411 83.9338 178.356 83.9468C177.635 84.1192 176.472 84.3971 172.491 85.1919L177.172 88.4492L185.491 81.6908ZM176.631 89.8707L170.479 85.5903C169.306 85.8213 168.054 86.0673 166.731 86.3265L175.769 92.9276L179.548 95.6924L176.631 89.8707ZM164.758 86.7132C146.252 90.3362 116.027 96.1817 94.6324 100.308L93.2258 109.197L173.543 93.1293L164.758 86.7132ZM91.888 108.207L93.0909 100.606C91.0848 100.993 89.1642 101.363 87.3471 101.713L91.888 108.207ZM258.581 17.8436L197.306 71.6841C198.142 69.5779 198.41 67.0795 197.906 63.8876C197.143 59.0539 193.743 56.4549 189.845 55.2467C186.921 54.3402 183.662 54.1916 180.861 54.449L238.84 4.77668L258.581 17.8436ZM232.505 16.82L243.089 24.5643L205.915 56.5106L196.042 48.0665L232.505 16.82ZM232.118 19.096L198.312 48.0654L199.744 49.29L232.584 20.9424L232.118 19.096ZM233.456 22.1396L200.878 50.2604L205.913 54.5664L239.041 26.0969L233.456 22.1396ZM240.195 25.1054L240.717 24.6571L233.759 19.5663L234.06 20.7586L240.195 25.1054Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M190.194 69.9744C191.32 68.1409 191.576 66.2271 190.942 64.5937C190.308 62.9603 188.829 61.7198 186.761 61.1254C184.691 60.5307 182.116 60.6196 179.553 61.6139C176.991 62.6081 175.029 64.2794 173.902 66.1141C172.776 67.9477 172.52 69.8614 173.154 71.4948C173.788 73.1282 175.267 74.3687 177.335 74.9631C179.405 75.5578 181.98 75.4689 184.543 74.4746C187.105 73.4804 189.067 71.8091 190.194 69.9744ZM185.077 75.8508C190.749 73.6502 193.991 68.3712 192.318 64.0598C190.645 59.7484 184.691 58.0372 179.019 60.2378C173.347 62.4383 170.105 67.7173 171.778 72.0287C173.451 76.3401 179.405 78.0513 185.077 75.8508Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M187.391 69.169C188.127 67.9713 188.266 66.7721 187.881 65.7812C187.497 64.7903 186.586 63.9984 185.235 63.6102C183.883 63.2216 182.173 63.2741 180.456 63.9404C178.738 64.6068 177.441 65.7208 176.705 66.9196C175.969 68.1172 175.83 69.3165 176.215 70.3074C176.599 71.2983 177.511 72.0901 178.861 72.4783C180.214 72.8669 181.923 72.8144 183.64 72.1481C185.358 71.4818 186.655 70.3678 187.391 69.169ZM184.174 73.5242C188.156 71.9795 190.432 68.2738 189.257 65.2473C188.083 62.2208 183.904 61.0196 179.922 62.5643C175.94 64.1091 173.665 67.8148 174.839 70.8412C176.013 73.8677 180.193 75.0689 184.174 73.5242Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M240.499 41.2441C239.744 40.3649 239.844 39.04 240.724 38.285L249.781 30.5067C250.66 29.7516 251.985 29.8523 252.74 30.7315V30.7315C253.495 31.6108 253.395 32.9356 252.516 33.6907L243.458 41.469C242.579 42.224 241.254 42.1234 240.499 41.2441V41.2441Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M250.743 31.6265L241.685 39.4048C241.424 39.6287 241.395 40.0217 241.619 40.2825C241.842 40.5433 242.235 40.5731 242.496 40.3492L251.554 32.5709C251.815 32.3469 251.845 31.954 251.621 31.6932C251.397 31.4324 251.004 31.4025 250.743 31.6265ZM240.724 38.285C239.844 39.04 239.744 40.3649 240.499 41.2441C241.254 42.1234 242.579 42.224 243.458 41.469L252.516 33.6907C253.395 32.9356 253.495 31.6108 252.74 30.7315C251.985 29.8523 250.66 29.7516 249.781 30.5067L240.724 38.285Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        d: "M205.779 71.4647C205.005 70.5642 205.108 69.2073 206.009 68.4339L214.989 60.7218C215.89 59.9485 217.247 60.0516 218.02 60.9521V60.9521C218.793 61.8526 218.69 63.2095 217.79 63.9829L208.809 71.695C207.909 72.4683 206.552 72.3652 205.779 71.4647V71.4647Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M215.951 61.8416L206.97 69.5537C206.688 69.796 206.656 70.221 206.898 70.5031C207.141 70.7851 207.566 70.8174 207.848 70.5752L216.828 62.863C217.11 62.6208 217.143 62.1958 216.9 61.9137C216.658 61.6317 216.233 61.5994 215.951 61.8416ZM206.009 68.4339C205.108 69.2073 205.005 70.5642 205.779 71.4647C206.552 72.3652 207.909 72.4683 208.809 71.695L217.79 63.9829C218.69 63.2095 218.793 61.8526 218.02 60.9521C217.247 60.0516 215.89 59.9485 214.989 60.7218L206.009 68.4339Z",
        fill: "black"
      }), (0, import_jsx_runtime.jsx)("circle", {
        cx: "141.356",
        cy: "19.525",
        r: "10.1855",
        fill: "#FE89B4"
      }), (0, import_jsx_runtime.jsx)("ellipse", {
        cx: "139.062",
        cy: "14.7094",
        rx: "2.42519",
        ry: "1.94015",
        transform: "rotate(-34.544 139.062 14.7094)",
        fill: "#FDF7FF"
      }), (0, import_jsx_runtime.jsx)("circle", {
        cx: "252.489",
        cy: "79.7577",
        r: "7.78893",
        fill: "#EC5236"
      }), (0, import_jsx_runtime.jsx)("ellipse", {
        cx: "250.434",
        cy: "76.3701",
        rx: "2.61272",
        ry: "2.09018",
        transform: "rotate(-34.544 250.434 76.3701)",
        fill: "#EDB69D"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M100.436 79.9254C100.461 79.6567 100.732 79.3897 101.042 79.329L106.657 78.2299C107.587 78.0478 108.281 78.5536 108.207 79.3596L107.759 84.2243C107.734 84.493 107.463 84.76 107.153 84.8207L100.416 86.1396C100.106 86.2003 99.8742 86.0317 99.899 85.7631L100.436 79.9254Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M95.8553 81.7775C95.9294 80.9715 96.7437 80.1704 97.6739 79.9883L98.7968 79.7685C99.1069 79.7078 99.3382 79.8764 99.3135 80.1451L99.1344 82.091C99.1096 82.3597 98.8382 82.6267 98.5282 82.6874L96.2824 83.127C95.9723 83.1877 95.741 83.0191 95.7657 82.7505L95.8553 81.7775Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M95.5865 84.6965C95.6112 84.4278 95.8826 84.1608 96.1927 84.1001L98.4385 83.6605C98.7486 83.5998 98.9799 83.7684 98.9552 84.037L98.7761 85.9829C98.7513 86.2516 98.4799 86.5186 98.1699 86.5793L95.9241 87.019C95.614 87.0797 95.3827 86.9111 95.4074 86.6424L95.5865 84.6965Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M95.2282 88.5884C95.2529 88.3197 95.5244 88.0527 95.8344 87.992L98.0802 87.5524C98.3903 87.4917 98.6216 87.6603 98.5969 87.929L98.4178 89.8749C98.3931 90.1435 98.1216 90.4105 97.8116 90.4712L96.6887 90.6911C95.7584 90.8732 95.0645 90.3674 95.1387 89.5614L95.2282 88.5884Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M99.7197 87.709C99.7444 87.4403 100.016 87.1733 100.326 87.1126L102.572 86.673C102.882 86.6123 103.113 86.7809 103.088 87.0496L102.909 88.9955C102.885 89.2641 102.613 89.5312 102.303 89.5919L100.057 90.0315C99.7472 90.0922 99.5159 89.9236 99.5406 89.6549L99.7197 87.709Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M104.211 86.8298C104.236 86.5611 104.507 86.2941 104.817 86.2334L107.063 85.7938C107.373 85.7331 107.605 85.9017 107.58 86.1704L107.49 87.1433C107.416 87.9493 106.602 88.7504 105.672 88.9325L104.549 89.1523C104.239 89.213 104.007 89.0444 104.032 88.7757L104.211 86.8298Z",
        fill: "#B3AAAA"
      }), (0, import_jsx_runtime.jsx)("defs", {
        children: (0, import_jsx_runtime.jsxs)("linearGradient", Object.assign({
          id: "paint0_linear_3_672",
          x1: "-44.5195",
          y1: "122.42",
          x2: "263.357",
          y2: "-8.65023",
          gradientUnits: "userSpaceOnUse"
        }, {
          children: [(0, import_jsx_runtime.jsx)("stop", {
            offset: "0.110697",
            stopColor: "#232323"
          }), (0, import_jsx_runtime.jsx)("stop", {
            offset: "1",
            stopColor: "#3D3D3D"
          })]
        }))
      })]
    }));
  };
  var UpArrowIcon = () => {
    return (0, import_jsx_runtime.jsx)("svg", Object.assign({
      width: "10",
      height: "7",
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M9 5.4762L5 1.4762L1 5.4762",
        stroke: "#4F7CD1",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })
    }));
  };
  var DownArrowIcon = () => {
    return (0, import_jsx_runtime.jsx)("svg", Object.assign({
      width: "10",
      height: "7",
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, {
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M1 1.52382L5 5.52382L9 1.52382",
        stroke: "#4F7CD1",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })
    }));
  };
  var DEFAULT_DERIVATION_PATH = "44'/397'/0'/0'/1'";
  var DerivationPath = ({
    selector,
    options,
    onBack,
    onConnected,
    params,
    onError,
    onCloseModal
  }) => {
    const [route, setRoute] = (0, import_react.useState)("EnterDerivationPath");
    const [derivationPath, setDerivationPath] = (0, import_react.useState)(DEFAULT_DERIVATION_PATH);
    const [customDerivationPath, setCustomDerivationPath] = (0, import_react.useState)(1);
    const [accounts, setAccounts] = (0, import_react.useState)([]);
    const [selectedAccounts, setSelectedAccounts] = (0, import_react.useState)([]);
    const [hardwareWallet, setHardwareWallet] = (0, import_react.useState)();
    const [customAccountId, setCustomAccountId] = (0, import_react.useState)("");
    const [connecting, setConnecting] = (0, import_react.useState)(false);
    const initalHeaderTitle = translate("modal.ledger.connectWithLedger");
    const [headerTitle, setHeaderTitle] = (0, import_react.useState)(initalHeaderTitle);
    const getAccountIds = (publicKey) => __awaiter2(void 0, void 0, void 0, function* () {
      const response = yield fetch(`${selector.options.network.indexerUrl}/publicKey/ed25519:${publicKey}/accounts`);
      if (!response.ok) {
        throw new Error("Failed to get account id from public key");
      }
      const accountIds = yield response.json();
      if (!Array.isArray(accountIds) || !accountIds.length) {
        return [];
      }
      return accountIds;
    });
    const resolveAccounts = (wallet) => __awaiter2(void 0, void 0, void 0, function* () {
      const publicKey = yield wallet.getPublicKey(derivationPath);
      try {
        const accountIds = yield getAccountIds(publicKey);
        return accountIds.map((accountId, index) => {
          return {
            derivationPath,
            publicKey,
            accountId,
            selected: index === 0
          };
        });
      } catch (e) {
        return null;
      }
    });
    const handleValidateAccount = () => __awaiter2(void 0, void 0, void 0, function* () {
      const wallet = yield selector.wallet(params.walletId);
      if (wallet.type !== "hardware") {
        return;
      }
      setConnecting(true);
      setHardwareWallet(wallet);
      try {
        const resolvedAccounts = yield resolveAccounts(wallet);
        if (!resolvedAccounts) {
          setRoute("AddCustomAccountId");
          return;
        }
        const noAccounts = resolvedAccounts.length === 0;
        const multipleAccounts = resolvedAccounts.length > 1;
        if (noAccounts) {
          setHeaderTitle(translate("modal.ledger.noAccountsFound"));
          setRoute("NoAccountsFound");
          return;
        }
        setAccounts(resolvedAccounts);
        if (!multipleAccounts) {
          setSelectedAccounts(resolvedAccounts);
          setRoute("OverviewAccounts");
        } else {
          setHeaderTitle(translate("modal.ledger.selectYourAccounts"));
          setRoute("ChooseAccount");
        }
      } catch (err) {
        setConnecting(false);
        const message = err && typeof err === "object" && "message" in err ? err.message : "Something went wrong";
        onError(message, wallet);
      } finally {
        setConnecting(false);
      }
    });
    const handleAddCustomAccountId = () => __awaiter2(void 0, void 0, void 0, function* () {
      try {
        setConnecting(true);
        const publicKey = yield hardwareWallet.getPublicKey(derivationPath);
        const accountList = [{
          derivationPath,
          publicKey,
          accountId: customAccountId,
          selected: true
        }];
        setAccounts(accountList);
        setSelectedAccounts(accountList);
        setHeaderTitle(translate("modal.ledger.connecting1Account"));
        setRoute("OverviewAccounts");
      } catch (err) {
        setConnecting(false);
        const message = err && typeof err === "object" && "message" in err ? err.message : "Something went wrong";
        onError(message, hardwareWallet);
      } finally {
        setConnecting(false);
      }
    });
    const handleSignIn = () => {
      const mapAccounts = selectedAccounts.map((account) => {
        return {
          derivationPath: account.derivationPath,
          publicKey: account.publicKey,
          accountId: account.accountId
        };
      });
      return hardwareWallet.signIn({
        contractId: options.contractId,
        methodNames: options.methodNames,
        accounts: mapAccounts
      }).then(() => onConnected()).catch((err) => {
        onError(`Error: ${err.message}`, hardwareWallet);
      });
    };
    const handleOnBackButtonClick = () => {
      if (route === "SpecifyHDPath" || route === "NoAccountsFound" || route === "ChooseAccount") {
        setHeaderTitle(translate("modal.ledger.connectWithLedger"));
        setRoute("EnterDerivationPath");
      }
      if (route === "OverviewAccounts") {
        setHeaderTitle(translate("modal.ledger.selectYourAccounts"));
        setRoute("ChooseAccount");
      }
    };
    if (connecting) {
      return (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "derivation-path-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsx)(WalletConnecting, {
          wallet: hardwareWallet,
          onBack: () => {
            setConnecting(false);
          },
          onCloseModal
        })
      }));
    }
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal-header-wrapper"
      }, {
        children: [(route === "SpecifyHDPath" || route === "NoAccountsFound" || route === "ChooseAccount" || route === "OverviewAccounts") && (0, import_jsx_runtime.jsx)(BackArrow, {
          onClick: handleOnBackButtonClick
        }), (0, import_jsx_runtime.jsx)(ModalHeader, {
          title: headerTitle,
          onCloseModal
        })]
      })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "derivation-path-wrapper"
      }, {
        children: [route === "EnterDerivationPath" && (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "enter-derivation-path"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "ledger-image"
          }, {
            children: (0, import_jsx_runtime.jsx)(LedgerDeviceIcon, {})
          })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "ledger-description"
          }, {
            children: [(0, import_jsx_runtime.jsx)("p", {
              children: translate("modal.ledger.makeSureYourLedger")
            }), (0, import_jsx_runtime.jsx)("p", Object.assign({
              className: "specify-path",
              onClick: () => {
                setHeaderTitle(translate("modal.ledger.specifyHDPath"));
                setRoute("SpecifyHDPath");
              }
            }, {
              children: translate("modal.ledger.specifyHDPath")
            }))]
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "action-buttons"
          }, {
            children: (0, import_jsx_runtime.jsx)("button", Object.assign({
              className: "middleButton",
              onClick: handleValidateAccount
            }, {
              children: translate("modal.ledger.continue")
            }))
          }))]
        })), route === "SpecifyHDPath" && (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "specify-path-wrapper"
        }, {
          children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "change-path-wrapper"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "display-path"
            }, {
              children: (0, import_jsx_runtime.jsx)("span", {
                children: derivationPath.slice(0, -2)
              })
            })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "change-path"
            }, {
              children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
                className: "path-value"
              }, {
                children: (0, import_jsx_runtime.jsx)("span", {
                  children: customDerivationPath
                })
              })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
                className: "buttons-wrapper"
              }, {
                children: [(0, import_jsx_runtime.jsx)("button", Object.assign({
                  onClick: () => {
                    const newValue = customDerivationPath + 1;
                    const path7 = derivationPath.slice(0, -2);
                    setDerivationPath(`${path7}${newValue}'`);
                    setCustomDerivationPath(newValue);
                  }
                }, {
                  children: (0, import_jsx_runtime.jsx)(UpArrowIcon, {})
                })), (0, import_jsx_runtime.jsx)("button", Object.assign({
                  onClick: () => {
                    const newValue = customDerivationPath - 1;
                    if (newValue < 0) {
                      return;
                    }
                    const path7 = derivationPath.slice(0, -2);
                    setDerivationPath(`${path7}${newValue}'`);
                    setCustomDerivationPath(newValue);
                  }
                }, {
                  children: (0, import_jsx_runtime.jsx)(DownArrowIcon, {})
                }))]
              }))]
            }))]
          })), (0, import_jsx_runtime.jsx)("p", Object.assign({
            className: "path-description"
          }, {
            children: translate("modal.ledger.enterYourPreferredHDPath")
          })), (0, import_jsx_runtime.jsx)("p", Object.assign({
            className: "what-link"
          }, {
            children: (0, import_jsx_runtime.jsx)("a", Object.assign({
              href: "https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets",
              target: "_blank"
            }, {
              children: "What's this?"
            }))
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "action-buttons"
          }, {
            children: (0, import_jsx_runtime.jsx)("button", Object.assign({
              className: "middleButton",
              onClick: handleValidateAccount
            }, {
              children: translate("modal.ledger.scan")
            }))
          }))]
        })), route === "NoAccountsFound" && (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "no-accounts-found-wrapper"
        }, {
          children: (0, import_jsx_runtime.jsxs)("p", {
            children: [translate("modal.ledger.cantFindAnyAccount"), " ", (0, import_jsx_runtime.jsx)("a", Object.assign({
              href: `https://${selector.options.network.networkId === "testnet" ? "testnet" : "app"}.mynearwallet.com/create`,
              target: "_blank"
            }, {
              children: "MyNearWallet"
            })), " ", translate("modal.ledger.orConnectAnAnotherLedger")]
          })
        })), route === "ChooseAccount" && (0, import_jsx_runtime.jsx)(HardwareWalletAccountsForm, {
          accounts,
          onSelectedChanged: (index, selected) => {
            setAccounts((prevAccounts) => {
              const updateAccounts = prevAccounts.map((account, idx) => {
                const selectedValue = index === idx ? selected : account.selected;
                return Object.assign(Object.assign({}, account), {
                  selected: selectedValue
                });
              });
              return [...updateAccounts];
            });
          },
          onSubmit: (acc, e) => {
            e.preventDefault();
            const selectedAcc = acc.filter((account) => account.selected);
            setSelectedAccounts(selectedAcc);
            const numberOfAccounts = selectedAcc.length;
            setHeaderTitle(`${translate("modal.ledger.connecting")} ${numberOfAccounts} ${translate("modal.ledger.ofAccounts")}`);
            setRoute("OverviewAccounts");
          },
          onChangeRoute: (newRoute) => {
            if (newRoute === "SpecifyHDPath") {
              setHeaderTitle(translate("modal.ledger.specifyHDPath"));
            }
            setRoute(newRoute);
          }
        }), route === "AddCustomAccountId" && (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "enter-custom-account"
        }, {
          children: [(0, import_jsx_runtime.jsx)("p", {
            children: translate("modal.ledger.failedToAutomatically")
          }), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "input-wrapper"
          }, {
            children: (0, import_jsx_runtime.jsx)("input", {
              type: "text",
              placeholder: "Account ID",
              value: customAccountId,
              onChange: (e) => {
                setCustomAccountId(e.target.value);
              }
            })
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "action-buttons"
          }, {
            children: (0, import_jsx_runtime.jsx)("button", Object.assign({
              className: "middleButton",
              onClick: handleAddCustomAccountId
            }, {
              children: translate("ledger.Continue")
            }))
          }))]
        })), route === "OverviewAccounts" && (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "overview-wrapper"
        }, {
          children: [(0, import_jsx_runtime.jsx)("p", {
            children: translate("modal.ledger.overviewTheListOfAuthorized")
          }), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "accounts"
          }, {
            children: selectedAccounts.map((account, index) => (0, import_jsx_runtime.jsx)("div", {
              children: (0, import_jsx_runtime.jsx)("div", Object.assign({
                className: "account"
              }, {
                children: (0, import_jsx_runtime.jsx)("span", {
                  children: account.accountId
                })
              }))
            }, account.accountId))
          })), (0, import_jsx_runtime.jsx)("div", Object.assign({
            className: "action-buttons"
          }, {
            children: (0, import_jsx_runtime.jsx)("button", Object.assign({
              className: "middleButton",
              onClick: handleSignIn,
              disabled: accounts.length === 0
            }, {
              children: translate("modal.ledger.finish")
            }))
          }))]
        }))]
      }))]
    });
  };
  var WalletNotInstalled = ({
    module: module2,
    onBack,
    onCloseModal
  }) => {
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal-header-wrapper"
      }, {
        children: [(0, import_jsx_runtime.jsx)(BackArrow, {
          onClick: onBack
        }), (0, import_jsx_runtime.jsx)(ModalHeader, {
          title: "",
          onCloseModal
        })]
      })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "wallet-not-installed-wrapper"
      }, {
        children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "wallet-data"
        }, {
          children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
            className: `wallet-icon-box ${module2.id}`
          }, {
            children: (0, import_jsx_runtime.jsx)("img", {
              src: module2.metadata.iconUrl,
              alt: module2.metadata.name
            })
          })), (0, import_jsx_runtime.jsx)("p", {
            children: module2.metadata.name
          })]
        })), (0, import_jsx_runtime.jsxs)("p", {
          children: [translate("modal.install.youllNeedToInstall"), " ", module2.metadata.name, " ", translate("modal.install.toContinueAfterInstalling"), (0, import_jsx_runtime.jsxs)("span", Object.assign({
            className: "refresh-link",
            onClick: () => window.location.reload()
          }, {
            children: [" ", translate("modal.install.refreshThePage")]
          }))]
        }), (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "action-buttons"
        }, {
          children: (0, import_jsx_runtime.jsxs)("button", Object.assign({
            className: "middleButton",
            onClick: () => {
              if (module2.type !== "injected") {
                return;
              }
              window.open(module2.metadata.downloadUrl, "_blank");
            }
          }, {
            children: [translate("modal.install.open"), " ", module2.metadata.name]
          }))
        }))]
      }))]
    });
  };
  var QRIcon = () => (0, import_jsx_runtime.jsxs)("svg", Object.assign({
    width: "18",
    height: "16",
    viewBox: "0 0 18 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, {
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7.22224 1.33334H1.44446V6.66668H7.22224V1.33334Z",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15.8889 1.33334H10.1111V6.66668H15.8889V1.33334Z",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.22224 9.33334H1.44446V14.6667H7.22224V9.33334Z",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.1111 13.1429V14.6667H15.8889M10.1111 9.33334V10.8572H12.5873V9.33334H15.8889V12.381",
      stroke: "#4C5155",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("rect", {
      x: "3.61108",
      y: "3.33334",
      width: "1.44444",
      height: "1.33333",
      fill: "#4C5155"
    }), (0, import_jsx_runtime.jsx)("rect", {
      x: "3.61108",
      y: "11.3333",
      width: "1.44444",
      height: "1.33333",
      fill: "#4C5155"
    }), (0, import_jsx_runtime.jsx)("rect", {
      x: "12.2778",
      y: "3.33334",
      width: "1.44445",
      height: "1.33333",
      fill: "#4C5155"
    })]
  }));
  var LinkIcon = () => (0, import_jsx_runtime.jsxs)("svg", Object.assign({
    width: "18",
    height: "16",
    viewBox: "0 0 18 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, {
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M13 8.66667V12.6667C13 13.0203 12.8478 13.3594 12.577 13.6095C12.3061 13.8595 11.9387 14 11.5556 14H3.61113C3.22804 14 2.86064 13.8595 2.58975 13.6095C2.31887 13.3594 2.16669 13.0203 2.16669 12.6667V5.33333C2.16669 4.97971 2.31887 4.64057 2.58975 4.39052C2.86064 4.14048 3.22804 4 3.61113 4H7.94447",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.8333 2H15.1666V6",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.22223 9.33333L15.1667 2",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  }));
  var KeyIcon = () => (0, import_jsx_runtime.jsx)("svg", Object.assign({
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, {
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658",
      stroke: "currentColor",
      strokeWidth: "3",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  }));
  var FolderIcon = () => (0, import_jsx_runtime.jsxs)("svg", Object.assign({
    width: "40",
    height: "41",
    viewBox: "0 0 40 41",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, {
    children: [(0, import_jsx_runtime.jsx)("circle", {
      cx: "28.3333",
      cy: "23.8333",
      r: "1.66667",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667",
      stroke: "currentColor",
      strokeWidth: "3",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334",
      stroke: "currentColor",
      strokeWidth: "3",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  }));
  var WalletHome = ({
    selector,
    onCloseModal
  }) => {
    const [modules, setModules] = (0, import_react.useState)([]);
    const [route, setRoute] = (0, import_react.useState)("WalletInfo");
    (0, import_react.useEffect)(() => {
      const subscription = selector.store.observable.subscribe((state) => {
        const filterByType = (item) => {
          return item.type !== "bridge" && item.type !== "hardware" && item.type !== "instant-link";
        };
        const filteredModules = state.modules.filter(filterByType);
        setModules(filteredModules);
      });
      return () => subscription.unsubscribe();
    }, []);
    const getWalletUrl = (module2) => {
      let url = "";
      if (module2.type === "injected") {
        url = module2.metadata.downloadUrl;
      }
      if (module2.type === "browser") {
        url = module2.metadata.walletUrl;
      }
      return url;
    };
    return (0, import_jsx_runtime.jsxs)("div", Object.assign({
      className: "wallet-home-wrapper"
    }, {
      children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal-header-wrapper"
      }, {
        children: [route === "GetWallets" && (0, import_jsx_runtime.jsx)(BackArrow, {
          onClick: () => {
            setRoute("WalletInfo");
          }
        }), (0, import_jsx_runtime.jsx)(ModalHeader, {
          title: route === "GetWallets" ? translate("modal.wallet.getAWallet") : translate("modal.wallet.whatIsAWallet"),
          onCloseModal
        })]
      })), route === "GetWallets" && (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "get-wallet-wrapper"
      }, {
        children: modules.map((module2) => {
          const {
            iconUrl,
            name
          } = module2.metadata;
          const qrIcon = ["nearfi", "here-wallet"].includes(module2.id);
          const hereWalletType = module2.id === "here-wallet" ? "mobile" : "";
          const walletUrl = getWalletUrl(module2);
          return (0, import_jsx_runtime.jsxs)("div", Object.assign({
            tabIndex: 0,
            className: `single-wallet-get ${module2.id}`,
            onClick: () => {
              if (walletUrl) {
                window.open(walletUrl, "_blank");
              }
            }
          }, {
            children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "small-icon"
            }, {
              children: [qrIcon && walletUrl && (0, import_jsx_runtime.jsx)(QRIcon, {}), !qrIcon && walletUrl && (0, import_jsx_runtime.jsx)(LinkIcon, {})]
            })), (0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "icon"
            }, {
              children: (0, import_jsx_runtime.jsx)("img", {
                src: iconUrl,
                alt: name
              })
            })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "content"
            }, {
              children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
                className: "title"
              }, {
                children: name
              })), (0, import_jsx_runtime.jsx)("div", Object.assign({
                className: "type"
              }, {
                children: translate(`modal.walletTypes.${hereWalletType || module2.type}`)
              }))]
            }))]
          }), module2.id);
        })
      })), route === "WalletInfo" && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "wallet-info-wrapper what-wallet-hide"
        }, {
          children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "wallet-what"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "icon-side"
            }, {
              children: (0, import_jsx_runtime.jsx)(KeyIcon, {})
            })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "content-side"
            }, {
              children: [(0, import_jsx_runtime.jsx)("h3", {
                children: translate("modal.wallet.secureAndManage")
              }), (0, import_jsx_runtime.jsx)("p", {
                children: translate("modal.wallet.safelyStore")
              })]
            }))]
          })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "wallet-what"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", Object.assign({
              className: "icon-side"
            }, {
              children: (0, import_jsx_runtime.jsx)(FolderIcon, {})
            })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
              className: "content-side"
            }, {
              children: [(0, import_jsx_runtime.jsx)("h3", {
                children: translate("modal.wallet.logInToAny")
              }), (0, import_jsx_runtime.jsx)("p", {
                children: translate("modal.wallet.noNeedToCreate")
              })]
            }))]
          })), (0, import_jsx_runtime.jsx)("div", {
            className: "button-spacing"
          }), (0, import_jsx_runtime.jsx)("button", Object.assign({
            className: "middleButton",
            onClick: () => {
              setRoute("GetWallets");
            }
          }, {
            children: translate("modal.wallet.getAWallet")
          }))]
        })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "what-wallet-mobile"
        }, {
          children: [(0, import_jsx_runtime.jsx)("p", {
            children: translate("modal.wallet.useAWallet")
          }), (0, import_jsx_runtime.jsx)("button", Object.assign({
            className: "middleButton",
            onClick: () => {
              setRoute("GetWallets");
            }
          }, {
            children: translate("modal.wallet.getAWallet")
          }))]
        })), (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "lang-selector-wrapper"
        }, {
          children: (0, import_jsx_runtime.jsxs)("select", Object.assign({
            className: "lang-selector",
            name: "lang"
          }, {
            children: [(0, import_jsx_runtime.jsx)("option", Object.assign({
              value: "en"
            }, {
              children: "English"
            })), (0, import_jsx_runtime.jsx)("option", Object.assign({
              value: "es"
            }, {
              children: "Spanish"
            }))]
          }))
        }))]
      })]
    }));
  };
  var WalletConnected = ({
    module: module2,
    onCloseModal
  }) => {
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal-header"
      }, {
        children: [(0, import_jsx_runtime.jsx)("h3", Object.assign({
          className: "middleTitle"
        }, {
          children: ``
        })), (0, import_jsx_runtime.jsx)(CloseButton, {
          onClick: onCloseModal
        })]
      })), (0, import_jsx_runtime.jsx)("div", Object.assign({
        className: "connecting-wrapper"
      }, {
        children: (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "content"
        }, {
          children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "icon"
          }, {
            children: [(0, import_jsx_runtime.jsx)("div", {
              className: "green-dot"
            }), (0, import_jsx_runtime.jsx)("img", {
              src: module2 === null || module2 === void 0 ? void 0 : module2.metadata.iconUrl,
              alt: module2 === null || module2 === void 0 ? void 0 : module2.metadata.name
            })]
          })), (0, import_jsx_runtime.jsx)("h3", Object.assign({
            className: "connecting-name"
          }, {
            children: module2 === null || module2 === void 0 ? void 0 : module2.metadata.name
          })), (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "wallet-connected-success"
          }, {
            children: [(0, import_jsx_runtime.jsx)(ConnectionSuccessIcon, {}), (0, import_jsx_runtime.jsx)("span", {
              children: translate("modal.wallet.connectionSuccessful")
            })]
          }))]
        }))
      }))]
    });
  };
  var anObject$12 = anObject$b2;
  var regexpFlags2 = function() {
    var that = anObject$12(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var redefine2 = redefine$52.exports;
  var anObject2 = anObject$b2;
  var fails2 = fails$c2;
  var flags = regexpFlags2;
  var TO_STRING = "toString";
  var RegExpPrototype = RegExp.prototype;
  var nativeToString = RegExpPrototype[TO_STRING];
  var NOT_GENERIC = fails2(function() {
    return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
  });
  var INCORRECT_NAME = nativeToString.name != TO_STRING;
  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine2(RegExp.prototype, TO_STRING, function toString18() {
      var R = anObject2(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
      return "/" + p + "/" + f;
    }, { unsafe: true });
  }
  var CopyIcon = () => (0, import_jsx_runtime.jsxs)("svg", Object.assign({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, {
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 15.25a1.75 1.75 0 0 1-1.75-1.75V6.75a2 2 0 0 1 2-2h6.75c.966 0 1.75.784 1.75 1.75",
      stroke: "#4F7CD1",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M8.75 10.75a2 2 0 0 1 2-2h6.5a2 2 0 0 1 2 2v6.5a2 2 0 0 1-2 2h-6.5a2 2 0 0 1-2-2v-6.5Z",
      stroke: "#4F7CD1",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  }));
  function formatQRCodeImage(data7) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield import_qrcode.default.toString(data7, {
        margin: 0,
        type: "svg"
      });
    });
  }
  var ScanQRCode = ({
    wallet,
    uri,
    onCloseModal,
    handleOpenDefaultModal
  }) => {
    const [notification, setNotification] = import_react.default.useState("");
    const [svg, setSvg] = import_react.default.useState("");
    const copyToClipboard = () => {
      if (!uri) {
        return;
      }
      const success = (0, import_copy_to_clipboard.default)(uri);
      if (success) {
        setNotification(translate("modal.qr.copiedToClipboard"));
        setTimeout(() => setNotification(""), 1200);
      } else {
        setNotification(translate("modal.qr.failedToCopy"));
        setTimeout(() => setNotification(""), 1200);
      }
    };
    import_react.default.useEffect(() => {
      (() => __awaiter2(void 0, void 0, void 0, function* () {
        if (uri) {
          setSvg(yield formatQRCodeImage(uri));
        }
      }))();
    }, [uri]);
    return (0, import_jsx_runtime.jsxs)("section", Object.assign({
      className: "scan-qr-code"
    }, {
      children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
        title: translate("modal.qr.scanWithYourMobile"),
        onCloseModal
      }), (0, import_jsx_runtime.jsxs)("section", Object.assign({
        className: "qr-code"
      }, {
        children: [(0, import_jsx_runtime.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: svg
          }
        }), notification ? (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "notification"
        }, {
          children: notification
        })) : (0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "copy-btn",
          onClick: copyToClipboard
        }, {
          children: [(0, import_jsx_runtime.jsx)(CopyIcon, {}), translate("modal.qr.copyToClipboard")]
        }))]
      })), (0, import_jsx_runtime.jsxs)("footer", Object.assign({
        className: "footer"
      }, {
        children: [(0, import_jsx_runtime.jsxs)("p", {
          children: [translate("modal.qr.preferTheOfficial"), " ", wallet.metadata.name, "?"]
        }), (0, import_jsx_runtime.jsx)("button", Object.assign({
          className: "btn",
          onClick: handleOpenDefaultModal
        }, {
          children: translate("modal.qr.open")
        }))]
      }))]
    }));
  };
  var getThemeClass = (theme) => {
    switch (theme) {
      case "dark":
        return "dark-theme";
      case "light":
        return "light-theme";
      default:
        return "";
    }
  };
  var Modal = ({
    selector,
    options,
    visible,
    hide,
    emitter
  }) => {
    var _a, _b, _c;
    const [route, setRoute] = (0, import_react.useState)({
      name: "WalletHome"
    });
    const [alertMessage, setAlertMessage] = (0, import_react.useState)(null);
    const [selectedWallet, setSelectedWallet] = (0, import_react.useState)();
    const [bridgeWalletUri, setBridgeWalletUri] = (0, import_react.useState)();
    const {
      rememberRecentWallets
    } = selector.store.getState();
    const [isChecked, setIsChecked] = (0, import_react.useState)(rememberRecentWallets === "enabled");
    const handleSwitchChange = () => {
      setIsChecked((prevIsChecked) => !prevIsChecked);
      selector.setRememberRecentWallets();
    };
    (0, import_react.useEffect)(() => {
      setRoute({
        name: "WalletHome"
      });
      allowOnlyLanguage(selector.options.languageCode);
      const {
        selectedWalletId,
        modules
      } = selector.store.getState();
      if (selectedWalletId) {
        const module2 = modules.find((m) => m.id === selectedWalletId);
        setSelectedWallet(module2);
        setRoute({
          name: "WalletConnected",
          params: {
            module: module2
          }
        });
      }
      setBridgeWalletUri("");
    }, [visible]);
    (0, import_react.useEffect)(() => {
      const subscription = selector.on("networkChanged", ({
        networkId
      }) => {
        if (networkId === selector.options.network.networkId) {
          return handleDismissClick({});
        }
        setRoute({
          name: "WalletNetworkChanged"
        });
      });
      return () => subscription.remove();
    }, []);
    const handleDismissClick = (0, import_react.useCallback)(({
      hideReason
    }) => {
      setAlertMessage(null);
      setRoute({
        name: "WalletHome"
      });
      if (hideReason === "user-triggered") {
        emitter.emit("onHide", {
          hideReason
        });
      }
      if (hideReason === "wallet-navigation") {
        emitter.emit("onHide", {
          hideReason
        });
      }
      hide();
    }, [hide, emitter]);
    (0, import_react.useEffect)(() => {
      const close = (e) => {
        if (e.key === "Escape") {
          handleDismissClick({
            hideReason: "user-triggered"
          });
        }
      };
      window.addEventListener("keydown", close);
      return () => window.removeEventListener("keydown", close);
    }, [handleDismissClick]);
    const handleWalletClick = (module2, qrCodeModal) => __awaiter2(void 0, void 0, void 0, function* () {
      setSelectedWallet(module2);
      const {
        selectedWalletId
      } = selector.store.getState();
      if (selectedWalletId === module2.id) {
        setRoute({
          name: "WalletConnected",
          params: {
            module: module2
          }
        });
        return;
      }
      try {
        const {
          deprecated,
          available
        } = module2.metadata;
        if (module2.type === "injected" && !available) {
          setRoute({
            name: "WalletNotInstalled",
            params: {
              module: module2
            }
          });
          return;
        }
        const wallet = yield module2.wallet();
        if (deprecated) {
          setAlertMessage(`${module2.metadata.name} is deprecated. Please select another wallet.`);
          setRoute({
            name: "AlertMessage",
            params: {
              module: module2
            }
          });
          return;
        }
        if (wallet.type === "hardware") {
          setRoute({
            name: "DerivationPath",
            params: {
              walletId: wallet.id || "ledger"
            }
          });
          return;
        }
        setRoute({
          name: "WalletConnecting",
          params: {
            wallet
          }
        });
        if (wallet.type === "bridge") {
          const subscription = selector.on("uriChanged", ({
            uri
          }) => {
            setBridgeWalletUri(uri);
            setRoute({
              name: "ScanQRCode",
              params: {
                uri,
                wallet
              }
            });
          });
          yield wallet.signIn({
            contractId: options.contractId,
            methodNames: options.methodNames,
            qrCodeModal
          });
          subscription.remove();
          handleDismissClick({
            hideReason: "wallet-navigation"
          });
          return;
        }
        if (wallet.type === "browser") {
          yield wallet.signIn({
            contractId: options.contractId,
            methodNames: options.methodNames,
            successUrl: wallet.metadata.successUrl,
            failureUrl: wallet.metadata.failureUrl
          });
          handleDismissClick({
            hideReason: "wallet-navigation"
          });
          return;
        }
        yield wallet.signIn({
          contractId: options.contractId,
          methodNames: options.methodNames
        });
        handleDismissClick({
          hideReason: "wallet-navigation"
        });
      } catch (err) {
        const {
          name
        } = module2.metadata;
        const message = err && typeof err === "object" && "message" in err ? err.message : "Something went wrong";
        setAlertMessage(`Failed to sign in with ${name}: ${message}`);
        setRoute({
          name: "AlertMessage",
          params: {
            module: module2
          }
        });
      }
    });
    if (!visible) {
      return null;
    }
    return (0, import_jsx_runtime.jsxs)("div", Object.assign({
      className: `nws-modal-wrapper ${getThemeClass(options === null || options === void 0 ? void 0 : options.theme)} ${visible ? "open" : ""}`
    }, {
      children: [(0, import_jsx_runtime.jsx)("div", {
        className: "nws-modal-overlay",
        onClick: () => {
          handleDismissClick({
            hideReason: "user-triggered"
          });
        }
      }), (0, import_jsx_runtime.jsxs)("div", Object.assign({
        className: "nws-modal"
      }, {
        children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
          className: "modal-left"
        }, {
          children: [(0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "modal-left-title"
          }, {
            children: [(0, import_jsx_runtime.jsx)("h2", {
              children: translate("modal.wallet.connectYourWallet")
            }), (0, import_jsx_runtime.jsx)("span", Object.assign({
              className: "nws-remember-wallet"
            }, {
              children: translate("modal.wallet.rememberWallet")
            })), (0, import_jsx_runtime.jsxs)("label", Object.assign({
              className: "nws-switch"
            }, {
              children: [(0, import_jsx_runtime.jsx)("input", {
                type: "checkbox",
                checked: isChecked,
                onChange: handleSwitchChange
              }), (0, import_jsx_runtime.jsx)("span", {
                className: "nws-slider round"
              })]
            }))]
          })), (0, import_jsx_runtime.jsx)(WalletOptions, {
            handleWalletClick: (module2) => {
              handleWalletClick(module2, false);
            },
            selector
          })]
        })), (0, import_jsx_runtime.jsx)("div", Object.assign({
          className: "modal-right"
        }, {
          children: (0, import_jsx_runtime.jsxs)("div", Object.assign({
            className: "nws-modal-body"
          }, {
            children: [route.name === "AlertMessage" && alertMessage && (0, import_jsx_runtime.jsx)(AlertMessage, {
              message: alertMessage,
              module: (_a = route.params) === null || _a === void 0 ? void 0 : _a.module,
              onBack: (retry) => {
                if (retry) {
                  handleWalletClick(selectedWallet, false);
                }
                setAlertMessage(null);
                setRoute({
                  name: "WalletHome"
                });
              },
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "DerivationPath" && (0, import_jsx_runtime.jsx)(DerivationPath, {
              selector,
              options,
              onConnected: () => {
                handleDismissClick({
                  hideReason: "wallet-navigation"
                });
              },
              params: route.params,
              onBack: () => setRoute({
                name: "WalletHome"
              }),
              onError: (message, wallet) => {
                const {
                  modules
                } = selector.store.getState();
                const findModule = modules.find((module2) => module2.id === wallet.id);
                setAlertMessage(message);
                setRoute({
                  name: "AlertMessage",
                  params: {
                    module: findModule
                  }
                });
              },
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "WalletNetworkChanged" && (0, import_jsx_runtime.jsx)(WalletNetworkChanged, {
              selector,
              onBack: () => setRoute({
                name: "WalletHome"
              }),
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "WalletNotInstalled" && (0, import_jsx_runtime.jsx)(WalletNotInstalled, {
              module: (_b = route.params) === null || _b === void 0 ? void 0 : _b.module,
              onBack: () => {
                setRoute({
                  name: "WalletHome"
                });
              },
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "WalletConnecting" && (0, import_jsx_runtime.jsx)(WalletConnecting, {
              wallet: (_c = route.params) === null || _c === void 0 ? void 0 : _c.wallet,
              onBack: () => {
                setRoute({
                  name: "WalletHome"
                });
              },
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "WalletHome" && (0, import_jsx_runtime.jsx)(WalletHome, {
              selector,
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "WalletConnected" && (0, import_jsx_runtime.jsx)(WalletConnected, {
              module: selectedWallet,
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              })
            }), route.name === "ScanQRCode" && (0, import_jsx_runtime.jsx)(ScanQRCode, {
              handleOpenDefaultModal: () => {
                handleWalletClick(selectedWallet, true);
              },
              onCloseModal: () => handleDismissClick({
                hideReason: "user-triggered"
              }),
              uri: bridgeWalletUri,
              wallet: selectedWallet
            })]
          }))
        }))]
      }))]
    }));
  };
  var MODAL_ELEMENT_ID = "near-wallet-selector-modal";
  var modalInstance = null;
  var root2 = null;
  var setupModal = (selector, options) => {
    if (!root2) {
      const body = document.body;
      const container = document.createElement("div");
      container.id = MODAL_ELEMENT_ID;
      body.appendChild(container);
      root2 = (0, import_client.createRoot)(container);
    }
    const emitter = new EventEmitter2();
    selector.store.getState().modules.forEach((module2) => __awaiter2(void 0, void 0, void 0, function* () {
      if ("topLevelInjected" in module2.metadata) {
        if (!module2.metadata.topLevelInjected) {
          return;
        }
        const wallet = yield module2.wallet();
        if (wallet.type !== "injected") {
          return;
        }
        yield wallet.signIn({
          contractId: options.contractId,
          methodNames: options.methodNames
        });
      }
    }));
    const render = (visible = false) => {
      root2.render((0, import_jsx_runtime.jsx)(Modal, {
        selector,
        options,
        visible,
        hide: () => render(false),
        emitter
      }));
    };
    if (!modalInstance) {
      modalInstance = {
        show: () => {
          render(true);
        },
        hide: () => {
          render(false);
        },
        on: (eventName, callback) => {
          return emitter.on(eventName, callback);
        },
        off: (eventName, callback) => {
          emitter.off(eventName, callback);
        }
      };
    }
    return modalInstance;
  };

  // node_modules/@near-wallet-selector/my-near-wallet/index.js
  init_process();
  init_buffer();
  var nearAPI3 = __toESM(require_browser_index2(), 1);

  // node_modules/@near-wallet-selector/wallet-utils/index.js
  init_process();
  init_buffer();
  var nearAPI2 = __toESM(require_browser_index2(), 1);
  var {
    transactions: transactions2,
    utils: utils3
  } = nearAPI2;
  var getAccessKey = (permission) => {
    if (permission === "FullAccess") {
      return transactions2.fullAccessKey();
    }
    const {
      receiverId,
      methodNames = []
    } = permission;
    const allowance = permission.allowance ? BigInt(permission.allowance) : void 0;
    return transactions2.functionCallAccessKey(receiverId, methodNames, allowance);
  };
  var createAction = (action) => {
    switch (action.type) {
      case "CreateAccount":
        return transactions2.createAccount();
      case "DeployContract": {
        const {
          code
        } = action.params;
        return transactions2.deployContract(code);
      }
      case "FunctionCall": {
        const {
          methodName,
          args,
          gas,
          deposit
        } = action.params;
        return transactions2.functionCall(methodName, args, BigInt(gas), BigInt(deposit));
      }
      case "Transfer": {
        const {
          deposit
        } = action.params;
        return transactions2.transfer(BigInt(deposit));
      }
      case "Stake": {
        const {
          stake,
          publicKey
        } = action.params;
        return transactions2.stake(BigInt(stake), utils3.PublicKey.from(publicKey));
      }
      case "AddKey": {
        const {
          publicKey,
          accessKey
        } = action.params;
        return transactions2.addKey(
          utils3.PublicKey.from(publicKey),
          // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
          getAccessKey(accessKey.permission)
        );
      }
      case "DeleteKey": {
        const {
          publicKey
        } = action.params;
        return transactions2.deleteKey(utils3.PublicKey.from(publicKey));
      }
      case "DeleteAccount": {
        const {
          beneficiaryId
        } = action.params;
        return transactions2.deleteAccount(beneficiaryId);
      }
      default:
        throw new Error("Invalid action type");
    }
  };
  var commonjsGlobal3 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var fails$83 = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var toString8 = {}.toString;
  var classofRaw$13 = function(it) {
    return toString8.call(it).slice(8, -1);
  };
  var fails$73 = fails$83;
  var classof$53 = classofRaw$13;
  var split3 = "".split;
  var indexedObject3 = fails$73(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$53(it) == "String" ? split3.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$23 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject3 = indexedObject3;
  var requireObjectCoercible$13 = requireObjectCoercible$23;
  var toIndexedObject$43 = function(it) {
    return IndexedObject3(requireObjectCoercible$13(it));
  };
  var check3 = function(it) {
    return it && it.Math == Math && it;
  };
  var global$i3 = (
    // eslint-disable-next-line no-undef
    check3(typeof globalThis == "object" && globalThis) || check3(typeof window == "object" && window) || check3(typeof self == "object" && self) || check3(typeof commonjsGlobal3 == "object" && commonjsGlobal3) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var shared$23 = { exports: {} };
  var fails$63 = fails$83;
  var descriptors3 = !fails$63(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectDefineProperty3 = {};
  var isObject$73 = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var global$h3 = global$i3;
  var isObject$63 = isObject$73;
  var document$23 = global$h3.document;
  var EXISTS3 = isObject$63(document$23) && isObject$63(document$23.createElement);
  var documentCreateElement$13 = function(it) {
    return EXISTS3 ? document$23.createElement(it) : {};
  };
  var DESCRIPTORS$53 = descriptors3;
  var fails$53 = fails$83;
  var createElement$13 = documentCreateElement$13;
  var ie8DomDefine3 = !DESCRIPTORS$53 && !fails$53(function() {
    return Object.defineProperty(createElement$13("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var isObject$53 = isObject$73;
  var anObject$b3 = function(it) {
    if (!isObject$53(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var isObject$43 = isObject$73;
  var toPrimitive$23 = function(input, PREFERRED_STRING) {
    if (!isObject$43(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$43(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$43(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$43(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var DESCRIPTORS$43 = descriptors3;
  var IE8_DOM_DEFINE$13 = ie8DomDefine3;
  var anObject$a3 = anObject$b3;
  var toPrimitive$13 = toPrimitive$23;
  var nativeDefineProperty3 = Object.defineProperty;
  objectDefineProperty3.f = DESCRIPTORS$43 ? nativeDefineProperty3 : function defineProperty6(O, P, Attributes) {
    anObject$a3(O);
    P = toPrimitive$13(P, true);
    anObject$a3(Attributes);
    if (IE8_DOM_DEFINE$13) try {
      return nativeDefineProperty3(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var createPropertyDescriptor$33 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var DESCRIPTORS$33 = descriptors3;
  var definePropertyModule$43 = objectDefineProperty3;
  var createPropertyDescriptor$23 = createPropertyDescriptor$33;
  var createNonEnumerableProperty$73 = DESCRIPTORS$33 ? function(object, key, value) {
    return definePropertyModule$43.f(object, key, createPropertyDescriptor$23(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var global$g3 = global$i3;
  var createNonEnumerableProperty$63 = createNonEnumerableProperty$73;
  var setGlobal$33 = function(key, value) {
    try {
      createNonEnumerableProperty$63(global$g3, key, value);
    } catch (error2) {
      global$g3[key] = value;
    }
    return value;
  };
  var global$f3 = global$i3;
  var setGlobal$23 = setGlobal$33;
  var SHARED3 = "__core-js_shared__";
  var store$33 = global$f3[SHARED3] || setGlobal$23(SHARED3, {});
  var sharedStore3 = store$33;
  var store$23 = sharedStore3;
  (shared$23.exports = function(key, value) {
    return store$23[key] || (store$23[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var hasOwnProperty5 = {}.hasOwnProperty;
  var has$93 = function(it, key) {
    return hasOwnProperty5.call(it, key);
  };
  var id3 = 0;
  var postfix3 = Math.random();
  var uid$23 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id3 + postfix3).toString(36);
  };
  var fails$43 = fails$83;
  var nativeSymbol3 = !!Object.getOwnPropertySymbols && !fails$43(function() {
    return !String(Symbol());
  });
  var NATIVE_SYMBOL$13 = nativeSymbol3;
  var useSymbolAsUid3 = NATIVE_SYMBOL$13 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var global$e3 = global$i3;
  var shared$13 = shared$23.exports;
  var has$83 = has$93;
  var uid$13 = uid$23;
  var NATIVE_SYMBOL3 = nativeSymbol3;
  var USE_SYMBOL_AS_UID3 = useSymbolAsUid3;
  var WellKnownSymbolsStore3 = shared$13("wks");
  var Symbol$13 = global$e3.Symbol;
  var createWellKnownSymbol3 = USE_SYMBOL_AS_UID3 ? Symbol$13 : Symbol$13 && Symbol$13.withoutSetter || uid$13;
  var wellKnownSymbol$d3 = function(name) {
    if (!has$83(WellKnownSymbolsStore3, name)) {
      if (NATIVE_SYMBOL3 && has$83(Symbol$13, name)) WellKnownSymbolsStore3[name] = Symbol$13[name];
      else WellKnownSymbolsStore3[name] = createWellKnownSymbol3("Symbol." + name);
    }
    return WellKnownSymbolsStore3[name];
  };
  var ceil3 = Math.ceil;
  var floor4 = Math.floor;
  var toInteger$23 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor4 : ceil3)(argument);
  };
  var toInteger$13 = toInteger$23;
  var min$13 = Math.min;
  var toLength$23 = function(argument) {
    return argument > 0 ? min$13(toInteger$13(argument), 9007199254740991) : 0;
  };
  var toInteger3 = toInteger$23;
  var max3 = Math.max;
  var min3 = Math.min;
  var toAbsoluteIndex$13 = function(index, length) {
    var integer = toInteger3(index);
    return integer < 0 ? max3(integer + length, 0) : min3(integer, length);
  };
  var toIndexedObject$33 = toIndexedObject$43;
  var toLength$13 = toLength$23;
  var toAbsoluteIndex3 = toAbsoluteIndex$13;
  var createMethod4 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$33($this);
      var length = toLength$13(O.length);
      var index = toAbsoluteIndex3(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes3 = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod4(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod4(false)
  };
  var hiddenKeys$43 = {};
  var has$73 = has$93;
  var toIndexedObject$23 = toIndexedObject$43;
  var indexOf6 = arrayIncludes3.indexOf;
  var hiddenKeys$33 = hiddenKeys$43;
  var objectKeysInternal3 = function(object, names) {
    var O = toIndexedObject$23(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$73(hiddenKeys$33, key) && has$73(O, key) && result.push(key);
    while (names.length > i) if (has$73(O, key = names[i++])) {
      ~indexOf6(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$33 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$13 = objectKeysInternal3;
  var enumBugKeys$23 = enumBugKeys$33;
  var objectKeys$13 = Object.keys || function keys5(O) {
    return internalObjectKeys$13(O, enumBugKeys$23);
  };
  var DESCRIPTORS$23 = descriptors3;
  var definePropertyModule$33 = objectDefineProperty3;
  var anObject$93 = anObject$b3;
  var objectKeys4 = objectKeys$13;
  var objectDefineProperties3 = DESCRIPTORS$23 ? Object.defineProperties : function defineProperties5(O, Properties) {
    anObject$93(O);
    var keys14 = objectKeys4(Properties);
    var length = keys14.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$33.f(O, key = keys14[index++], Properties[key]);
    return O;
  };
  var global$d3 = global$i3;
  var path$13 = global$d3;
  var path3 = path$13;
  var global$c3 = global$i3;
  var aFunction$53 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$53 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction$53(path3[namespace]) || aFunction$53(global$c3[namespace]) : path3[namespace] && path3[namespace][method2] || global$c3[namespace] && global$c3[namespace][method2];
  };
  var getBuiltIn$43 = getBuiltIn$53;
  var html$23 = getBuiltIn$43("document", "documentElement");
  var shared3 = shared$23.exports;
  var uid3 = uid$23;
  var keys6 = shared3("keys");
  var sharedKey$33 = function(key) {
    return keys6[key] || (keys6[key] = uid3(key));
  };
  var anObject$83 = anObject$b3;
  var defineProperties6 = objectDefineProperties3;
  var enumBugKeys$13 = enumBugKeys$33;
  var hiddenKeys$23 = hiddenKeys$43;
  var html$13 = html$23;
  var documentCreateElement3 = documentCreateElement$13;
  var sharedKey$23 = sharedKey$33;
  var GT3 = ">";
  var LT3 = "<";
  var PROTOTYPE3 = "prototype";
  var SCRIPT3 = "script";
  var IE_PROTO$13 = sharedKey$23("IE_PROTO");
  var EmptyConstructor3 = function() {
  };
  var scriptTag3 = function(content) {
    return LT3 + SCRIPT3 + GT3 + content + LT3 + "/" + SCRIPT3 + GT3;
  };
  var NullProtoObjectViaActiveX3 = function(activeXDocument5) {
    activeXDocument5.write(scriptTag3(""));
    activeXDocument5.close();
    var temp = activeXDocument5.parentWindow.Object;
    activeXDocument5 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame3 = function() {
    var iframe = documentCreateElement3("iframe");
    var JS = "java" + SCRIPT3 + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html$13.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag3("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument3;
  var NullProtoObject3 = function() {
    try {
      activeXDocument3 = document.domain && new ActiveXObject("htmlfile");
    } catch (error2) {
    }
    NullProtoObject3 = activeXDocument3 ? NullProtoObjectViaActiveX3(activeXDocument3) : NullProtoObjectViaIFrame3();
    var length = enumBugKeys$13.length;
    while (length--) delete NullProtoObject3[PROTOTYPE3][enumBugKeys$13[length]];
    return NullProtoObject3();
  };
  hiddenKeys$23[IE_PROTO$13] = true;
  var objectCreate3 = Object.create || function create5(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor3[PROTOTYPE3] = anObject$83(O);
      result = new EmptyConstructor3();
      EmptyConstructor3[PROTOTYPE3] = null;
      result[IE_PROTO$13] = O;
    } else result = NullProtoObject3();
    return Properties === void 0 ? result : defineProperties6(result, Properties);
  };
  var wellKnownSymbol$c3 = wellKnownSymbol$d3;
  var create$13 = objectCreate3;
  var definePropertyModule$23 = objectDefineProperty3;
  var UNSCOPABLES3 = wellKnownSymbol$c3("unscopables");
  var ArrayPrototype$13 = Array.prototype;
  if (ArrayPrototype$13[UNSCOPABLES3] == void 0) {
    definePropertyModule$23.f(ArrayPrototype$13, UNSCOPABLES3, {
      configurable: true,
      value: create$13(null)
    });
  }
  var addToUnscopables$13 = function(key) {
    ArrayPrototype$13[UNSCOPABLES3][key] = true;
  };
  var iterators3 = {};
  var store$13 = sharedStore3;
  var functionToString3 = Function.toString;
  if (typeof store$13.inspectSource != "function") {
    store$13.inspectSource = function(it) {
      return functionToString3.call(it);
    };
  }
  var inspectSource$33 = store$13.inspectSource;
  var global$b3 = global$i3;
  var inspectSource$23 = inspectSource$33;
  var WeakMap$13 = global$b3.WeakMap;
  var nativeWeakMap3 = typeof WeakMap$13 === "function" && /native code/.test(inspectSource$23(WeakMap$13));
  var NATIVE_WEAK_MAP3 = nativeWeakMap3;
  var global$a3 = global$i3;
  var isObject$33 = isObject$73;
  var createNonEnumerableProperty$53 = createNonEnumerableProperty$73;
  var objectHas3 = has$93;
  var sharedKey$13 = sharedKey$33;
  var hiddenKeys$13 = hiddenKeys$43;
  var WeakMap4 = global$a3.WeakMap;
  var set$13;
  var get5;
  var has$63;
  var enforce3 = function(it) {
    return has$63(it) ? get5(it) : set$13(it, {});
  };
  var getterFor3 = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$33(it) || (state = get5(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP3) {
    store = new WeakMap4();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set$13 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get5 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$63 = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey$13("state");
    hiddenKeys$13[STATE] = true;
    set$13 = function(it, metadata) {
      createNonEnumerableProperty$53(it, STATE, metadata);
      return metadata;
    };
    get5 = function(it) {
      return objectHas3(it, STATE) ? it[STATE] : {};
    };
    has$63 = function(it) {
      return objectHas3(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState3 = {
    set: set$13,
    get: get5,
    has: has$63,
    enforce: enforce3,
    getterFor: getterFor3
  };
  var objectGetOwnPropertyDescriptor3 = {};
  var objectPropertyIsEnumerable3 = {};
  var nativePropertyIsEnumerable3 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$23 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG3 = getOwnPropertyDescriptor$23 && !nativePropertyIsEnumerable3.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable3.f = NASHORN_BUG3 ? function propertyIsEnumerable3(V) {
    var descriptor = getOwnPropertyDescriptor$23(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable3;
  var DESCRIPTORS$13 = descriptors3;
  var propertyIsEnumerableModule3 = objectPropertyIsEnumerable3;
  var createPropertyDescriptor$13 = createPropertyDescriptor$33;
  var toIndexedObject$13 = toIndexedObject$43;
  var toPrimitive3 = toPrimitive$23;
  var has$53 = has$93;
  var IE8_DOM_DEFINE3 = ie8DomDefine3;
  var nativeGetOwnPropertyDescriptor3 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor3.f = DESCRIPTORS$13 ? nativeGetOwnPropertyDescriptor3 : function getOwnPropertyDescriptor6(O, P) {
    O = toIndexedObject$13(O);
    P = toPrimitive3(P, true);
    if (IE8_DOM_DEFINE3) try {
      return nativeGetOwnPropertyDescriptor3(O, P);
    } catch (error2) {
    }
    if (has$53(O, P)) return createPropertyDescriptor$13(!propertyIsEnumerableModule3.f.call(O, P), O[P]);
  };
  var redefine$53 = { exports: {} };
  var global$93 = global$i3;
  var createNonEnumerableProperty$43 = createNonEnumerableProperty$73;
  var has$43 = has$93;
  var setGlobal$13 = setGlobal$33;
  var inspectSource$13 = inspectSource$33;
  var InternalStateModule$23 = internalState3;
  var getInternalState$23 = InternalStateModule$23.get;
  var enforceInternalState3 = InternalStateModule$23.enforce;
  var TEMPLATE3 = String(String).split("String");
  (redefine$53.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$43(value, "name")) createNonEnumerableProperty$43(value, "name", key);
      enforceInternalState3(value).source = TEMPLATE3.join(typeof key == "string" ? key : "");
    }
    if (O === global$93) {
      if (simple) O[key] = value;
      else setGlobal$13(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$43(O, key, value);
  })(Function.prototype, "toString", function toString9() {
    return typeof this == "function" && getInternalState$23(this).source || inspectSource$13(this);
  });
  var objectGetOwnPropertyNames3 = {};
  var internalObjectKeys3 = objectKeysInternal3;
  var enumBugKeys3 = enumBugKeys$33;
  var hiddenKeys3 = enumBugKeys3.concat("length", "prototype");
  objectGetOwnPropertyNames3.f = Object.getOwnPropertyNames || function getOwnPropertyNames4(O) {
    return internalObjectKeys3(O, hiddenKeys3);
  };
  var objectGetOwnPropertySymbols3 = {};
  objectGetOwnPropertySymbols3.f = Object.getOwnPropertySymbols;
  var getBuiltIn$33 = getBuiltIn$53;
  var getOwnPropertyNamesModule3 = objectGetOwnPropertyNames3;
  var getOwnPropertySymbolsModule3 = objectGetOwnPropertySymbols3;
  var anObject$73 = anObject$b3;
  var ownKeys$13 = getBuiltIn$33("Reflect", "ownKeys") || function ownKeys5(it) {
    var keys14 = getOwnPropertyNamesModule3.f(anObject$73(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule3.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has$33 = has$93;
  var ownKeys6 = ownKeys$13;
  var getOwnPropertyDescriptorModule3 = objectGetOwnPropertyDescriptor3;
  var definePropertyModule$13 = objectDefineProperty3;
  var copyConstructorProperties$13 = function(target, source) {
    var keys14 = ownKeys6(source);
    var defineProperty14 = definePropertyModule$13.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule3.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has$33(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$33 = fails$83;
  var replacement3 = /#|\.prototype\./;
  var isForced$23 = function(feature, detection) {
    var value = data3[normalize3(feature)];
    return value == POLYFILL3 ? true : value == NATIVE3 ? false : typeof detection == "function" ? fails$33(detection) : !!detection;
  };
  var normalize3 = isForced$23.normalize = function(string) {
    return String(string).replace(replacement3, ".").toLowerCase();
  };
  var data3 = isForced$23.data = {};
  var NATIVE3 = isForced$23.NATIVE = "N";
  var POLYFILL3 = isForced$23.POLYFILL = "P";
  var isForced_13 = isForced$23;
  var global$83 = global$i3;
  var getOwnPropertyDescriptor$13 = objectGetOwnPropertyDescriptor3.f;
  var createNonEnumerableProperty$33 = createNonEnumerableProperty$73;
  var redefine$43 = redefine$53.exports;
  var setGlobal3 = setGlobal$33;
  var copyConstructorProperties3 = copyConstructorProperties$13;
  var isForced$13 = isForced_13;
  var _export3 = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$83;
    } else if (STATIC) {
      target = global$83[TARGET] || setGlobal3(TARGET, {});
    } else {
      target = (global$83[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$13(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced$13(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties3(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$33(sourceProperty, "sham", true);
      }
      redefine$43(target, key, sourceProperty, options);
    }
  };
  var requireObjectCoercible3 = requireObjectCoercible$23;
  var toObject$13 = function(argument) {
    return Object(requireObjectCoercible3(argument));
  };
  var fails$23 = fails$83;
  var correctPrototypeGetter3 = !fails$23(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  var has$23 = has$93;
  var toObject3 = toObject$13;
  var sharedKey3 = sharedKey$33;
  var CORRECT_PROTOTYPE_GETTER3 = correctPrototypeGetter3;
  var IE_PROTO3 = sharedKey3("IE_PROTO");
  var ObjectPrototype3 = Object.prototype;
  var objectGetPrototypeOf3 = CORRECT_PROTOTYPE_GETTER3 ? Object.getPrototypeOf : function(O) {
    O = toObject3(O);
    if (has$23(O, IE_PROTO3)) return O[IE_PROTO3];
    if (typeof O.constructor == "function" && O instanceof O.constructor) {
      return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectPrototype3 : null;
  };
  var getPrototypeOf$13 = objectGetPrototypeOf3;
  var createNonEnumerableProperty$23 = createNonEnumerableProperty$73;
  var has$13 = has$93;
  var wellKnownSymbol$b3 = wellKnownSymbol$d3;
  var ITERATOR$53 = wellKnownSymbol$b3("iterator");
  var BUGGY_SAFARI_ITERATORS$13 = false;
  var returnThis$23 = function() {
    return this;
  };
  var IteratorPrototype$23;
  var PrototypeOfArrayIteratorPrototype3;
  var arrayIterator3;
  if ([].keys) {
    arrayIterator3 = [].keys();
    if (!("next" in arrayIterator3)) BUGGY_SAFARI_ITERATORS$13 = true;
    else {
      PrototypeOfArrayIteratorPrototype3 = getPrototypeOf$13(getPrototypeOf$13(arrayIterator3));
      if (PrototypeOfArrayIteratorPrototype3 !== Object.prototype) IteratorPrototype$23 = PrototypeOfArrayIteratorPrototype3;
    }
  }
  if (IteratorPrototype$23 == void 0) IteratorPrototype$23 = {};
  if (!has$13(IteratorPrototype$23, ITERATOR$53)) {
    createNonEnumerableProperty$23(IteratorPrototype$23, ITERATOR$53, returnThis$23);
  }
  var iteratorsCore3 = {
    IteratorPrototype: IteratorPrototype$23,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$13
  };
  var defineProperty7 = objectDefineProperty3.f;
  var has3 = has$93;
  var wellKnownSymbol$a3 = wellKnownSymbol$d3;
  var TO_STRING_TAG$33 = wellKnownSymbol$a3("toStringTag");
  var setToStringTag$33 = function(it, TAG, STATIC) {
    if (it && !has3(it = STATIC ? it : it.prototype, TO_STRING_TAG$33)) {
      defineProperty7(it, TO_STRING_TAG$33, { configurable: true, value: TAG });
    }
  };
  var IteratorPrototype$13 = iteratorsCore3.IteratorPrototype;
  var create6 = objectCreate3;
  var createPropertyDescriptor3 = createPropertyDescriptor$33;
  var setToStringTag$23 = setToStringTag$33;
  var Iterators$43 = iterators3;
  var returnThis$13 = function() {
    return this;
  };
  var createIteratorConstructor$13 = function(IteratorConstructor, NAME2, next3) {
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    IteratorConstructor.prototype = create6(IteratorPrototype$13, { next: createPropertyDescriptor3(1, next3) });
    setToStringTag$23(IteratorConstructor, TO_STRING_TAG5, false);
    Iterators$43[TO_STRING_TAG5] = returnThis$13;
    return IteratorConstructor;
  };
  var isObject$23 = isObject$73;
  var aPossiblePrototype$13 = function(it) {
    if (!isObject$23(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + " as a prototype");
    }
    return it;
  };
  var anObject$63 = anObject$b3;
  var aPossiblePrototype3 = aPossiblePrototype$13;
  var objectSetPrototypeOf3 = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test5 = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
      setter.call(test5, []);
      CORRECT_SETTER = test5 instanceof Array;
    } catch (error2) {
    }
    return function setPrototypeOf5(O, proto) {
      anObject$63(O);
      aPossiblePrototype3(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  })() : void 0);
  var $$13 = _export3;
  var createIteratorConstructor3 = createIteratorConstructor$13;
  var getPrototypeOf3 = objectGetPrototypeOf3;
  var setPrototypeOf3 = objectSetPrototypeOf3;
  var setToStringTag$13 = setToStringTag$33;
  var createNonEnumerableProperty$13 = createNonEnumerableProperty$73;
  var redefine$33 = redefine$53.exports;
  var wellKnownSymbol$93 = wellKnownSymbol$d3;
  var Iterators$33 = iterators3;
  var IteratorsCore3 = iteratorsCore3;
  var IteratorPrototype3 = IteratorsCore3.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS3 = IteratorsCore3.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$43 = wellKnownSymbol$93("iterator");
  var KEYS3 = "keys";
  var VALUES3 = "values";
  var ENTRIES3 = "entries";
  var returnThis3 = function() {
    return this;
  };
  var defineIterator$13 = function(Iterable, NAME2, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED5) {
    createIteratorConstructor3(IteratorConstructor, NAME2, next3);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS3 && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS3:
          return function keys14() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES3:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES3:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$43] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS3 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf3(anyNativeIterator.call(new Iterable()));
      if (IteratorPrototype3 !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf3(CurrentIteratorPrototype) !== IteratorPrototype3) {
          if (setPrototypeOf3) {
            setPrototypeOf3(CurrentIteratorPrototype, IteratorPrototype3);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$43] != "function") {
            createNonEnumerableProperty$13(CurrentIteratorPrototype, ITERATOR$43, returnThis3);
          }
        }
        setToStringTag$13(CurrentIteratorPrototype, TO_STRING_TAG5, true);
      }
    }
    if (DEFAULT == VALUES3 && nativeIterator && nativeIterator.name !== VALUES3) {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return nativeIterator.call(this);
      };
    }
    if (IterablePrototype[ITERATOR$43] !== defaultIterator) {
      createNonEnumerableProperty$13(IterablePrototype, ITERATOR$43, defaultIterator);
    }
    Iterators$33[NAME2] = defaultIterator;
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES3),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS3),
        entries: getIterationMethod(ENTRIES3)
      };
      if (FORCED5) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS3 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$33(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $$13({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS3 || INCORRECT_VALUES_NAME }, methods);
    }
    return methods;
  };
  var toIndexedObject3 = toIndexedObject$43;
  var addToUnscopables3 = addToUnscopables$13;
  var Iterators$23 = iterators3;
  var InternalStateModule$13 = internalState3;
  var defineIterator3 = defineIterator$13;
  var ARRAY_ITERATOR3 = "Array Iterator";
  var setInternalState$13 = InternalStateModule$13.set;
  var getInternalState$13 = InternalStateModule$13.getterFor(ARRAY_ITERATOR3);
  var es_array_iterator3 = defineIterator3(Array, "Array", function(iterated, kind) {
    setInternalState$13(this, {
      type: ARRAY_ITERATOR3,
      target: toIndexedObject3(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState$13(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, "values");
  Iterators$23.Arguments = Iterators$23.Array;
  addToUnscopables3("keys");
  addToUnscopables3("values");
  addToUnscopables3("entries");
  var global$73 = global$i3;
  var nativePromiseConstructor3 = global$73.Promise;
  var redefine$23 = redefine$53.exports;
  var redefineAll$13 = function(target, src, options) {
    for (var key in src) redefine$23(target, key, src[key], options);
    return target;
  };
  var getBuiltIn$23 = getBuiltIn$53;
  var definePropertyModule3 = objectDefineProperty3;
  var wellKnownSymbol$83 = wellKnownSymbol$d3;
  var DESCRIPTORS3 = descriptors3;
  var SPECIES$23 = wellKnownSymbol$83("species");
  var setSpecies$13 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$23(CONSTRUCTOR_NAME);
    var defineProperty14 = definePropertyModule3.f;
    if (DESCRIPTORS3 && Constructor && !Constructor[SPECIES$23]) {
      defineProperty14(Constructor, SPECIES$23, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  var aFunction$43 = function(it) {
    if (typeof it != "function") {
      throw TypeError(String(it) + " is not a function");
    }
    return it;
  };
  var anInstance$13 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
    }
    return it;
  };
  var iterate$23 = { exports: {} };
  var wellKnownSymbol$73 = wellKnownSymbol$d3;
  var Iterators$13 = iterators3;
  var ITERATOR$33 = wellKnownSymbol$73("iterator");
  var ArrayPrototype3 = Array.prototype;
  var isArrayIteratorMethod$13 = function(it) {
    return it !== void 0 && (Iterators$13.Array === it || ArrayPrototype3[ITERATOR$33] === it);
  };
  var aFunction$33 = aFunction$43;
  var functionBindContext3 = function(fn, that, length) {
    aFunction$33(fn);
    if (that === void 0) return fn;
    switch (length) {
      case 0:
        return function() {
          return fn.call(that);
        };
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var wellKnownSymbol$63 = wellKnownSymbol$d3;
  var TO_STRING_TAG$23 = wellKnownSymbol$63("toStringTag");
  var test3 = {};
  test3[TO_STRING_TAG$23] = "z";
  var toStringTagSupport3 = String(test3) === "[object z]";
  var TO_STRING_TAG_SUPPORT3 = toStringTagSupport3;
  var classofRaw3 = classofRaw$13;
  var wellKnownSymbol$53 = wellKnownSymbol$d3;
  var TO_STRING_TAG$13 = wellKnownSymbol$53("toStringTag");
  var CORRECT_ARGUMENTS3 = classofRaw3(/* @__PURE__ */ (function() {
    return arguments;
  })()) == "Arguments";
  var tryGet3 = function(it, key) {
    try {
      return it[key];
    } catch (error2) {
    }
  };
  var classof$43 = TO_STRING_TAG_SUPPORT3 ? classofRaw3 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet3(O = Object(it), TO_STRING_TAG$13)) == "string" ? tag : CORRECT_ARGUMENTS3 ? classofRaw3(O) : (result = classofRaw3(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
  };
  var classof$33 = classof$43;
  var Iterators3 = iterators3;
  var wellKnownSymbol$43 = wellKnownSymbol$d3;
  var ITERATOR$23 = wellKnownSymbol$43("iterator");
  var getIteratorMethod$13 = function(it) {
    if (it != void 0) return it[ITERATOR$23] || it["@@iterator"] || Iterators3[classof$33(it)];
  };
  var anObject$53 = anObject$b3;
  var callWithSafeIterationClosing$13 = function(iterator, fn, value, ENTRIES5) {
    try {
      return ENTRIES5 ? fn(anObject$53(value)[0], value[1]) : fn(value);
    } catch (error2) {
      var returnMethod = iterator["return"];
      if (returnMethod !== void 0) anObject$53(returnMethod.call(iterator));
      throw error2;
    }
  };
  var anObject$43 = anObject$b3;
  var isArrayIteratorMethod3 = isArrayIteratorMethod$13;
  var toLength3 = toLength$23;
  var bind$23 = functionBindContext3;
  var getIteratorMethod3 = getIteratorMethod$13;
  var callWithSafeIterationClosing3 = callWithSafeIterationClosing$13;
  var Result3 = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var iterate$13 = iterate$23.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bind$23(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next3, step;
    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod3(iterable);
      if (typeof iterFn != "function") throw TypeError("Target is not iterable");
      if (isArrayIteratorMethod3(iterFn)) {
        for (index = 0, length = toLength3(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject$43(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result3) return result;
        }
        return new Result3(false);
      }
      iterator = iterFn.call(iterable);
    }
    next3 = iterator.next;
    while (!(step = next3.call(iterator)).done) {
      result = callWithSafeIterationClosing3(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == "object" && result && result instanceof Result3) return result;
    }
    return new Result3(false);
  };
  iterate$13.stop = function(result) {
    return new Result3(true, result);
  };
  var wellKnownSymbol$33 = wellKnownSymbol$d3;
  var ITERATOR$13 = wellKnownSymbol$33("iterator");
  var SAFE_CLOSING3 = false;
  try {
    called = 0;
    iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING3 = true;
      }
    };
    iteratorWithReturn[ITERATOR$13] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error2) {
  }
  var called;
  var iteratorWithReturn;
  var checkCorrectnessOfIteration$13 = function(exec3, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING3) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$13] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec3(object);
    } catch (error2) {
    }
    return ITERATION_SUPPORT;
  };
  var anObject$33 = anObject$b3;
  var aFunction$23 = aFunction$43;
  var wellKnownSymbol$23 = wellKnownSymbol$d3;
  var SPECIES$13 = wellKnownSymbol$23("species");
  var speciesConstructor$13 = function(O, defaultConstructor) {
    var C = anObject$33(O).constructor;
    var S;
    return C === void 0 || (S = anObject$33(C)[SPECIES$13]) == void 0 ? defaultConstructor : aFunction$23(S);
  };
  var getBuiltIn$13 = getBuiltIn$53;
  var engineUserAgent3 = getBuiltIn$13("navigator", "userAgent") || "";
  var userAgent$13 = engineUserAgent3;
  var engineIsIos3 = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent$13);
  var global$63 = global$i3;
  var fails$13 = fails$83;
  var classof$23 = classofRaw$13;
  var bind$13 = functionBindContext3;
  var html3 = html$23;
  var createElement3 = documentCreateElement$13;
  var IS_IOS$13 = engineIsIos3;
  var location4 = global$63.location;
  var set4 = global$63.setImmediate;
  var clear3 = global$63.clearImmediate;
  var process$33 = global$63.process;
  var MessageChannel4 = global$63.MessageChannel;
  var Dispatch3 = global$63.Dispatch;
  var counter3 = 0;
  var queue5 = {};
  var ONREADYSTATECHANGE3 = "onreadystatechange";
  var defer3;
  var channel3;
  var port3;
  var run3 = function(id7) {
    if (queue5.hasOwnProperty(id7)) {
      var fn = queue5[id7];
      delete queue5[id7];
      fn();
    }
  };
  var runner3 = function(id7) {
    return function() {
      run3(id7);
    };
  };
  var listener3 = function(event) {
    run3(event.data);
  };
  var post3 = function(id7) {
    global$63.postMessage(id7 + "", location4.protocol + "//" + location4.host);
  };
  if (!set4 || !clear3) {
    set4 = function setImmediate2(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue5[++counter3] = function() {
        (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
      };
      defer3(counter3);
      return counter3;
    };
    clear3 = function clearImmediate(id7) {
      delete queue5[id7];
    };
    if (classof$23(process$33) == "process") {
      defer3 = function(id7) {
        process$33.nextTick(runner3(id7));
      };
    } else if (Dispatch3 && Dispatch3.now) {
      defer3 = function(id7) {
        Dispatch3.now(runner3(id7));
      };
    } else if (MessageChannel4 && !IS_IOS$13) {
      channel3 = new MessageChannel4();
      port3 = channel3.port2;
      channel3.port1.onmessage = listener3;
      defer3 = bind$13(port3.postMessage, port3, 1);
    } else if (global$63.addEventListener && typeof postMessage == "function" && !global$63.importScripts && !fails$13(post3) && location4.protocol !== "file:") {
      defer3 = post3;
      global$63.addEventListener("message", listener3, false);
    } else if (ONREADYSTATECHANGE3 in createElement3("script")) {
      defer3 = function(id7) {
        html3.appendChild(createElement3("script"))[ONREADYSTATECHANGE3] = function() {
          html3.removeChild(this);
          run3(id7);
        };
      };
    } else {
      defer3 = function(id7) {
        setTimeout(runner3(id7), 0);
      };
    }
  }
  var task$13 = {
    set: set4,
    clear: clear3
  };
  var global$53 = global$i3;
  var getOwnPropertyDescriptor7 = objectGetOwnPropertyDescriptor3.f;
  var classof$13 = classofRaw$13;
  var macrotask3 = task$13.set;
  var IS_IOS3 = engineIsIos3;
  var MutationObserver3 = global$53.MutationObserver || global$53.WebKitMutationObserver;
  var process$23 = global$53.process;
  var Promise$13 = global$53.Promise;
  var IS_NODE$13 = classof$13(process$23) == "process";
  var queueMicrotaskDescriptor3 = getOwnPropertyDescriptor7(global$53, "queueMicrotask");
  var queueMicrotask4 = queueMicrotaskDescriptor3 && queueMicrotaskDescriptor3.value;
  var flush3;
  var head3;
  var last3;
  var notify$13;
  var toggle3;
  var node3;
  var promise3;
  var then3;
  if (!queueMicrotask4) {
    flush3 = function() {
      var parent2, fn;
      if (IS_NODE$13 && (parent2 = process$23.domain)) parent2.exit();
      while (head3) {
        fn = head3.fn;
        head3 = head3.next;
        try {
          fn();
        } catch (error2) {
          if (head3) notify$13();
          else last3 = void 0;
          throw error2;
        }
      }
      last3 = void 0;
      if (parent2) parent2.enter();
    };
    if (IS_NODE$13) {
      notify$13 = function() {
        process$23.nextTick(flush3);
      };
    } else if (MutationObserver3 && !IS_IOS3) {
      toggle3 = true;
      node3 = document.createTextNode("");
      new MutationObserver3(flush3).observe(node3, { characterData: true });
      notify$13 = function() {
        node3.data = toggle3 = !toggle3;
      };
    } else if (Promise$13 && Promise$13.resolve) {
      promise3 = Promise$13.resolve(void 0);
      then3 = promise3.then;
      notify$13 = function() {
        then3.call(promise3, flush3);
      };
    } else {
      notify$13 = function() {
        macrotask3.call(global$53, flush3);
      };
    }
  }
  var microtask$13 = queueMicrotask4 || function(fn) {
    var task5 = { fn, next: void 0 };
    if (last3) last3.next = task5;
    if (!head3) {
      head3 = task5;
      notify$13();
    }
    last3 = task5;
  };
  var newPromiseCapability$23 = {};
  var aFunction$13 = aFunction$43;
  var PromiseCapability3 = function(C) {
    var resolve5, reject5;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve5 !== void 0 || reject5 !== void 0) throw TypeError("Bad Promise constructor");
      resolve5 = $$resolve;
      reject5 = $$reject;
    });
    this.resolve = aFunction$13(resolve5);
    this.reject = aFunction$13(reject5);
  };
  newPromiseCapability$23.f = function(C) {
    return new PromiseCapability3(C);
  };
  var anObject$23 = anObject$b3;
  var isObject$13 = isObject$73;
  var newPromiseCapability$13 = newPromiseCapability$23;
  var promiseResolve$13 = function(C, x) {
    anObject$23(C);
    if (isObject$13(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$13.f(C);
    var resolve5 = promiseCapability.resolve;
    resolve5(x);
    return promiseCapability.promise;
  };
  var global$43 = global$i3;
  var hostReportErrors$13 = function(a, b) {
    var console2 = global$43.console;
    if (console2 && console2.error) {
      arguments.length === 1 ? console2.error(a) : console2.error(a, b);
    }
  };
  var perform$13 = function(exec3) {
    try {
      return { error: false, value: exec3() };
    } catch (error2) {
      return { error: true, value: error2 };
    }
  };
  var global$33 = global$i3;
  var userAgent3 = engineUserAgent3;
  var process$13 = global$33.process;
  var versions5 = process$13 && process$13.versions;
  var v83 = versions5 && versions5.v8;
  var match3;
  var version5;
  if (v83) {
    match3 = v83.split(".");
    version5 = match3[0] + match3[1];
  } else if (userAgent3) {
    match3 = userAgent3.match(/Edge\/(\d+)/);
    if (!match3 || match3[1] >= 74) {
      match3 = userAgent3.match(/Chrome\/(\d+)/);
      if (match3) version5 = match3[1];
    }
  }
  var engineV8Version3 = version5 && +version5;
  var $3 = _export3;
  var global$23 = global$i3;
  var getBuiltIn3 = getBuiltIn$53;
  var NativePromise3 = nativePromiseConstructor3;
  var redefine$13 = redefine$53.exports;
  var redefineAll3 = redefineAll$13;
  var setToStringTag3 = setToStringTag$33;
  var setSpecies3 = setSpecies$13;
  var isObject4 = isObject$73;
  var aFunction3 = aFunction$43;
  var anInstance3 = anInstance$13;
  var classof3 = classofRaw$13;
  var inspectSource3 = inspectSource$33;
  var iterate3 = iterate$23.exports;
  var checkCorrectnessOfIteration3 = checkCorrectnessOfIteration$13;
  var speciesConstructor3 = speciesConstructor$13;
  var task3 = task$13.set;
  var microtask3 = microtask$13;
  var promiseResolve3 = promiseResolve$13;
  var hostReportErrors3 = hostReportErrors$13;
  var newPromiseCapabilityModule3 = newPromiseCapability$23;
  var perform3 = perform$13;
  var InternalStateModule3 = internalState3;
  var isForced3 = isForced_13;
  var wellKnownSymbol$13 = wellKnownSymbol$d3;
  var V8_VERSION3 = engineV8Version3;
  var SPECIES3 = wellKnownSymbol$13("species");
  var PROMISE3 = "Promise";
  var getInternalState3 = InternalStateModule3.get;
  var setInternalState3 = InternalStateModule3.set;
  var getInternalPromiseState3 = InternalStateModule3.getterFor(PROMISE3);
  var PromiseConstructor3 = NativePromise3;
  var TypeError$13 = global$23.TypeError;
  var document$13 = global$23.document;
  var process4 = global$23.process;
  var $fetch3 = getBuiltIn3("fetch");
  var newPromiseCapability3 = newPromiseCapabilityModule3.f;
  var newGenericPromiseCapability3 = newPromiseCapability3;
  var IS_NODE3 = classof3(process4) == "process";
  var DISPATCH_EVENT3 = !!(document$13 && document$13.createEvent && global$23.dispatchEvent);
  var UNHANDLED_REJECTION3 = "unhandledrejection";
  var REJECTION_HANDLED3 = "rejectionhandled";
  var PENDING3 = 0;
  var FULFILLED3 = 1;
  var REJECTED3 = 2;
  var HANDLED3 = 1;
  var UNHANDLED3 = 2;
  var Internal3;
  var OwnPromiseCapability3;
  var PromiseWrapper3;
  var nativeThen3;
  var FORCED3 = isForced3(PROMISE3, function() {
    var GLOBAL_CORE_JS_PROMISE = inspectSource3(PromiseConstructor3) !== String(PromiseConstructor3);
    if (!GLOBAL_CORE_JS_PROMISE) {
      if (V8_VERSION3 === 66) return true;
      if (!IS_NODE3 && typeof PromiseRejectionEvent != "function") return true;
    }
    if (V8_VERSION3 >= 51 && /native code/.test(PromiseConstructor3)) return false;
    var promise5 = PromiseConstructor3.resolve(1);
    var FakePromise = function(exec3) {
      exec3(function() {
      }, function() {
      });
    };
    var constructor = promise5.constructor = {};
    constructor[SPECIES3] = FakePromise;
    return !(promise5.then(function() {
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION3 = FORCED3 || !checkCorrectnessOfIteration3(function(iterable) {
    PromiseConstructor3.all(iterable)["catch"](function() {
    });
  });
  var isThenable3 = function(it) {
    var then5;
    return isObject4(it) && typeof (then5 = it.then) == "function" ? then5 : false;
  };
  var notify3 = function(promise5, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask3(function() {
      var value = state.value;
      var ok = state.state == FULFILLED3;
      var index = 0;
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve5 = reaction.resolve;
        var reject5 = reaction.reject;
        var domain2 = reaction.domain;
        var result, then5, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED3) onHandleUnhandled3(promise5, state);
              state.rejection = HANDLED3;
            }
            if (handler === true) result = value;
            else {
              if (domain2) domain2.enter();
              result = handler(value);
              if (domain2) {
                domain2.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject5(TypeError$13("Promise-chain cycle"));
            } else if (then5 = isThenable3(result)) {
              then5.call(result, resolve5, reject5);
            } else resolve5(result);
          } else reject5(value);
        } catch (error2) {
          if (domain2 && !exited) domain2.exit();
          reject5(error2);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled3(promise5, state);
    });
  };
  var dispatchEvent3 = function(name, promise5, reason) {
    var event, handler;
    if (DISPATCH_EVENT3) {
      event = document$13.createEvent("Event");
      event.promise = promise5;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$23.dispatchEvent(event);
    } else event = { promise: promise5, reason };
    if (handler = global$23["on" + name]) handler(event);
    else if (name === UNHANDLED_REJECTION3) hostReportErrors3("Unhandled promise rejection", reason);
  };
  var onUnhandled3 = function(promise5, state) {
    task3.call(global$23, function() {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled3(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform3(function() {
          if (IS_NODE3) {
            process4.emit("unhandledRejection", value, promise5);
          } else dispatchEvent3(UNHANDLED_REJECTION3, promise5, value);
        });
        state.rejection = IS_NODE3 || isUnhandled3(state) ? UNHANDLED3 : HANDLED3;
        if (result.error) throw result.value;
      }
    });
  };
  var isUnhandled3 = function(state) {
    return state.rejection !== HANDLED3 && !state.parent;
  };
  var onHandleUnhandled3 = function(promise5, state) {
    task3.call(global$23, function() {
      if (IS_NODE3) {
        process4.emit("rejectionHandled", promise5);
      } else dispatchEvent3(REJECTION_HANDLED3, promise5, state.value);
    });
  };
  var bind4 = function(fn, promise5, state, unwrap) {
    return function(value) {
      fn(promise5, state, value, unwrap);
    };
  };
  var internalReject3 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED3;
    notify3(promise5, state, true);
  };
  var internalResolve3 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (promise5 === value) throw TypeError$13("Promise can't be resolved itself");
      var then5 = isThenable3(value);
      if (then5) {
        microtask3(function() {
          var wrapper = { done: false };
          try {
            then5.call(
              value,
              bind4(internalResolve3, promise5, wrapper, state),
              bind4(internalReject3, promise5, wrapper, state)
            );
          } catch (error2) {
            internalReject3(promise5, wrapper, error2, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED3;
        notify3(promise5, state, false);
      }
    } catch (error2) {
      internalReject3(promise5, { done: false }, error2, state);
    }
  };
  if (FORCED3) {
    PromiseConstructor3 = function Promise2(executor) {
      anInstance3(this, PromiseConstructor3, PROMISE3);
      aFunction3(executor);
      Internal3.call(this);
      var state = getInternalState3(this);
      try {
        executor(bind4(internalResolve3, this, state), bind4(internalReject3, this, state));
      } catch (error2) {
        internalReject3(this, state, error2);
      }
    };
    Internal3 = function Promise2(executor) {
      setInternalState3(this, {
        type: PROMISE3,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING3,
        value: void 0
      });
    };
    Internal3.prototype = redefineAll3(PromiseConstructor3.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then5(onFulfilled, onRejected) {
        var state = getInternalPromiseState3(this);
        var reaction = newPromiseCapability3(speciesConstructor3(this, PromiseConstructor3));
        reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
        reaction.fail = typeof onRejected == "function" && onRejected;
        reaction.domain = IS_NODE3 ? process4.domain : void 0;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING3) notify3(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability3 = function() {
      var promise5 = new Internal3();
      var state = getInternalState3(promise5);
      this.promise = promise5;
      this.resolve = bind4(internalResolve3, promise5, state);
      this.reject = bind4(internalReject3, promise5, state);
    };
    newPromiseCapabilityModule3.f = newPromiseCapability3 = function(C) {
      return C === PromiseConstructor3 || C === PromiseWrapper3 ? new OwnPromiseCapability3(C) : newGenericPromiseCapability3(C);
    };
    if (typeof NativePromise3 == "function") {
      nativeThen3 = NativePromise3.prototype.then;
      redefine$13(NativePromise3.prototype, "then", function then5(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor3(function(resolve5, reject5) {
          nativeThen3.call(that, resolve5, reject5);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      if (typeof $fetch3 == "function") $3({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch2(input) {
          return promiseResolve3(PromiseConstructor3, $fetch3.apply(global$23, arguments));
        }
      });
    }
  }
  $3({ global: true, wrap: true, forced: FORCED3 }, {
    Promise: PromiseConstructor3
  });
  setToStringTag3(PromiseConstructor3, PROMISE3, false);
  setSpecies3(PROMISE3);
  PromiseWrapper3 = getBuiltIn3(PROMISE3);
  $3({ target: PROMISE3, stat: true, forced: FORCED3 }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject3(r) {
      var capability = newPromiseCapability3(this);
      capability.reject.call(void 0, r);
      return capability.promise;
    }
  });
  $3({ target: PROMISE3, stat: true, forced: FORCED3 }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve3(x) {
      return promiseResolve3(this, x);
    }
  });
  $3({ target: PROMISE3, stat: true, forced: INCORRECT_ITERATION3 }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all3(iterable) {
      var C = this;
      var capability = newPromiseCapability3(C);
      var resolve5 = capability.resolve;
      var reject5 = capability.reject;
      var result = perform3(function() {
        var $promiseResolve = aFunction3(C.resolve);
        var values2 = [];
        var counter5 = 0;
        var remaining = 1;
        iterate3(iterable, function(promise5) {
          var index = counter5++;
          var alreadyCalled = false;
          values2.push(void 0);
          remaining++;
          $promiseResolve.call(C, promise5).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve5(values2);
          }, reject5);
        });
        --remaining || resolve5(values2);
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race3(iterable) {
      var C = this;
      var capability = newPromiseCapability3(C);
      var reject5 = capability.reject;
      var result = perform3(function() {
        var $promiseResolve = aFunction3(C.resolve);
        iterate3(iterable, function(promise5) {
          $promiseResolve.call(C, promise5).then(capability.resolve, reject5);
        });
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    }
  });
  var anObject$13 = anObject$b3;
  var regexpFlags3 = function() {
    var that = anObject$13(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var redefine3 = redefine$53.exports;
  var anObject3 = anObject$b3;
  var fails3 = fails$83;
  var flags2 = regexpFlags3;
  var TO_STRING2 = "toString";
  var RegExpPrototype2 = RegExp.prototype;
  var nativeToString2 = RegExpPrototype2[TO_STRING2];
  var NOT_GENERIC2 = fails3(function() {
    return nativeToString2.call({ source: "a", flags: "b" }) != "/a/b";
  });
  var INCORRECT_NAME2 = nativeToString2.name != TO_STRING2;
  if (NOT_GENERIC2 || INCORRECT_NAME2) {
    redefine3(RegExp.prototype, TO_STRING2, function toString18() {
      var R = anObject3(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype2) ? flags2.call(R) : rf);
      return "/" + p + "/" + f;
    }, { unsafe: true });
  }
  var domIterables3 = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var global$13 = global$i3;
  var DOMIterables3 = domIterables3;
  var ArrayIteratorMethods3 = es_array_iterator3;
  var createNonEnumerableProperty3 = createNonEnumerableProperty$73;
  var wellKnownSymbol3 = wellKnownSymbol$d3;
  var ITERATOR3 = wellKnownSymbol3("iterator");
  var TO_STRING_TAG3 = wellKnownSymbol3("toStringTag");
  var ArrayValues3 = ArrayIteratorMethods3.values;
  for (COLLECTION_NAME in DOMIterables3) {
    Collection = global$13[COLLECTION_NAME];
    CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR3] !== ArrayValues3) try {
        createNonEnumerableProperty3(CollectionPrototype, ITERATOR3, ArrayValues3);
      } catch (error2) {
        CollectionPrototype[ITERATOR3] = ArrayValues3;
      }
      if (!CollectionPrototype[TO_STRING_TAG3]) {
        createNonEnumerableProperty3(CollectionPrototype, TO_STRING_TAG3, COLLECTION_NAME);
      }
      if (DOMIterables3[COLLECTION_NAME]) for (METHOD_NAME in ArrayIteratorMethods3) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods3[METHOD_NAME]) try {
          createNonEnumerableProperty3(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods3[METHOD_NAME]);
        } catch (error2) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods3[METHOD_NAME];
        }
      }
    }
  }
  var Collection;
  var CollectionPrototype;
  var METHOD_NAME;
  var COLLECTION_NAME;

  // node_modules/@near-wallet-selector/my-near-wallet/index.js
  var commonjsGlobal4 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var fails$c3 = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var toString10 = {}.toString;
  var classofRaw$14 = function(it) {
    return toString10.call(it).slice(8, -1);
  };
  var fails$b3 = fails$c3;
  var classof$72 = classofRaw$14;
  var split4 = "".split;
  var indexedObject4 = fails$b3(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$72(it) == "String" ? split4.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$42 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject$13 = indexedObject4;
  var requireObjectCoercible$33 = requireObjectCoercible$42;
  var toIndexedObject$44 = function(it) {
    return IndexedObject$13(requireObjectCoercible$33(it));
  };
  var check4 = function(it) {
    return it && it.Math == Math && it;
  };
  var global$j3 = (
    // eslint-disable-next-line no-undef
    check4(typeof globalThis == "object" && globalThis) || check4(typeof window == "object" && window) || check4(typeof self == "object" && self) || check4(typeof commonjsGlobal4 == "object" && commonjsGlobal4) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var shared$24 = { exports: {} };
  var isPure = false;
  var fails$a3 = fails$c3;
  var descriptors4 = !fails$a3(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectDefineProperty4 = {};
  var isObject$83 = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var global$i4 = global$j3;
  var isObject$74 = isObject$83;
  var document$24 = global$i4.document;
  var EXISTS4 = isObject$74(document$24) && isObject$74(document$24.createElement);
  var documentCreateElement$14 = function(it) {
    return EXISTS4 ? document$24.createElement(it) : {};
  };
  var DESCRIPTORS$73 = descriptors4;
  var fails$93 = fails$c3;
  var createElement$14 = documentCreateElement$14;
  var ie8DomDefine4 = !DESCRIPTORS$73 && !fails$93(function() {
    return Object.defineProperty(createElement$14("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var isObject$64 = isObject$83;
  var anObject$e = function(it) {
    if (!isObject$64(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var isObject$54 = isObject$83;
  var toPrimitive$32 = function(input, PREFERRED_STRING) {
    if (!isObject$54(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$54(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$54(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$54(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var DESCRIPTORS$63 = descriptors4;
  var IE8_DOM_DEFINE$14 = ie8DomDefine4;
  var anObject$d = anObject$e;
  var toPrimitive$24 = toPrimitive$32;
  var nativeDefineProperty4 = Object.defineProperty;
  objectDefineProperty4.f = DESCRIPTORS$63 ? nativeDefineProperty4 : function defineProperty8(O, P, Attributes) {
    anObject$d(O);
    P = toPrimitive$24(P, true);
    anObject$d(Attributes);
    if (IE8_DOM_DEFINE$14) try {
      return nativeDefineProperty4(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var createPropertyDescriptor$5 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var DESCRIPTORS$54 = descriptors4;
  var definePropertyModule$52 = objectDefineProperty4;
  var createPropertyDescriptor$42 = createPropertyDescriptor$5;
  var createNonEnumerableProperty$82 = DESCRIPTORS$54 ? function(object, key, value) {
    return definePropertyModule$52.f(object, key, createPropertyDescriptor$42(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var global$h4 = global$j3;
  var createNonEnumerableProperty$74 = createNonEnumerableProperty$82;
  var setGlobal$34 = function(key, value) {
    try {
      createNonEnumerableProperty$74(global$h4, key, value);
    } catch (error2) {
      global$h4[key] = value;
    }
    return value;
  };
  var global$g4 = global$j3;
  var setGlobal$24 = setGlobal$34;
  var SHARED4 = "__core-js_shared__";
  var store$34 = global$g4[SHARED4] || setGlobal$24(SHARED4, {});
  var sharedStore4 = store$34;
  var store$24 = sharedStore4;
  (shared$24.exports = function(key, value) {
    return store$24[key] || (store$24[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var hasOwnProperty6 = {}.hasOwnProperty;
  var has$a3 = function(it, key) {
    return hasOwnProperty6.call(it, key);
  };
  var id4 = 0;
  var postfix4 = Math.random();
  var uid$24 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id4 + postfix4).toString(36);
  };
  var fails$84 = fails$c3;
  var nativeSymbol4 = !!Object.getOwnPropertySymbols && !fails$84(function() {
    return !String(Symbol());
  });
  var NATIVE_SYMBOL$14 = nativeSymbol4;
  var useSymbolAsUid4 = NATIVE_SYMBOL$14 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var global$f4 = global$j3;
  var shared$14 = shared$24.exports;
  var has$94 = has$a3;
  var uid$14 = uid$24;
  var NATIVE_SYMBOL4 = nativeSymbol4;
  var USE_SYMBOL_AS_UID4 = useSymbolAsUid4;
  var WellKnownSymbolsStore4 = shared$14("wks");
  var Symbol$14 = global$f4.Symbol;
  var createWellKnownSymbol4 = USE_SYMBOL_AS_UID4 ? Symbol$14 : Symbol$14 && Symbol$14.withoutSetter || uid$14;
  var wellKnownSymbol$g2 = function(name) {
    if (!has$94(WellKnownSymbolsStore4, name)) {
      if (NATIVE_SYMBOL4 && has$94(Symbol$14, name)) WellKnownSymbolsStore4[name] = Symbol$14[name];
      else WellKnownSymbolsStore4[name] = createWellKnownSymbol4("Symbol." + name);
    }
    return WellKnownSymbolsStore4[name];
  };
  var ceil4 = Math.ceil;
  var floor$3 = Math.floor;
  var toInteger$42 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$3 : ceil4)(argument);
  };
  var toInteger$32 = toInteger$42;
  var min$2 = Math.min;
  var toLength$42 = function(argument) {
    return argument > 0 ? min$2(toInteger$32(argument), 9007199254740991) : 0;
  };
  var toInteger$24 = toInteger$42;
  var max$1 = Math.max;
  var min$14 = Math.min;
  var toAbsoluteIndex$14 = function(index, length) {
    var integer = toInteger$24(index);
    return integer < 0 ? max$1(integer + length, 0) : min$14(integer, length);
  };
  var toIndexedObject$34 = toIndexedObject$44;
  var toLength$33 = toLength$42;
  var toAbsoluteIndex4 = toAbsoluteIndex$14;
  var createMethod$13 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$34($this);
      var length = toLength$33(O.length);
      var index = toAbsoluteIndex4(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes4 = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod$13(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$13(false)
  };
  var hiddenKeys$44 = {};
  var has$84 = has$a3;
  var toIndexedObject$24 = toIndexedObject$44;
  var indexOf7 = arrayIncludes4.indexOf;
  var hiddenKeys$34 = hiddenKeys$44;
  var objectKeysInternal4 = function(object, names) {
    var O = toIndexedObject$24(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$84(hiddenKeys$34, key) && has$84(O, key) && result.push(key);
    while (names.length > i) if (has$84(O, key = names[i++])) {
      ~indexOf7(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$34 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$14 = objectKeysInternal4;
  var enumBugKeys$24 = enumBugKeys$34;
  var objectKeys$23 = Object.keys || function keys7(O) {
    return internalObjectKeys$14(O, enumBugKeys$24);
  };
  var DESCRIPTORS$44 = descriptors4;
  var definePropertyModule$44 = objectDefineProperty4;
  var anObject$c = anObject$e;
  var objectKeys$14 = objectKeys$23;
  var objectDefineProperties4 = DESCRIPTORS$44 ? Object.defineProperties : function defineProperties7(O, Properties) {
    anObject$c(O);
    var keys14 = objectKeys$14(Properties);
    var length = keys14.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$44.f(O, key = keys14[index++], Properties[key]);
    return O;
  };
  var global$e4 = global$j3;
  var path$14 = global$e4;
  var path4 = path$14;
  var global$d4 = global$j3;
  var aFunction$54 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$6 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction$54(path4[namespace]) || aFunction$54(global$d4[namespace]) : path4[namespace] && path4[namespace][method2] || global$d4[namespace] && global$d4[namespace][method2];
  };
  var getBuiltIn$54 = getBuiltIn$6;
  var html$24 = getBuiltIn$54("document", "documentElement");
  var shared4 = shared$24.exports;
  var uid4 = uid$24;
  var keys8 = shared4("keys");
  var sharedKey$34 = function(key) {
    return keys8[key] || (keys8[key] = uid4(key));
  };
  var anObject$b4 = anObject$e;
  var defineProperties$1 = objectDefineProperties4;
  var enumBugKeys$14 = enumBugKeys$34;
  var hiddenKeys$24 = hiddenKeys$44;
  var html$14 = html$24;
  var documentCreateElement4 = documentCreateElement$14;
  var sharedKey$24 = sharedKey$34;
  var GT4 = ">";
  var LT4 = "<";
  var PROTOTYPE4 = "prototype";
  var SCRIPT4 = "script";
  var IE_PROTO$14 = sharedKey$24("IE_PROTO");
  var EmptyConstructor4 = function() {
  };
  var scriptTag4 = function(content) {
    return LT4 + SCRIPT4 + GT4 + content + LT4 + "/" + SCRIPT4 + GT4;
  };
  var NullProtoObjectViaActiveX4 = function(activeXDocument5) {
    activeXDocument5.write(scriptTag4(""));
    activeXDocument5.close();
    var temp = activeXDocument5.parentWindow.Object;
    activeXDocument5 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame4 = function() {
    var iframe = documentCreateElement4("iframe");
    var JS = "java" + SCRIPT4 + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html$14.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag4("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument4;
  var NullProtoObject4 = function() {
    try {
      activeXDocument4 = document.domain && new ActiveXObject("htmlfile");
    } catch (error2) {
    }
    NullProtoObject4 = activeXDocument4 ? NullProtoObjectViaActiveX4(activeXDocument4) : NullProtoObjectViaIFrame4();
    var length = enumBugKeys$14.length;
    while (length--) delete NullProtoObject4[PROTOTYPE4][enumBugKeys$14[length]];
    return NullProtoObject4();
  };
  hiddenKeys$24[IE_PROTO$14] = true;
  var objectCreate4 = Object.create || function create7(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor4[PROTOTYPE4] = anObject$b4(O);
      result = new EmptyConstructor4();
      EmptyConstructor4[PROTOTYPE4] = null;
      result[IE_PROTO$14] = O;
    } else result = NullProtoObject4();
    return Properties === void 0 ? result : defineProperties$1(result, Properties);
  };
  var wellKnownSymbol$f3 = wellKnownSymbol$g2;
  var create$22 = objectCreate4;
  var definePropertyModule$34 = objectDefineProperty4;
  var UNSCOPABLES4 = wellKnownSymbol$f3("unscopables");
  var ArrayPrototype$14 = Array.prototype;
  if (ArrayPrototype$14[UNSCOPABLES4] == void 0) {
    definePropertyModule$34.f(ArrayPrototype$14, UNSCOPABLES4, {
      configurable: true,
      value: create$22(null)
    });
  }
  var addToUnscopables$14 = function(key) {
    ArrayPrototype$14[UNSCOPABLES4][key] = true;
  };
  var iterators4 = {};
  var store$14 = sharedStore4;
  var functionToString4 = Function.toString;
  if (typeof store$14.inspectSource != "function") {
    store$14.inspectSource = function(it) {
      return functionToString4.call(it);
    };
  }
  var inspectSource$34 = store$14.inspectSource;
  var global$c4 = global$j3;
  var inspectSource$24 = inspectSource$34;
  var WeakMap$14 = global$c4.WeakMap;
  var nativeWeakMap4 = typeof WeakMap$14 === "function" && /native code/.test(inspectSource$24(WeakMap$14));
  var NATIVE_WEAK_MAP4 = nativeWeakMap4;
  var global$b4 = global$j3;
  var isObject$44 = isObject$83;
  var createNonEnumerableProperty$64 = createNonEnumerableProperty$82;
  var objectHas4 = has$a3;
  var sharedKey$14 = sharedKey$34;
  var hiddenKeys$14 = hiddenKeys$44;
  var WeakMap5 = global$b4.WeakMap;
  var set$14;
  var get6;
  var has$74;
  var enforce4 = function(it) {
    return has$74(it) ? get6(it) : set$14(it, {});
  };
  var getterFor4 = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$44(it) || (state = get6(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP4) {
    store = new WeakMap5();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set$14 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get6 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$74 = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey$14("state");
    hiddenKeys$14[STATE] = true;
    set$14 = function(it, metadata) {
      createNonEnumerableProperty$64(it, STATE, metadata);
      return metadata;
    };
    get6 = function(it) {
      return objectHas4(it, STATE) ? it[STATE] : {};
    };
    has$74 = function(it) {
      return objectHas4(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState4 = {
    set: set$14,
    get: get6,
    has: has$74,
    enforce: enforce4,
    getterFor: getterFor4
  };
  var objectGetOwnPropertyDescriptor4 = {};
  var objectPropertyIsEnumerable4 = {};
  var nativePropertyIsEnumerable4 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$24 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG4 = getOwnPropertyDescriptor$24 && !nativePropertyIsEnumerable4.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable4.f = NASHORN_BUG4 ? function propertyIsEnumerable4(V) {
    var descriptor = getOwnPropertyDescriptor$24(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable4;
  var DESCRIPTORS$34 = descriptors4;
  var propertyIsEnumerableModule$13 = objectPropertyIsEnumerable4;
  var createPropertyDescriptor$34 = createPropertyDescriptor$5;
  var toIndexedObject$14 = toIndexedObject$44;
  var toPrimitive$14 = toPrimitive$32;
  var has$64 = has$a3;
  var IE8_DOM_DEFINE4 = ie8DomDefine4;
  var nativeGetOwnPropertyDescriptor4 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor4.f = DESCRIPTORS$34 ? nativeGetOwnPropertyDescriptor4 : function getOwnPropertyDescriptor8(O, P) {
    O = toIndexedObject$14(O);
    P = toPrimitive$14(P, true);
    if (IE8_DOM_DEFINE4) try {
      return nativeGetOwnPropertyDescriptor4(O, P);
    } catch (error2) {
    }
    if (has$64(O, P)) return createPropertyDescriptor$34(!propertyIsEnumerableModule$13.f.call(O, P), O[P]);
  };
  var redefine$8 = { exports: {} };
  var global$a4 = global$j3;
  var createNonEnumerableProperty$54 = createNonEnumerableProperty$82;
  var has$54 = has$a3;
  var setGlobal$14 = setGlobal$34;
  var inspectSource$14 = inspectSource$34;
  var InternalStateModule$5 = internalState4;
  var getInternalState$32 = InternalStateModule$5.get;
  var enforceInternalState4 = InternalStateModule$5.enforce;
  var TEMPLATE4 = String(String).split("String");
  (redefine$8.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$54(value, "name")) createNonEnumerableProperty$54(value, "name", key);
      enforceInternalState4(value).source = TEMPLATE4.join(typeof key == "string" ? key : "");
    }
    if (O === global$a4) {
      if (simple) O[key] = value;
      else setGlobal$14(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$54(O, key, value);
  })(Function.prototype, "toString", function toString11() {
    return typeof this == "function" && getInternalState$32(this).source || inspectSource$14(this);
  });
  var objectGetOwnPropertyNames4 = {};
  var internalObjectKeys4 = objectKeysInternal4;
  var enumBugKeys4 = enumBugKeys$34;
  var hiddenKeys4 = enumBugKeys4.concat("length", "prototype");
  objectGetOwnPropertyNames4.f = Object.getOwnPropertyNames || function getOwnPropertyNames5(O) {
    return internalObjectKeys4(O, hiddenKeys4);
  };
  var objectGetOwnPropertySymbols4 = {};
  objectGetOwnPropertySymbols4.f = Object.getOwnPropertySymbols;
  var getBuiltIn$44 = getBuiltIn$6;
  var getOwnPropertyNamesModule4 = objectGetOwnPropertyNames4;
  var getOwnPropertySymbolsModule$13 = objectGetOwnPropertySymbols4;
  var anObject$a4 = anObject$e;
  var ownKeys$14 = getBuiltIn$44("Reflect", "ownKeys") || function ownKeys7(it) {
    var keys14 = getOwnPropertyNamesModule4.f(anObject$a4(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$13.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has$44 = has$a3;
  var ownKeys8 = ownKeys$14;
  var getOwnPropertyDescriptorModule4 = objectGetOwnPropertyDescriptor4;
  var definePropertyModule$24 = objectDefineProperty4;
  var copyConstructorProperties$14 = function(target, source) {
    var keys14 = ownKeys8(source);
    var defineProperty14 = definePropertyModule$24.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule4.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has$44(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$74 = fails$c3;
  var replacement4 = /#|\.prototype\./;
  var isForced$24 = function(feature, detection) {
    var value = data4[normalize4(feature)];
    return value == POLYFILL4 ? true : value == NATIVE4 ? false : typeof detection == "function" ? fails$74(detection) : !!detection;
  };
  var normalize4 = isForced$24.normalize = function(string) {
    return String(string).replace(replacement4, ".").toLowerCase();
  };
  var data4 = isForced$24.data = {};
  var NATIVE4 = isForced$24.NATIVE = "N";
  var POLYFILL4 = isForced$24.POLYFILL = "P";
  var isForced_14 = isForced$24;
  var global$94 = global$j3;
  var getOwnPropertyDescriptor$14 = objectGetOwnPropertyDescriptor4.f;
  var createNonEnumerableProperty$44 = createNonEnumerableProperty$82;
  var redefine$7 = redefine$8.exports;
  var setGlobal4 = setGlobal$34;
  var copyConstructorProperties4 = copyConstructorProperties$14;
  var isForced$14 = isForced_14;
  var _export4 = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$94;
    } else if (STATIC) {
      target = global$94[TARGET] || setGlobal4(TARGET, {});
    } else {
      target = (global$94[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$14(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced$14(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties4(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$44(sourceProperty, "sham", true);
      }
      redefine$7(target, key, sourceProperty, options);
    }
  };
  var requireObjectCoercible$24 = requireObjectCoercible$42;
  var toObject$43 = function(argument) {
    return Object(requireObjectCoercible$24(argument));
  };
  var fails$64 = fails$c3;
  var correctPrototypeGetter4 = !fails$64(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  var has$34 = has$a3;
  var toObject$33 = toObject$43;
  var sharedKey4 = sharedKey$34;
  var CORRECT_PROTOTYPE_GETTER4 = correctPrototypeGetter4;
  var IE_PROTO4 = sharedKey4("IE_PROTO");
  var ObjectPrototype4 = Object.prototype;
  var objectGetPrototypeOf4 = CORRECT_PROTOTYPE_GETTER4 ? Object.getPrototypeOf : function(O) {
    O = toObject$33(O);
    if (has$34(O, IE_PROTO4)) return O[IE_PROTO4];
    if (typeof O.constructor == "function" && O instanceof O.constructor) {
      return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectPrototype4 : null;
  };
  var getPrototypeOf$14 = objectGetPrototypeOf4;
  var createNonEnumerableProperty$34 = createNonEnumerableProperty$82;
  var has$24 = has$a3;
  var wellKnownSymbol$e3 = wellKnownSymbol$g2;
  var ITERATOR$7 = wellKnownSymbol$e3("iterator");
  var BUGGY_SAFARI_ITERATORS$14 = false;
  var returnThis$24 = function() {
    return this;
  };
  var IteratorPrototype$24;
  var PrototypeOfArrayIteratorPrototype4;
  var arrayIterator4;
  if ([].keys) {
    arrayIterator4 = [].keys();
    if (!("next" in arrayIterator4)) BUGGY_SAFARI_ITERATORS$14 = true;
    else {
      PrototypeOfArrayIteratorPrototype4 = getPrototypeOf$14(getPrototypeOf$14(arrayIterator4));
      if (PrototypeOfArrayIteratorPrototype4 !== Object.prototype) IteratorPrototype$24 = PrototypeOfArrayIteratorPrototype4;
    }
  }
  if (IteratorPrototype$24 == void 0) IteratorPrototype$24 = {};
  if (!has$24(IteratorPrototype$24, ITERATOR$7)) {
    createNonEnumerableProperty$34(IteratorPrototype$24, ITERATOR$7, returnThis$24);
  }
  var iteratorsCore4 = {
    IteratorPrototype: IteratorPrototype$24,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$14
  };
  var defineProperty$13 = objectDefineProperty4.f;
  var has$14 = has$a3;
  var wellKnownSymbol$d4 = wellKnownSymbol$g2;
  var TO_STRING_TAG$34 = wellKnownSymbol$d4("toStringTag");
  var setToStringTag$5 = function(it, TAG, STATIC) {
    if (it && !has$14(it = STATIC ? it : it.prototype, TO_STRING_TAG$34)) {
      defineProperty$13(it, TO_STRING_TAG$34, { configurable: true, value: TAG });
    }
  };
  var IteratorPrototype$14 = iteratorsCore4.IteratorPrototype;
  var create$14 = objectCreate4;
  var createPropertyDescriptor$24 = createPropertyDescriptor$5;
  var setToStringTag$42 = setToStringTag$5;
  var Iterators$44 = iterators4;
  var returnThis$14 = function() {
    return this;
  };
  var createIteratorConstructor$2 = function(IteratorConstructor, NAME2, next3) {
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    IteratorConstructor.prototype = create$14(IteratorPrototype$14, { next: createPropertyDescriptor$24(1, next3) });
    setToStringTag$42(IteratorConstructor, TO_STRING_TAG5, false);
    Iterators$44[TO_STRING_TAG5] = returnThis$14;
    return IteratorConstructor;
  };
  var isObject$34 = isObject$83;
  var aPossiblePrototype$14 = function(it) {
    if (!isObject$34(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + " as a prototype");
    }
    return it;
  };
  var anObject$94 = anObject$e;
  var aPossiblePrototype4 = aPossiblePrototype$14;
  var objectSetPrototypeOf4 = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test5 = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
      setter.call(test5, []);
      CORRECT_SETTER = test5 instanceof Array;
    } catch (error2) {
    }
    return function setPrototypeOf5(O, proto) {
      anObject$94(O);
      aPossiblePrototype4(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  })() : void 0);
  var $$63 = _export4;
  var createIteratorConstructor$14 = createIteratorConstructor$2;
  var getPrototypeOf4 = objectGetPrototypeOf4;
  var setPrototypeOf4 = objectSetPrototypeOf4;
  var setToStringTag$34 = setToStringTag$5;
  var createNonEnumerableProperty$24 = createNonEnumerableProperty$82;
  var redefine$6 = redefine$8.exports;
  var wellKnownSymbol$c4 = wellKnownSymbol$g2;
  var Iterators$34 = iterators4;
  var IteratorsCore4 = iteratorsCore4;
  var IteratorPrototype4 = IteratorsCore4.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS4 = IteratorsCore4.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$6 = wellKnownSymbol$c4("iterator");
  var KEYS4 = "keys";
  var VALUES4 = "values";
  var ENTRIES4 = "entries";
  var returnThis4 = function() {
    return this;
  };
  var defineIterator$2 = function(Iterable, NAME2, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED5) {
    createIteratorConstructor$14(IteratorConstructor, NAME2, next3);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS4 && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS4:
          return function keys14() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES4:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES4:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG5 = NAME2 + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$6] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS4 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf4(anyNativeIterator.call(new Iterable()));
      if (IteratorPrototype4 !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf4(CurrentIteratorPrototype) !== IteratorPrototype4) {
          if (setPrototypeOf4) {
            setPrototypeOf4(CurrentIteratorPrototype, IteratorPrototype4);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$6] != "function") {
            createNonEnumerableProperty$24(CurrentIteratorPrototype, ITERATOR$6, returnThis4);
          }
        }
        setToStringTag$34(CurrentIteratorPrototype, TO_STRING_TAG5, true);
      }
    }
    if (DEFAULT == VALUES4 && nativeIterator && nativeIterator.name !== VALUES4) {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return nativeIterator.call(this);
      };
    }
    if (IterablePrototype[ITERATOR$6] !== defaultIterator) {
      createNonEnumerableProperty$24(IterablePrototype, ITERATOR$6, defaultIterator);
    }
    Iterators$34[NAME2] = defaultIterator;
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES4),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS4),
        entries: getIterationMethod(ENTRIES4)
      };
      if (FORCED5) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS4 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$6(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $$63({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS4 || INCORRECT_VALUES_NAME }, methods);
    }
    return methods;
  };
  var toIndexedObject4 = toIndexedObject$44;
  var addToUnscopables4 = addToUnscopables$14;
  var Iterators$24 = iterators4;
  var InternalStateModule$42 = internalState4;
  var defineIterator$14 = defineIterator$2;
  var ARRAY_ITERATOR4 = "Array Iterator";
  var setInternalState$4 = InternalStateModule$42.set;
  var getInternalState$24 = InternalStateModule$42.getterFor(ARRAY_ITERATOR4);
  var es_array_iterator4 = defineIterator$14(Array, "Array", function(iterated, kind) {
    setInternalState$4(this, {
      type: ARRAY_ITERATOR4,
      target: toIndexedObject4(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState$24(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, "values");
  Iterators$24.Arguments = Iterators$24.Array;
  addToUnscopables4("keys");
  addToUnscopables4("values");
  addToUnscopables4("entries");
  var DESCRIPTORS$24 = descriptors4;
  var fails$54 = fails$c3;
  var objectKeys5 = objectKeys$23;
  var getOwnPropertySymbolsModule4 = objectGetOwnPropertySymbols4;
  var propertyIsEnumerableModule4 = objectPropertyIsEnumerable4;
  var toObject$23 = toObject$43;
  var IndexedObject4 = indexedObject4;
  var nativeAssign3 = Object.assign;
  var defineProperty9 = Object.defineProperty;
  var objectAssign3 = !nativeAssign3 || fails$54(function() {
    if (DESCRIPTORS$24 && nativeAssign3({ b: 1 }, nativeAssign3(defineProperty9({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty9(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return nativeAssign3({}, A)[symbol] != 7 || objectKeys5(nativeAssign3({}, B)).join("") != alphabet;
  }) ? function assign5(target, source) {
    var T = toObject$23(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule4.f;
    var propertyIsEnumerable7 = propertyIsEnumerableModule4.f;
    while (argumentsLength > index) {
      var S = IndexedObject4(arguments[index++]);
      var keys14 = getOwnPropertySymbols ? objectKeys5(S).concat(getOwnPropertySymbols(S)) : objectKeys5(S);
      var length = keys14.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys14[j++];
        if (!DESCRIPTORS$24 || propertyIsEnumerable7.call(S, key)) T[key] = S[key];
      }
    }
    return T;
  } : nativeAssign3;
  var $$53 = _export4;
  var assign$1 = objectAssign3;
  $$53({ target: "Object", stat: true, forced: Object.assign !== assign$1 }, {
    assign: assign$1
  });
  var global$84 = global$j3;
  var nativePromiseConstructor4 = global$84.Promise;
  var redefine$54 = redefine$8.exports;
  var redefineAll$22 = function(target, src, options) {
    for (var key in src) redefine$54(target, key, src[key], options);
    return target;
  };
  var getBuiltIn$34 = getBuiltIn$6;
  var definePropertyModule$14 = objectDefineProperty4;
  var wellKnownSymbol$b4 = wellKnownSymbol$g2;
  var DESCRIPTORS$14 = descriptors4;
  var SPECIES$32 = wellKnownSymbol$b4("species");
  var setSpecies$14 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$34(CONSTRUCTOR_NAME);
    var defineProperty14 = definePropertyModule$14.f;
    if (DESCRIPTORS$14 && Constructor && !Constructor[SPECIES$32]) {
      defineProperty14(Constructor, SPECIES$32, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  var aFunction$44 = function(it) {
    if (typeof it != "function") {
      throw TypeError(String(it) + " is not a function");
    }
    return it;
  };
  var anInstance$32 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
    }
    return it;
  };
  var iterate$24 = { exports: {} };
  var wellKnownSymbol$a4 = wellKnownSymbol$g2;
  var Iterators$14 = iterators4;
  var ITERATOR$54 = wellKnownSymbol$a4("iterator");
  var ArrayPrototype4 = Array.prototype;
  var isArrayIteratorMethod$22 = function(it) {
    return it !== void 0 && (Iterators$14.Array === it || ArrayPrototype4[ITERATOR$54] === it);
  };
  var aFunction$34 = aFunction$44;
  var functionBindContext4 = function(fn, that, length) {
    aFunction$34(fn);
    if (that === void 0) return fn;
    switch (length) {
      case 0:
        return function() {
          return fn.call(that);
        };
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var wellKnownSymbol$94 = wellKnownSymbol$g2;
  var TO_STRING_TAG$24 = wellKnownSymbol$94("toStringTag");
  var test4 = {};
  test4[TO_STRING_TAG$24] = "z";
  var toStringTagSupport4 = String(test4) === "[object z]";
  var TO_STRING_TAG_SUPPORT4 = toStringTagSupport4;
  var classofRaw4 = classofRaw$14;
  var wellKnownSymbol$84 = wellKnownSymbol$g2;
  var TO_STRING_TAG$14 = wellKnownSymbol$84("toStringTag");
  var CORRECT_ARGUMENTS4 = classofRaw4(/* @__PURE__ */ (function() {
    return arguments;
  })()) == "Arguments";
  var tryGet4 = function(it, key) {
    try {
      return it[key];
    } catch (error2) {
    }
  };
  var classof$63 = TO_STRING_TAG_SUPPORT4 ? classofRaw4 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet4(O = Object(it), TO_STRING_TAG$14)) == "string" ? tag : CORRECT_ARGUMENTS4 ? classofRaw4(O) : (result = classofRaw4(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
  };
  var classof$54 = classof$63;
  var Iterators4 = iterators4;
  var wellKnownSymbol$74 = wellKnownSymbol$g2;
  var ITERATOR$44 = wellKnownSymbol$74("iterator");
  var getIteratorMethod$4 = function(it) {
    if (it != void 0) return it[ITERATOR$44] || it["@@iterator"] || Iterators4[classof$54(it)];
  };
  var anObject$84 = anObject$e;
  var callWithSafeIterationClosing$2 = function(iterator, fn, value, ENTRIES5) {
    try {
      return ENTRIES5 ? fn(anObject$84(value)[0], value[1]) : fn(value);
    } catch (error2) {
      var returnMethod = iterator["return"];
      if (returnMethod !== void 0) anObject$84(returnMethod.call(iterator));
      throw error2;
    }
  };
  var anObject$74 = anObject$e;
  var isArrayIteratorMethod$14 = isArrayIteratorMethod$22;
  var toLength$24 = toLength$42;
  var bind$42 = functionBindContext4;
  var getIteratorMethod$3 = getIteratorMethod$4;
  var callWithSafeIterationClosing$14 = callWithSafeIterationClosing$2;
  var Result4 = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var iterate$14 = iterate$24.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bind$42(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next3, step;
    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod$3(iterable);
      if (typeof iterFn != "function") throw TypeError("Target is not iterable");
      if (isArrayIteratorMethod$14(iterFn)) {
        for (index = 0, length = toLength$24(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject$74(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result4) return result;
        }
        return new Result4(false);
      }
      iterator = iterFn.call(iterable);
    }
    next3 = iterator.next;
    while (!(step = next3.call(iterator)).done) {
      result = callWithSafeIterationClosing$14(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == "object" && result && result instanceof Result4) return result;
    }
    return new Result4(false);
  };
  iterate$14.stop = function(result) {
    return new Result4(true, result);
  };
  var wellKnownSymbol$64 = wellKnownSymbol$g2;
  var ITERATOR$34 = wellKnownSymbol$64("iterator");
  var SAFE_CLOSING4 = false;
  try {
    called = 0;
    iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING4 = true;
      }
    };
    iteratorWithReturn[ITERATOR$34] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error2) {
  }
  var called;
  var iteratorWithReturn;
  var checkCorrectnessOfIteration$14 = function(exec3, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING4) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$34] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec3(object);
    } catch (error2) {
    }
    return ITERATION_SUPPORT;
  };
  var anObject$64 = anObject$e;
  var aFunction$24 = aFunction$44;
  var wellKnownSymbol$54 = wellKnownSymbol$g2;
  var SPECIES$24 = wellKnownSymbol$54("species");
  var speciesConstructor$14 = function(O, defaultConstructor) {
    var C = anObject$64(O).constructor;
    var S;
    return C === void 0 || (S = anObject$64(C)[SPECIES$24]) == void 0 ? defaultConstructor : aFunction$24(S);
  };
  var getBuiltIn$24 = getBuiltIn$6;
  var engineUserAgent4 = getBuiltIn$24("navigator", "userAgent") || "";
  var userAgent$14 = engineUserAgent4;
  var engineIsIos4 = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent$14);
  var global$74 = global$j3;
  var fails$44 = fails$c3;
  var classof$44 = classofRaw$14;
  var bind$32 = functionBindContext4;
  var html4 = html$24;
  var createElement4 = documentCreateElement$14;
  var IS_IOS$14 = engineIsIos4;
  var location5 = global$74.location;
  var set5 = global$74.setImmediate;
  var clear4 = global$74.clearImmediate;
  var process$34 = global$74.process;
  var MessageChannel5 = global$74.MessageChannel;
  var Dispatch4 = global$74.Dispatch;
  var counter4 = 0;
  var queue6 = {};
  var ONREADYSTATECHANGE4 = "onreadystatechange";
  var defer4;
  var channel4;
  var port4;
  var run4 = function(id7) {
    if (queue6.hasOwnProperty(id7)) {
      var fn = queue6[id7];
      delete queue6[id7];
      fn();
    }
  };
  var runner4 = function(id7) {
    return function() {
      run4(id7);
    };
  };
  var listener4 = function(event) {
    run4(event.data);
  };
  var post4 = function(id7) {
    global$74.postMessage(id7 + "", location5.protocol + "//" + location5.host);
  };
  if (!set5 || !clear4) {
    set5 = function setImmediate2(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue6[++counter4] = function() {
        (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
      };
      defer4(counter4);
      return counter4;
    };
    clear4 = function clearImmediate(id7) {
      delete queue6[id7];
    };
    if (classof$44(process$34) == "process") {
      defer4 = function(id7) {
        process$34.nextTick(runner4(id7));
      };
    } else if (Dispatch4 && Dispatch4.now) {
      defer4 = function(id7) {
        Dispatch4.now(runner4(id7));
      };
    } else if (MessageChannel5 && !IS_IOS$14) {
      channel4 = new MessageChannel5();
      port4 = channel4.port2;
      channel4.port1.onmessage = listener4;
      defer4 = bind$32(port4.postMessage, port4, 1);
    } else if (global$74.addEventListener && typeof postMessage == "function" && !global$74.importScripts && !fails$44(post4) && location5.protocol !== "file:") {
      defer4 = post4;
      global$74.addEventListener("message", listener4, false);
    } else if (ONREADYSTATECHANGE4 in createElement4("script")) {
      defer4 = function(id7) {
        html4.appendChild(createElement4("script"))[ONREADYSTATECHANGE4] = function() {
          html4.removeChild(this);
          run4(id7);
        };
      };
    } else {
      defer4 = function(id7) {
        setTimeout(runner4(id7), 0);
      };
    }
  }
  var task$14 = {
    set: set5,
    clear: clear4
  };
  var global$64 = global$j3;
  var getOwnPropertyDescriptor9 = objectGetOwnPropertyDescriptor4.f;
  var classof$34 = classofRaw$14;
  var macrotask4 = task$14.set;
  var IS_IOS4 = engineIsIos4;
  var MutationObserver4 = global$64.MutationObserver || global$64.WebKitMutationObserver;
  var process$24 = global$64.process;
  var Promise$14 = global$64.Promise;
  var IS_NODE$14 = classof$34(process$24) == "process";
  var queueMicrotaskDescriptor4 = getOwnPropertyDescriptor9(global$64, "queueMicrotask");
  var queueMicrotask5 = queueMicrotaskDescriptor4 && queueMicrotaskDescriptor4.value;
  var flush4;
  var head4;
  var last4;
  var notify$14;
  var toggle4;
  var node4;
  var promise4;
  var then4;
  if (!queueMicrotask5) {
    flush4 = function() {
      var parent2, fn;
      if (IS_NODE$14 && (parent2 = process$24.domain)) parent2.exit();
      while (head4) {
        fn = head4.fn;
        head4 = head4.next;
        try {
          fn();
        } catch (error2) {
          if (head4) notify$14();
          else last4 = void 0;
          throw error2;
        }
      }
      last4 = void 0;
      if (parent2) parent2.enter();
    };
    if (IS_NODE$14) {
      notify$14 = function() {
        process$24.nextTick(flush4);
      };
    } else if (MutationObserver4 && !IS_IOS4) {
      toggle4 = true;
      node4 = document.createTextNode("");
      new MutationObserver4(flush4).observe(node4, { characterData: true });
      notify$14 = function() {
        node4.data = toggle4 = !toggle4;
      };
    } else if (Promise$14 && Promise$14.resolve) {
      promise4 = Promise$14.resolve(void 0);
      then4 = promise4.then;
      notify$14 = function() {
        then4.call(promise4, flush4);
      };
    } else {
      notify$14 = function() {
        macrotask4.call(global$64, flush4);
      };
    }
  }
  var microtask$14 = queueMicrotask5 || function(fn) {
    var task5 = { fn, next: void 0 };
    if (last4) last4.next = task5;
    if (!head4) {
      head4 = task5;
      notify$14();
    }
    last4 = task5;
  };
  var newPromiseCapability$24 = {};
  var aFunction$14 = aFunction$44;
  var PromiseCapability4 = function(C) {
    var resolve5, reject5;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve5 !== void 0 || reject5 !== void 0) throw TypeError("Bad Promise constructor");
      resolve5 = $$resolve;
      reject5 = $$reject;
    });
    this.resolve = aFunction$14(resolve5);
    this.reject = aFunction$14(reject5);
  };
  newPromiseCapability$24.f = function(C) {
    return new PromiseCapability4(C);
  };
  var anObject$54 = anObject$e;
  var isObject$24 = isObject$83;
  var newPromiseCapability$14 = newPromiseCapability$24;
  var promiseResolve$14 = function(C, x) {
    anObject$54(C);
    if (isObject$24(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$14.f(C);
    var resolve5 = promiseCapability.resolve;
    resolve5(x);
    return promiseCapability.promise;
  };
  var global$54 = global$j3;
  var hostReportErrors$14 = function(a, b) {
    var console2 = global$54.console;
    if (console2 && console2.error) {
      arguments.length === 1 ? console2.error(a) : console2.error(a, b);
    }
  };
  var perform$14 = function(exec3) {
    try {
      return { error: false, value: exec3() };
    } catch (error2) {
      return { error: true, value: error2 };
    }
  };
  var global$44 = global$j3;
  var userAgent4 = engineUserAgent4;
  var process$14 = global$44.process;
  var versions6 = process$14 && process$14.versions;
  var v84 = versions6 && versions6.v8;
  var match4;
  var version6;
  if (v84) {
    match4 = v84.split(".");
    version6 = match4[0] + match4[1];
  } else if (userAgent4) {
    match4 = userAgent4.match(/Edge\/(\d+)/);
    if (!match4 || match4[1] >= 74) {
      match4 = userAgent4.match(/Chrome\/(\d+)/);
      if (match4) version6 = match4[1];
    }
  }
  var engineV8Version4 = version6 && +version6;
  var $$43 = _export4;
  var global$34 = global$j3;
  var getBuiltIn$14 = getBuiltIn$6;
  var NativePromise4 = nativePromiseConstructor4;
  var redefine$44 = redefine$8.exports;
  var redefineAll$14 = redefineAll$22;
  var setToStringTag$24 = setToStringTag$5;
  var setSpecies4 = setSpecies$14;
  var isObject$14 = isObject$83;
  var aFunction4 = aFunction$44;
  var anInstance$22 = anInstance$32;
  var classof$24 = classofRaw$14;
  var inspectSource4 = inspectSource$34;
  var iterate4 = iterate$24.exports;
  var checkCorrectnessOfIteration4 = checkCorrectnessOfIteration$14;
  var speciesConstructor4 = speciesConstructor$14;
  var task4 = task$14.set;
  var microtask4 = microtask$14;
  var promiseResolve4 = promiseResolve$14;
  var hostReportErrors4 = hostReportErrors$14;
  var newPromiseCapabilityModule4 = newPromiseCapability$24;
  var perform4 = perform$14;
  var InternalStateModule$32 = internalState4;
  var isForced4 = isForced_14;
  var wellKnownSymbol$44 = wellKnownSymbol$g2;
  var V8_VERSION4 = engineV8Version4;
  var SPECIES$14 = wellKnownSymbol$44("species");
  var PROMISE4 = "Promise";
  var getInternalState$14 = InternalStateModule$32.get;
  var setInternalState$32 = InternalStateModule$32.set;
  var getInternalPromiseState4 = InternalStateModule$32.getterFor(PROMISE4);
  var PromiseConstructor4 = NativePromise4;
  var TypeError$14 = global$34.TypeError;
  var document$14 = global$34.document;
  var process5 = global$34.process;
  var $fetch$1 = getBuiltIn$14("fetch");
  var newPromiseCapability4 = newPromiseCapabilityModule4.f;
  var newGenericPromiseCapability4 = newPromiseCapability4;
  var IS_NODE4 = classof$24(process5) == "process";
  var DISPATCH_EVENT4 = !!(document$14 && document$14.createEvent && global$34.dispatchEvent);
  var UNHANDLED_REJECTION4 = "unhandledrejection";
  var REJECTION_HANDLED4 = "rejectionhandled";
  var PENDING4 = 0;
  var FULFILLED4 = 1;
  var REJECTED4 = 2;
  var HANDLED4 = 1;
  var UNHANDLED4 = 2;
  var Internal4;
  var OwnPromiseCapability4;
  var PromiseWrapper4;
  var nativeThen4;
  var FORCED4 = isForced4(PROMISE4, function() {
    var GLOBAL_CORE_JS_PROMISE = inspectSource4(PromiseConstructor4) !== String(PromiseConstructor4);
    if (!GLOBAL_CORE_JS_PROMISE) {
      if (V8_VERSION4 === 66) return true;
      if (!IS_NODE4 && typeof PromiseRejectionEvent != "function") return true;
    }
    if (V8_VERSION4 >= 51 && /native code/.test(PromiseConstructor4)) return false;
    var promise5 = PromiseConstructor4.resolve(1);
    var FakePromise = function(exec3) {
      exec3(function() {
      }, function() {
      });
    };
    var constructor = promise5.constructor = {};
    constructor[SPECIES$14] = FakePromise;
    return !(promise5.then(function() {
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION4 = FORCED4 || !checkCorrectnessOfIteration4(function(iterable) {
    PromiseConstructor4.all(iterable)["catch"](function() {
    });
  });
  var isThenable4 = function(it) {
    var then5;
    return isObject$14(it) && typeof (then5 = it.then) == "function" ? then5 : false;
  };
  var notify4 = function(promise5, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask4(function() {
      var value = state.value;
      var ok = state.state == FULFILLED4;
      var index = 0;
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve5 = reaction.resolve;
        var reject5 = reaction.reject;
        var domain2 = reaction.domain;
        var result, then5, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED4) onHandleUnhandled4(promise5, state);
              state.rejection = HANDLED4;
            }
            if (handler === true) result = value;
            else {
              if (domain2) domain2.enter();
              result = handler(value);
              if (domain2) {
                domain2.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject5(TypeError$14("Promise-chain cycle"));
            } else if (then5 = isThenable4(result)) {
              then5.call(result, resolve5, reject5);
            } else resolve5(result);
          } else reject5(value);
        } catch (error2) {
          if (domain2 && !exited) domain2.exit();
          reject5(error2);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled4(promise5, state);
    });
  };
  var dispatchEvent4 = function(name, promise5, reason) {
    var event, handler;
    if (DISPATCH_EVENT4) {
      event = document$14.createEvent("Event");
      event.promise = promise5;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$34.dispatchEvent(event);
    } else event = { promise: promise5, reason };
    if (handler = global$34["on" + name]) handler(event);
    else if (name === UNHANDLED_REJECTION4) hostReportErrors4("Unhandled promise rejection", reason);
  };
  var onUnhandled4 = function(promise5, state) {
    task4.call(global$34, function() {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled4(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform4(function() {
          if (IS_NODE4) {
            process5.emit("unhandledRejection", value, promise5);
          } else dispatchEvent4(UNHANDLED_REJECTION4, promise5, value);
        });
        state.rejection = IS_NODE4 || isUnhandled4(state) ? UNHANDLED4 : HANDLED4;
        if (result.error) throw result.value;
      }
    });
  };
  var isUnhandled4 = function(state) {
    return state.rejection !== HANDLED4 && !state.parent;
  };
  var onHandleUnhandled4 = function(promise5, state) {
    task4.call(global$34, function() {
      if (IS_NODE4) {
        process5.emit("rejectionHandled", promise5);
      } else dispatchEvent4(REJECTION_HANDLED4, promise5, state.value);
    });
  };
  var bind$24 = function(fn, promise5, state, unwrap) {
    return function(value) {
      fn(promise5, state, value, unwrap);
    };
  };
  var internalReject4 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED4;
    notify4(promise5, state, true);
  };
  var internalResolve4 = function(promise5, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (promise5 === value) throw TypeError$14("Promise can't be resolved itself");
      var then5 = isThenable4(value);
      if (then5) {
        microtask4(function() {
          var wrapper = { done: false };
          try {
            then5.call(
              value,
              bind$24(internalResolve4, promise5, wrapper, state),
              bind$24(internalReject4, promise5, wrapper, state)
            );
          } catch (error2) {
            internalReject4(promise5, wrapper, error2, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED4;
        notify4(promise5, state, false);
      }
    } catch (error2) {
      internalReject4(promise5, { done: false }, error2, state);
    }
  };
  if (FORCED4) {
    PromiseConstructor4 = function Promise2(executor) {
      anInstance$22(this, PromiseConstructor4, PROMISE4);
      aFunction4(executor);
      Internal4.call(this);
      var state = getInternalState$14(this);
      try {
        executor(bind$24(internalResolve4, this, state), bind$24(internalReject4, this, state));
      } catch (error2) {
        internalReject4(this, state, error2);
      }
    };
    Internal4 = function Promise2(executor) {
      setInternalState$32(this, {
        type: PROMISE4,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING4,
        value: void 0
      });
    };
    Internal4.prototype = redefineAll$14(PromiseConstructor4.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then5(onFulfilled, onRejected) {
        var state = getInternalPromiseState4(this);
        var reaction = newPromiseCapability4(speciesConstructor4(this, PromiseConstructor4));
        reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
        reaction.fail = typeof onRejected == "function" && onRejected;
        reaction.domain = IS_NODE4 ? process5.domain : void 0;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING4) notify4(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability4 = function() {
      var promise5 = new Internal4();
      var state = getInternalState$14(promise5);
      this.promise = promise5;
      this.resolve = bind$24(internalResolve4, promise5, state);
      this.reject = bind$24(internalReject4, promise5, state);
    };
    newPromiseCapabilityModule4.f = newPromiseCapability4 = function(C) {
      return C === PromiseConstructor4 || C === PromiseWrapper4 ? new OwnPromiseCapability4(C) : newGenericPromiseCapability4(C);
    };
    if (typeof NativePromise4 == "function") {
      nativeThen4 = NativePromise4.prototype.then;
      redefine$44(NativePromise4.prototype, "then", function then5(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor4(function(resolve5, reject5) {
          nativeThen4.call(that, resolve5, reject5);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      if (typeof $fetch$1 == "function") $$43({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch2(input) {
          return promiseResolve4(PromiseConstructor4, $fetch$1.apply(global$34, arguments));
        }
      });
    }
  }
  $$43({ global: true, wrap: true, forced: FORCED4 }, {
    Promise: PromiseConstructor4
  });
  setToStringTag$24(PromiseConstructor4, PROMISE4, false);
  setSpecies4(PROMISE4);
  PromiseWrapper4 = getBuiltIn$14(PROMISE4);
  $$43({ target: PROMISE4, stat: true, forced: FORCED4 }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject4(r) {
      var capability = newPromiseCapability4(this);
      capability.reject.call(void 0, r);
      return capability.promise;
    }
  });
  $$43({ target: PROMISE4, stat: true, forced: FORCED4 }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve4(x) {
      return promiseResolve4(this, x);
    }
  });
  $$43({ target: PROMISE4, stat: true, forced: INCORRECT_ITERATION4 }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all4(iterable) {
      var C = this;
      var capability = newPromiseCapability4(C);
      var resolve5 = capability.resolve;
      var reject5 = capability.reject;
      var result = perform4(function() {
        var $promiseResolve = aFunction4(C.resolve);
        var values2 = [];
        var counter5 = 0;
        var remaining = 1;
        iterate4(iterable, function(promise5) {
          var index = counter5++;
          var alreadyCalled = false;
          values2.push(void 0);
          remaining++;
          $promiseResolve.call(C, promise5).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve5(values2);
          }, reject5);
        });
        --remaining || resolve5(values2);
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race4(iterable) {
      var C = this;
      var capability = newPromiseCapability4(C);
      var reject5 = capability.reject;
      var result = perform4(function() {
        var $promiseResolve = aFunction4(C.resolve);
        iterate4(iterable, function(promise5) {
          $promiseResolve.call(C, promise5).then(capability.resolve, reject5);
        });
      });
      if (result.error) reject5(result.value);
      return capability.promise;
    }
  });
  var anObject$44 = anObject$e;
  var regexpFlags$12 = function() {
    var that = anObject$44(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var regexpStickyHelpers2 = {};
  var fails$34 = fails$c3;
  function RE2(s, f) {
    return RegExp(s, f);
  }
  regexpStickyHelpers2.UNSUPPORTED_Y = fails$34(function() {
    var re = RE2("a", "y");
    re.lastIndex = 2;
    return re.exec("abcd") != null;
  });
  regexpStickyHelpers2.BROKEN_CARET = fails$34(function() {
    var re = RE2("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") != null;
  });
  var regexpFlags4 = regexpFlags$12;
  var stickyHelpers2 = regexpStickyHelpers2;
  var nativeExec2 = RegExp.prototype.exec;
  var nativeReplace2 = String.prototype.replace;
  var patchedExec2 = nativeExec2;
  var UPDATES_LAST_INDEX_WRONG2 = (function() {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec2.call(re1, "a");
    nativeExec2.call(re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();
  var UNSUPPORTED_Y2 = stickyHelpers2.UNSUPPORTED_Y || stickyHelpers2.BROKEN_CARET;
  var NPCG_INCLUDED2 = /()??/.exec("")[1] !== void 0;
  var PATCH2 = UPDATES_LAST_INDEX_WRONG2 || NPCG_INCLUDED2 || UNSUPPORTED_Y2;
  if (PATCH2) {
    patchedExec2 = function exec3(str) {
      var re = this;
      var lastIndex, reCopy, match5, i;
      var sticky = UNSUPPORTED_Y2 && re.sticky;
      var flags6 = regexpFlags4.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;
      if (sticky) {
        flags6 = flags6.replace("y", "");
        if (flags6.indexOf("g") === -1) {
          flags6 += "g";
        }
        strCopy = String(str).slice(re.lastIndex);
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags6);
      }
      if (NPCG_INCLUDED2) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags6);
      }
      if (UPDATES_LAST_INDEX_WRONG2) lastIndex = re.lastIndex;
      match5 = nativeExec2.call(sticky ? reCopy : re, strCopy);
      if (sticky) {
        if (match5) {
          match5.input = match5.input.slice(charsAdded);
          match5[0] = match5[0].slice(charsAdded);
          match5.index = re.lastIndex;
          re.lastIndex += match5[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG2 && match5) {
        re.lastIndex = re.global ? match5.index + match5[0].length : lastIndex;
      }
      if (NPCG_INCLUDED2 && match5 && match5.length > 1) {
        nativeReplace2.call(match5[0], reCopy, function() {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === void 0) match5[i] = void 0;
          }
        });
      }
      return match5;
    };
  }
  var regexpExec$2 = patchedExec2;
  var $$33 = _export4;
  var exec2 = regexpExec$2;
  $$33({ target: "RegExp", proto: true, forced: /./.exec !== exec2 }, {
    exec: exec2
  });
  var redefine$34 = redefine$8.exports;
  var anObject$34 = anObject$e;
  var fails$24 = fails$c3;
  var flags3 = regexpFlags$12;
  var TO_STRING3 = "toString";
  var RegExpPrototype3 = RegExp.prototype;
  var nativeToString3 = RegExpPrototype3[TO_STRING3];
  var NOT_GENERIC3 = fails$24(function() {
    return nativeToString3.call({ source: "a", flags: "b" }) != "/a/b";
  });
  var INCORRECT_NAME3 = nativeToString3.name != TO_STRING3;
  if (NOT_GENERIC3 || INCORRECT_NAME3) {
    redefine$34(RegExp.prototype, TO_STRING3, function toString18() {
      var R = anObject$34(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype3) ? flags3.call(R) : rf);
      return "/" + p + "/" + f;
    }, { unsafe: true });
  }
  var redefine$24 = redefine$8.exports;
  var fails$14 = fails$c3;
  var wellKnownSymbol$34 = wellKnownSymbol$g2;
  var regexpExec$1 = regexpExec$2;
  var createNonEnumerableProperty$14 = createNonEnumerableProperty$82;
  var SPECIES4 = wellKnownSymbol$34("species");
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$14(function() {
    var re = /./;
    re.exec = function() {
      var result = [];
      result.groups = { a: "7" };
      return result;
    };
    return "".replace(re, "$<a>") !== "7";
  });
  var REPLACE_KEEPS_$0 = (function() {
    return "a".replace(/./, "$0") === "$0";
  })();
  var REPLACE = wellKnownSymbol$34("replace");
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
    if (/./[REPLACE]) {
      return /./[REPLACE]("a", "$0") === "";
    }
    return false;
  })();
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$14(function() {
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function() {
      return originalExec.apply(this, arguments);
    };
    var result = "ab".split(re);
    return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
  });
  var fixRegexpWellKnownSymbolLogic = function(KEY, length, exec3, sham) {
    var SYMBOL = wellKnownSymbol$34(KEY);
    var DELEGATES_TO_SYMBOL = !fails$14(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ""[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$14(function() {
      var execCalled = false;
      var re = /a/;
      if (KEY === "split") {
        re = {};
        re.constructor = {};
        re.constructor[SPECIES4] = function() {
          return re;
        };
        re.flags = "";
        re[SYMBOL] = /./[SYMBOL];
      }
      re.exec = function() {
        execCalled = true;
        return null;
      };
      re[SYMBOL]("");
      return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec3(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec$1) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }, {
        REPLACE_KEEPS_$0,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      });
      var stringMethod = methods[0];
      var regexMethod = methods[1];
      redefine$24(String.prototype, KEY, stringMethod);
      redefine$24(
        RegExp.prototype,
        SYMBOL,
        length == 2 ? function(string, arg) {
          return regexMethod.call(string, this, arg);
        } : function(string) {
          return regexMethod.call(string, this);
        }
      );
    }
    if (sham) createNonEnumerableProperty$14(RegExp.prototype[SYMBOL], "sham", true);
  };
  var toInteger$14 = toInteger$42;
  var requireObjectCoercible$14 = requireObjectCoercible$42;
  var createMethod5 = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = String(requireObjectCoercible$14($this));
      var position = toInteger$14(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
      first = S.charCodeAt(position);
      return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod5(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod5(true)
  };
  var charAt$1 = stringMultibyte.charAt;
  var advanceStringIndex$1 = function(S, index, unicode) {
    return index + (unicode ? charAt$1(S, index).length : 1);
  };
  var classof$14 = classofRaw$14;
  var regexpExec2 = regexpExec$2;
  var regexpExecAbstract = function(R, S) {
    var exec3 = R.exec;
    if (typeof exec3 === "function") {
      var result = exec3.call(R, S);
      if (typeof result !== "object") {
        throw TypeError("RegExp exec method returned something other than an Object or null");
      }
      return result;
    }
    if (classof$14(R) !== "RegExp") {
      throw TypeError("RegExp#exec called on incompatible receiver");
    }
    return regexpExec2.call(R, S);
  };
  var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
  var anObject$24 = anObject$e;
  var toObject$14 = toObject$43;
  var toLength$14 = toLength$42;
  var toInteger4 = toInteger$42;
  var requireObjectCoercible4 = requireObjectCoercible$42;
  var advanceStringIndex = advanceStringIndex$1;
  var regExpExec = regexpExecAbstract;
  var max4 = Math.max;
  var min4 = Math.min;
  var floor$2 = Math.floor;
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
  var maybeToString = function(it) {
    return it === void 0 ? it : String(it);
  };
  fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE2, nativeReplace3, maybeCallNative, reason) {
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
    var REPLACE_KEEPS_$02 = reason.REPLACE_KEEPS_$0;
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace2(searchValue, replaceValue) {
        var O = requireObjectCoercible4(this);
        var replacer2 = searchValue == void 0 ? void 0 : searchValue[REPLACE2];
        return replacer2 !== void 0 ? replacer2.call(searchValue, O, replaceValue) : nativeReplace3.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function(regexp, replaceValue) {
        if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 && REPLACE_KEEPS_$02 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
          var res = maybeCallNative(nativeReplace3, regexp, this, replaceValue);
          if (res.done) return res.value;
        }
        var rx = anObject$24(regexp);
        var S = String(this);
        var functionalReplace = typeof replaceValue === "function";
        if (!functionalReplace) replaceValue = String(replaceValue);
        var global2 = rx.global;
        if (global2) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;
          results.push(result);
          if (!global2) break;
          var matchStr = String(result[0]);
          if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength$14(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = "";
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = String(result[0]);
          var position = max4(min4(toInteger4(result.index), S.length), 0);
          var captures = [];
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
            var replacement7 = String(replaceValue.apply(void 0, replacerArgs));
          } else {
            replacement7 = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement7;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement7) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject$14(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return nativeReplace3.call(replacement7, symbols, function(match5, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return str.slice(0, position);
          case "'":
            return str.slice(tailPos);
          case "<":
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0) return match5;
            if (n > m) {
              var f = floor$2(n / 10);
              if (f === 0) return match5;
              if (f <= m) return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match5;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    }
  });
  var domIterables4 = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var global$24 = global$j3;
  var DOMIterables4 = domIterables4;
  var ArrayIteratorMethods4 = es_array_iterator4;
  var createNonEnumerableProperty4 = createNonEnumerableProperty$82;
  var wellKnownSymbol$24 = wellKnownSymbol$g2;
  var ITERATOR$24 = wellKnownSymbol$24("iterator");
  var TO_STRING_TAG4 = wellKnownSymbol$24("toStringTag");
  var ArrayValues4 = ArrayIteratorMethods4.values;
  for (COLLECTION_NAME in DOMIterables4) {
    Collection = global$24[COLLECTION_NAME];
    CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR$24] !== ArrayValues4) try {
        createNonEnumerableProperty4(CollectionPrototype, ITERATOR$24, ArrayValues4);
      } catch (error2) {
        CollectionPrototype[ITERATOR$24] = ArrayValues4;
      }
      if (!CollectionPrototype[TO_STRING_TAG4]) {
        createNonEnumerableProperty4(CollectionPrototype, TO_STRING_TAG4, COLLECTION_NAME);
      }
      if (DOMIterables4[COLLECTION_NAME]) for (METHOD_NAME in ArrayIteratorMethods4) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods4[METHOD_NAME]) try {
          createNonEnumerableProperty4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods4[METHOD_NAME]);
        } catch (error2) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods4[METHOD_NAME];
        }
      }
    }
  }
  var Collection;
  var CollectionPrototype;
  var METHOD_NAME;
  var COLLECTION_NAME;
  var charAt = stringMultibyte.charAt;
  var InternalStateModule$24 = internalState4;
  var defineIterator4 = defineIterator$2;
  var STRING_ITERATOR = "String Iterator";
  var setInternalState$22 = InternalStateModule$24.set;
  var getInternalState4 = InternalStateModule$24.getterFor(STRING_ITERATOR);
  defineIterator4(String, "String", function(iterated) {
    setInternalState$22(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    });
  }, function next() {
    var state = getInternalState4(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return { value: void 0, done: true };
    point = charAt(string, index);
    state.index += point.length;
    return { value: point, done: false };
  });
  var fails4 = fails$c3;
  var wellKnownSymbol$14 = wellKnownSymbol$g2;
  var IS_PURE = isPure;
  var ITERATOR$14 = wellKnownSymbol$14("iterator");
  var nativeUrl = !fails4(function() {
    var url = new URL("b?a=1&b=2&c=3", "http://a");
    var searchParams = url.searchParams;
    var result = "";
    url.pathname = "c%20d";
    searchParams.forEach(function(value, key) {
      searchParams["delete"]("b");
      result += key + value;
    });
    return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR$14] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
  });
  var toPrimitive4 = toPrimitive$32;
  var definePropertyModule4 = objectDefineProperty4;
  var createPropertyDescriptor$14 = createPropertyDescriptor$5;
  var createProperty$1 = function(object, key, value) {
    var propertyKey = toPrimitive4(key);
    if (propertyKey in object) definePropertyModule4.f(object, propertyKey, createPropertyDescriptor$14(0, value));
    else object[propertyKey] = value;
  };
  var bind$14 = functionBindContext4;
  var toObject4 = toObject$43;
  var callWithSafeIterationClosing4 = callWithSafeIterationClosing$2;
  var isArrayIteratorMethod4 = isArrayIteratorMethod$22;
  var toLength4 = toLength$42;
  var createProperty = createProperty$1;
  var getIteratorMethod$22 = getIteratorMethod$4;
  var arrayFrom$1 = function from4(arrayLike) {
    var O = toObject4(arrayLike);
    var C = typeof this == "function" ? this : Array;
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
    var mapping = mapfn !== void 0;
    var iteratorMethod = getIteratorMethod$22(O);
    var index = 0;
    var length, result, step, iterator, next3, value;
    if (mapping) mapfn = bind$14(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
    if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod4(iteratorMethod))) {
      iterator = iteratorMethod.call(O);
      next3 = iterator.next;
      result = new C();
      for (; !(step = next3.call(iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing4(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty(result, index, value);
      }
    } else {
      length = toLength4(O.length);
      result = new C(length);
      for (; length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty(result, index, value);
      }
    }
    result.length = index;
    return result;
  };
  var maxInt2 = 2147483647;
  var base2 = 36;
  var tMin2 = 1;
  var tMax2 = 26;
  var skew2 = 38;
  var damp2 = 700;
  var initialBias2 = 72;
  var initialN2 = 128;
  var delimiter2 = "-";
  var regexNonASCII2 = /[^\0-\u007E]/;
  var regexSeparators2 = /[.\u3002\uFF0E\uFF61]/g;
  var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
  var baseMinusTMin2 = base2 - tMin2;
  var floor$12 = Math.floor;
  var stringFromCharCode2 = String.fromCharCode;
  var ucs2decode2 = function(string) {
    var output = [];
    var counter5 = 0;
    var length = string.length;
    while (counter5 < length) {
      var value = string.charCodeAt(counter5++);
      if (value >= 55296 && value <= 56319 && counter5 < length) {
        var extra = string.charCodeAt(counter5++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter5--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  var digitToBasic2 = function(digit) {
    return digit + 22 + 75 * (digit < 26);
  };
  var adapt2 = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor$12(delta / damp2) : delta >> 1;
    delta += floor$12(delta / numPoints);
    for (; delta > baseMinusTMin2 * tMax2 >> 1; k += base2) {
      delta = floor$12(delta / baseMinusTMin2);
    }
    return floor$12(k + (baseMinusTMin2 + 1) * delta / (delta + skew2));
  };
  var encode2 = function(input) {
    var output = [];
    input = ucs2decode2(input);
    var inputLength = input.length;
    var n = initialN2;
    var delta = 0;
    var bias = initialBias2;
    var i, currentValue;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < 128) {
        output.push(stringFromCharCode2(currentValue));
      }
    }
    var basicLength = output.length;
    var handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter2);
    }
    while (handledCPCount < inputLength) {
      var m = maxInt2;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor$12((maxInt2 - delta) / handledCPCountPlusOne)) {
        throw RangeError(OVERFLOW_ERROR);
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue < n && ++delta > maxInt2) {
          throw RangeError(OVERFLOW_ERROR);
        }
        if (currentValue == n) {
          var q = delta;
          for (var k = base2; ; k += base2) {
            var t = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
            if (q < t) break;
            var qMinusT = q - t;
            var baseMinusT = base2 - t;
            output.push(stringFromCharCode2(digitToBasic2(t + qMinusT % baseMinusT)));
            q = floor$12(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode2(digitToBasic2(q)));
          bias = adapt2(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var stringPunycodeToAscii = function(input) {
    var encoded = [];
    var labels = input.toLowerCase().replace(regexSeparators2, ".").split(".");
    var i, label;
    for (i = 0; i < labels.length; i++) {
      label = labels[i];
      encoded.push(regexNonASCII2.test(label) ? "xn--" + encode2(label) : label);
    }
    return encoded.join(".");
  };
  var anObject$14 = anObject$e;
  var getIteratorMethod$14 = getIteratorMethod$4;
  var getIterator$1 = function(it) {
    var iteratorMethod = getIteratorMethod$14(it);
    if (typeof iteratorMethod != "function") {
      throw TypeError(String(it) + " is not iterable");
    }
    return anObject$14(iteratorMethod.call(it));
  };
  var $$23 = _export4;
  var getBuiltIn4 = getBuiltIn$6;
  var USE_NATIVE_URL$1 = nativeUrl;
  var redefine$14 = redefine$8.exports;
  var redefineAll4 = redefineAll$22;
  var setToStringTag$14 = setToStringTag$5;
  var createIteratorConstructor4 = createIteratorConstructor$2;
  var InternalStateModule$14 = internalState4;
  var anInstance$14 = anInstance$32;
  var hasOwn = has$a3;
  var bind5 = functionBindContext4;
  var classof4 = classof$63;
  var anObject4 = anObject$e;
  var isObject5 = isObject$83;
  var create8 = objectCreate4;
  var createPropertyDescriptor4 = createPropertyDescriptor$5;
  var getIterator = getIterator$1;
  var getIteratorMethod4 = getIteratorMethod$4;
  var wellKnownSymbol4 = wellKnownSymbol$g2;
  var $fetch4 = getBuiltIn4("fetch");
  var Headers = getBuiltIn4("Headers");
  var ITERATOR4 = wellKnownSymbol4("iterator");
  var URL_SEARCH_PARAMS = "URLSearchParams";
  var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
  var setInternalState$14 = InternalStateModule$14.set;
  var getInternalParamsState = InternalStateModule$14.getterFor(URL_SEARCH_PARAMS);
  var getInternalIteratorState = InternalStateModule$14.getterFor(URL_SEARCH_PARAMS_ITERATOR);
  var plus = /\+/g;
  var sequences = Array(4);
  var percentSequence = function(bytes) {
    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
  };
  var percentDecode = function(sequence) {
    try {
      return decodeURIComponent(sequence);
    } catch (error2) {
      return sequence;
    }
  };
  var deserialize = function(it) {
    var result = it.replace(plus, " ");
    var bytes = 4;
    try {
      return decodeURIComponent(result);
    } catch (error2) {
      while (bytes) {
        result = result.replace(percentSequence(bytes--), percentDecode);
      }
      return result;
    }
  };
  var find = /[!'()~]|%20/g;
  var replace = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+"
  };
  var replacer = function(match5) {
    return replace[match5];
  };
  var serialize2 = function(it) {
    return encodeURIComponent(it).replace(find, replacer);
  };
  var parseSearchParams = function(result, query) {
    if (query) {
      var attributes = query.split("&");
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = attribute.split("=");
          result.push({
            key: deserialize(entry.shift()),
            value: deserialize(entry.join("="))
          });
        }
      }
    }
  };
  var updateSearchParams = function(query) {
    this.entries.length = 0;
    parseSearchParams(this.entries, query);
  };
  var validateArgumentsLength = function(passed, required) {
    if (passed < required) throw TypeError("Not enough arguments");
  };
  var URLSearchParamsIterator = createIteratorConstructor4(function Iterator2(params, kind) {
    setInternalState$14(this, {
      type: URL_SEARCH_PARAMS_ITERATOR,
      iterator: getIterator(getInternalParamsState(params).entries),
      kind
    });
  }, "Iterator", function next2() {
    var state = getInternalIteratorState(this);
    var kind = state.kind;
    var step = state.iterator.next();
    var entry = step.value;
    if (!step.done) {
      step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
    }
    return step;
  });
  var URLSearchParamsConstructor = function URLSearchParams2() {
    anInstance$14(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    var init3 = arguments.length > 0 ? arguments[0] : void 0;
    var that = this;
    var entries2 = [];
    var iteratorMethod, iterator, next3, step, entryIterator, entryNext, first, second, key;
    setInternalState$14(that, {
      type: URL_SEARCH_PARAMS,
      entries: entries2,
      updateURL: function() {
      },
      updateSearchParams
    });
    if (init3 !== void 0) {
      if (isObject5(init3)) {
        iteratorMethod = getIteratorMethod4(init3);
        if (typeof iteratorMethod === "function") {
          iterator = iteratorMethod.call(init3);
          next3 = iterator.next;
          while (!(step = next3.call(iterator)).done) {
            entryIterator = getIterator(anObject4(step.value));
            entryNext = entryIterator.next;
            if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError("Expected sequence with length 2");
            entries2.push({ key: first.value + "", value: second.value + "" });
          }
        } else for (key in init3) if (hasOwn(init3, key)) entries2.push({ key, value: init3[key] + "" });
      } else {
        parseSearchParams(entries2, typeof init3 === "string" ? init3.charAt(0) === "?" ? init3.slice(1) : init3 : init3 + "");
      }
    }
  };
  var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
  redefineAll4(URLSearchParamsPrototype, {
    // `URLSearchParams.prototype.appent` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-append
    append: function append(name, value) {
      validateArgumentsLength(arguments.length, 2);
      var state = getInternalParamsState(this);
      state.entries.push({ key: name + "", value: value + "" });
      state.updateURL();
    },
    // `URLSearchParams.prototype.delete` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
    "delete": function(name) {
      validateArgumentsLength(arguments.length, 1);
      var state = getInternalParamsState(this);
      var entries2 = state.entries;
      var key = name + "";
      var index = 0;
      while (index < entries2.length) {
        if (entries2[index].key === key) entries2.splice(index, 1);
        else index++;
      }
      state.updateURL();
    },
    // `URLSearchParams.prototype.get` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-get
    get: function get7(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries2 = getInternalParamsState(this).entries;
      var key = name + "";
      var index = 0;
      for (; index < entries2.length; index++) {
        if (entries2[index].key === key) return entries2[index].value;
      }
      return null;
    },
    // `URLSearchParams.prototype.getAll` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
    getAll: function getAll(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries2 = getInternalParamsState(this).entries;
      var key = name + "";
      var result = [];
      var index = 0;
      for (; index < entries2.length; index++) {
        if (entries2[index].key === key) result.push(entries2[index].value);
      }
      return result;
    },
    // `URLSearchParams.prototype.has` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-has
    has: function has4(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries2 = getInternalParamsState(this).entries;
      var key = name + "";
      var index = 0;
      while (index < entries2.length) {
        if (entries2[index++].key === key) return true;
      }
      return false;
    },
    // `URLSearchParams.prototype.set` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-set
    set: function set6(name, value) {
      validateArgumentsLength(arguments.length, 1);
      var state = getInternalParamsState(this);
      var entries2 = state.entries;
      var found = false;
      var key = name + "";
      var val = value + "";
      var index = 0;
      var entry;
      for (; index < entries2.length; index++) {
        entry = entries2[index];
        if (entry.key === key) {
          if (found) entries2.splice(index--, 1);
          else {
            found = true;
            entry.value = val;
          }
        }
      }
      if (!found) entries2.push({ key, value: val });
      state.updateURL();
    },
    // `URLSearchParams.prototype.sort` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
    sort: function sort3() {
      var state = getInternalParamsState(this);
      var entries2 = state.entries;
      var slice4 = entries2.slice();
      var entry, entriesIndex, sliceIndex;
      entries2.length = 0;
      for (sliceIndex = 0; sliceIndex < slice4.length; sliceIndex++) {
        entry = slice4[sliceIndex];
        for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
          if (entries2[entriesIndex].key > entry.key) {
            entries2.splice(entriesIndex, 0, entry);
            break;
          }
        }
        if (entriesIndex === sliceIndex) entries2.push(entry);
      }
      state.updateURL();
    },
    // `URLSearchParams.prototype.forEach` method
    forEach: function forEach3(callback) {
      var entries2 = getInternalParamsState(this).entries;
      var boundFunction = bind5(callback, arguments.length > 1 ? arguments[1] : void 0, 3);
      var index = 0;
      var entry;
      while (index < entries2.length) {
        entry = entries2[index++];
        boundFunction(entry.value, entry.key, this);
      }
    },
    // `URLSearchParams.prototype.keys` method
    keys: function keys9() {
      return new URLSearchParamsIterator(this, "keys");
    },
    // `URLSearchParams.prototype.values` method
    values: function values() {
      return new URLSearchParamsIterator(this, "values");
    },
    // `URLSearchParams.prototype.entries` method
    entries: function entries() {
      return new URLSearchParamsIterator(this, "entries");
    }
  }, { enumerable: true });
  redefine$14(URLSearchParamsPrototype, ITERATOR4, URLSearchParamsPrototype.entries);
  redefine$14(URLSearchParamsPrototype, "toString", function toString12() {
    var entries2 = getInternalParamsState(this).entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries2.length) {
      entry = entries2[index++];
      result.push(serialize2(entry.key) + "=" + serialize2(entry.value));
    }
    return result.join("&");
  }, { enumerable: true });
  setToStringTag$14(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  $$23({ global: true, forced: !USE_NATIVE_URL$1 }, {
    URLSearchParams: URLSearchParamsConstructor
  });
  if (!USE_NATIVE_URL$1 && typeof $fetch4 == "function" && typeof Headers == "function") {
    $$23({ global: true, enumerable: true, forced: true }, {
      fetch: function fetch2(input) {
        var args = [input];
        var init3, body, headers;
        if (arguments.length > 1) {
          init3 = arguments[1];
          if (isObject5(init3)) {
            body = init3.body;
            if (classof4(body) === URL_SEARCH_PARAMS) {
              headers = init3.headers ? new Headers(init3.headers) : new Headers();
              if (!headers.has("content-type")) {
                headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              init3 = create8(init3, {
                body: createPropertyDescriptor4(0, String(body)),
                headers: createPropertyDescriptor4(0, headers)
              });
            }
          }
          args.push(init3);
        }
        return $fetch4.apply(this, args);
      }
    });
  }
  var web_urlSearchParams = {
    URLSearchParams: URLSearchParamsConstructor,
    getState: getInternalParamsState
  };
  var $$14 = _export4;
  var DESCRIPTORS4 = descriptors4;
  var USE_NATIVE_URL = nativeUrl;
  var global$14 = global$j3;
  var defineProperties8 = objectDefineProperties4;
  var redefine4 = redefine$8.exports;
  var anInstance4 = anInstance$32;
  var has5 = has$a3;
  var assign6 = objectAssign3;
  var arrayFrom = arrayFrom$1;
  var codeAt = stringMultibyte.codeAt;
  var toASCII2 = stringPunycodeToAscii;
  var setToStringTag4 = setToStringTag$5;
  var URLSearchParamsModule = web_urlSearchParams;
  var InternalStateModule4 = internalState4;
  var NativeURL = global$14.URL;
  var URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;
  var getInternalSearchParamsState = URLSearchParamsModule.getState;
  var setInternalState4 = InternalStateModule4.set;
  var getInternalURLState = InternalStateModule4.getterFor("URL");
  var floor5 = Math.floor;
  var pow2 = Math.pow;
  var INVALID_AUTHORITY = "Invalid authority";
  var INVALID_SCHEME = "Invalid scheme";
  var INVALID_HOST = "Invalid host";
  var INVALID_PORT = "Invalid port";
  var ALPHA = /[A-Za-z]/;
  var ALPHANUMERIC = /[\d+-.A-Za-z]/;
  var DIGIT = /\d/;
  var HEX_START = /^(0x|0X)/;
  var OCT = /^[0-7]+$/;
  var DEC = /^\d+$/;
  var HEX = /^[\dA-Fa-f]+$/;
  var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
  var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
  var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
  var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
  var EOF;
  var parseHost2 = function(url, input) {
    var result, codePoints, index;
    if (input.charAt(0) == "[") {
      if (input.charAt(input.length - 1) != "]") return INVALID_HOST;
      result = parseIPv6(input.slice(1, -1));
      if (!result) return INVALID_HOST;
      url.host = result;
    } else if (!isSpecial(url)) {
      if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
      result = "";
      codePoints = arrayFrom(input);
      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      url.host = result;
    } else {
      input = toASCII2(input);
      if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      url.host = result;
    }
  };
  var parseIPv4 = function(input) {
    var parts = input.split(".");
    var partsLength, numbers, index, part, radix, number, ipv4;
    if (parts.length && parts[parts.length - 1] == "") {
      parts.pop();
    }
    partsLength = parts.length;
    if (partsLength > 4) return input;
    numbers = [];
    for (index = 0; index < partsLength; index++) {
      part = parts[index];
      if (part == "") return input;
      radix = 10;
      if (part.length > 1 && part.charAt(0) == "0") {
        radix = HEX_START.test(part) ? 16 : 8;
        part = part.slice(radix == 8 ? 1 : 2);
      }
      if (part === "") {
        number = 0;
      } else {
        if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
        number = parseInt(part, radix);
      }
      numbers.push(number);
    }
    for (index = 0; index < partsLength; index++) {
      number = numbers[index];
      if (index == partsLength - 1) {
        if (number >= pow2(256, 5 - partsLength)) return null;
      } else if (number > 255) return null;
    }
    ipv4 = numbers.pop();
    for (index = 0; index < numbers.length; index++) {
      ipv4 += numbers[index] * pow2(256, 3 - index);
    }
    return ipv4;
  };
  var parseIPv6 = function(input) {
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var pointer = 0;
    var value, length, numbersSeen, ipv4Piece, number, swaps, swap3;
    var char = function() {
      return input.charAt(pointer);
    };
    if (char() == ":") {
      if (input.charAt(1) != ":") return;
      pointer += 2;
      pieceIndex++;
      compress = pieceIndex;
    }
    while (char()) {
      if (pieceIndex == 8) return;
      if (char() == ":") {
        if (compress !== null) return;
        pointer++;
        pieceIndex++;
        compress = pieceIndex;
        continue;
      }
      value = length = 0;
      while (length < 4 && HEX.test(char())) {
        value = value * 16 + parseInt(char(), 16);
        pointer++;
        length++;
      }
      if (char() == ".") {
        if (length == 0) return;
        pointer -= length;
        if (pieceIndex > 6) return;
        numbersSeen = 0;
        while (char()) {
          ipv4Piece = null;
          if (numbersSeen > 0) {
            if (char() == "." && numbersSeen < 4) pointer++;
            else return;
          }
          if (!DIGIT.test(char())) return;
          while (DIGIT.test(char())) {
            number = parseInt(char(), 10);
            if (ipv4Piece === null) ipv4Piece = number;
            else if (ipv4Piece == 0) return;
            else ipv4Piece = ipv4Piece * 10 + number;
            if (ipv4Piece > 255) return;
            pointer++;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          numbersSeen++;
          if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
        }
        if (numbersSeen != 4) return;
        break;
      } else if (char() == ":") {
        pointer++;
        if (!char()) return;
      } else if (char()) return;
      address[pieceIndex++] = value;
    }
    if (compress !== null) {
      swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex != 0 && swaps > 0) {
        swap3 = address[pieceIndex];
        address[pieceIndex--] = address[compress + swaps - 1];
        address[compress + --swaps] = swap3;
      }
    } else if (pieceIndex != 8) return;
    return address;
  };
  var findLongestZeroSequence = function(ipv6) {
    var maxIndex = null;
    var maxLength = 1;
    var currStart = null;
    var currLength = 0;
    var index = 0;
    for (; index < 8; index++) {
      if (ipv6[index] !== 0) {
        if (currLength > maxLength) {
          maxIndex = currStart;
          maxLength = currLength;
        }
        currStart = null;
        currLength = 0;
      } else {
        if (currStart === null) currStart = index;
        ++currLength;
      }
    }
    if (currLength > maxLength) {
      maxIndex = currStart;
      maxLength = currLength;
    }
    return maxIndex;
  };
  var serializeHost = function(host) {
    var result, index, compress, ignore0;
    if (typeof host == "number") {
      result = [];
      for (index = 0; index < 4; index++) {
        result.unshift(host % 256);
        host = floor5(host / 256);
      }
      return result.join(".");
    } else if (typeof host == "object") {
      result = "";
      compress = findLongestZeroSequence(host);
      for (index = 0; index < 8; index++) {
        if (ignore0 && host[index] === 0) continue;
        if (ignore0) ignore0 = false;
        if (compress === index) {
          result += index ? ":" : "::";
          ignore0 = true;
        } else {
          result += host[index].toString(16);
          if (index < 7) result += ":";
        }
      }
      return "[" + result + "]";
    }
    return host;
  };
  var C0ControlPercentEncodeSet = {};
  var fragmentPercentEncodeSet = assign6({}, C0ControlPercentEncodeSet, {
    " ": 1,
    '"': 1,
    "<": 1,
    ">": 1,
    "`": 1
  });
  var pathPercentEncodeSet = assign6({}, fragmentPercentEncodeSet, {
    "#": 1,
    "?": 1,
    "{": 1,
    "}": 1
  });
  var userinfoPercentEncodeSet = assign6({}, pathPercentEncodeSet, {
    "/": 1,
    ":": 1,
    ";": 1,
    "=": 1,
    "@": 1,
    "[": 1,
    "\\": 1,
    "]": 1,
    "^": 1,
    "|": 1
  });
  var percentEncode = function(char, set9) {
    var code = codeAt(char, 0);
    return code > 32 && code < 127 && !has5(set9, char) ? char : encodeURIComponent(char);
  };
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var isSpecial = function(url) {
    return has5(specialSchemes, url.scheme);
  };
  var includesCredentials = function(url) {
    return url.username != "" || url.password != "";
  };
  var cannotHaveUsernamePasswordPort = function(url) {
    return !url.host || url.cannotBeABaseURL || url.scheme == "file";
  };
  var isWindowsDriveLetter = function(string, normalized) {
    var second;
    return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ":" || !normalized && second == "|");
  };
  var startsWithWindowsDriveLetter = function(string) {
    var third;
    return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === "/" || third === "\\" || third === "?" || third === "#"));
  };
  var shortenURLsPath = function(url) {
    var path7 = url.path;
    var pathSize = path7.length;
    if (pathSize && (url.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path7[0], true))) {
      path7.pop();
    }
  };
  var isSingleDot = function(segment) {
    return segment === "." || segment.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(segment) {
    segment = segment.toLowerCase();
    return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
  };
  var SCHEME_START = {};
  var SCHEME = {};
  var NO_SCHEME = {};
  var SPECIAL_RELATIVE_OR_AUTHORITY = {};
  var PATH_OR_AUTHORITY = {};
  var RELATIVE = {};
  var RELATIVE_SLASH = {};
  var SPECIAL_AUTHORITY_SLASHES = {};
  var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
  var AUTHORITY = {};
  var HOST = {};
  var HOSTNAME = {};
  var PORT = {};
  var FILE = {};
  var FILE_SLASH = {};
  var FILE_HOST = {};
  var PATH_START = {};
  var PATH = {};
  var CANNOT_BE_A_BASE_URL_PATH = {};
  var QUERY = {};
  var FRAGMENT = {};
  var parseURL = function(url, input, stateOverride, base3) {
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = "";
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, char, bufferCodePoints, failure;
    if (!stateOverride) {
      url.scheme = "";
      url.username = "";
      url.password = "";
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
    }
    input = input.replace(TAB_AND_NEW_LINE, "");
    codePoints = arrayFrom(input);
    while (pointer <= codePoints.length) {
      char = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (char && ALPHA.test(char)) {
            buffer += char.toLowerCase();
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;
        case SCHEME:
          if (char && (ALPHANUMERIC.test(char) || char == "+" || char == "-" || char == ".")) {
            buffer += char.toLowerCase();
          } else if (char == ":") {
            if (stateOverride && (isSpecial(url) != has5(specialSchemes, buffer) || buffer == "file" && (includesCredentials(url) || url.port !== null) || url.scheme == "file" && !url.host)) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
              return;
            }
            buffer = "";
            if (url.scheme == "file") {
              state = FILE;
            } else if (isSpecial(url) && base3 && base3.scheme == url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (isSpecial(url)) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] == "/") {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              url.path.push("");
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = "";
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;
        case NO_SCHEME:
          if (!base3 || base3.cannotBeABaseURL && char != "#") return INVALID_SCHEME;
          if (base3.cannotBeABaseURL && char == "#") {
            url.scheme = base3.scheme;
            url.path = base3.path.slice();
            url.query = base3.query;
            url.fragment = "";
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base3.scheme == "file" ? FILE : RELATIVE;
          continue;
        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (char == "/" && codePoints[pointer + 1] == "/") {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          }
          break;
        case PATH_OR_AUTHORITY:
          if (char == "/") {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }
        case RELATIVE:
          url.scheme = base3.scheme;
          if (char == EOF) {
            url.username = base3.username;
            url.password = base3.password;
            url.host = base3.host;
            url.port = base3.port;
            url.path = base3.path.slice();
            url.query = base3.query;
          } else if (char == "/" || char == "\\" && isSpecial(url)) {
            state = RELATIVE_SLASH;
          } else if (char == "?") {
            url.username = base3.username;
            url.password = base3.password;
            url.host = base3.host;
            url.port = base3.port;
            url.path = base3.path.slice();
            url.query = "";
            state = QUERY;
          } else if (char == "#") {
            url.username = base3.username;
            url.password = base3.password;
            url.host = base3.host;
            url.port = base3.port;
            url.path = base3.path.slice();
            url.query = base3.query;
            url.fragment = "";
            state = FRAGMENT;
          } else {
            url.username = base3.username;
            url.password = base3.password;
            url.host = base3.host;
            url.port = base3.port;
            url.path = base3.path.slice();
            url.path.pop();
            state = PATH;
            continue;
          }
          break;
        case RELATIVE_SLASH:
          if (isSpecial(url) && (char == "/" || char == "\\")) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (char == "/") {
            state = AUTHORITY;
          } else {
            url.username = base3.username;
            url.password = base3.password;
            url.host = base3.host;
            url.port = base3.port;
            state = PATH;
            continue;
          }
          break;
        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (char != "/" || buffer.charAt(pointer + 1) != "/") continue;
          pointer++;
          break;
        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (char != "/" && char != "\\") {
            state = AUTHORITY;
            continue;
          }
          break;
        case AUTHORITY:
          if (char == "@") {
            if (seenAt) buffer = "%40" + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint == ":" && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = "";
          } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
            if (seenAt && buffer == "") return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = "";
            state = HOST;
          } else buffer += char;
          break;
        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme == "file") {
            state = FILE_HOST;
            continue;
          } else if (char == ":" && !seenBracket) {
            if (buffer == "") return INVALID_HOST;
            failure = parseHost2(url, buffer);
            if (failure) return failure;
            buffer = "";
            state = PORT;
            if (stateOverride == HOSTNAME) return;
          } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
            if (isSpecial(url) && buffer == "") return INVALID_HOST;
            if (stateOverride && buffer == "" && (includesCredentials(url) || url.port !== null)) return;
            failure = parseHost2(url, buffer);
            if (failure) return failure;
            buffer = "";
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (char == "[") seenBracket = true;
            else if (char == "]") seenBracket = false;
            buffer += char;
          }
          break;
        case PORT:
          if (DIGIT.test(char)) {
            buffer += char;
          } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url) || stateOverride) {
            if (buffer != "") {
              var port5 = parseInt(buffer, 10);
              if (port5 > 65535) return INVALID_PORT;
              url.port = isSpecial(url) && port5 === specialSchemes[url.scheme] ? null : port5;
              buffer = "";
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;
        case FILE:
          url.scheme = "file";
          if (char == "/" || char == "\\") state = FILE_SLASH;
          else if (base3 && base3.scheme == "file") {
            if (char == EOF) {
              url.host = base3.host;
              url.path = base3.path.slice();
              url.query = base3.query;
            } else if (char == "?") {
              url.host = base3.host;
              url.path = base3.path.slice();
              url.query = "";
              state = QUERY;
            } else if (char == "#") {
              url.host = base3.host;
              url.path = base3.path.slice();
              url.query = base3.query;
              url.fragment = "";
              state = FRAGMENT;
            } else {
              if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
                url.host = base3.host;
                url.path = base3.path.slice();
                shortenURLsPath(url);
              }
              state = PATH;
              continue;
            }
          } else {
            state = PATH;
            continue;
          }
          break;
        case FILE_SLASH:
          if (char == "/" || char == "\\") {
            state = FILE_HOST;
            break;
          }
          if (base3 && base3.scheme == "file" && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
            if (isWindowsDriveLetter(base3.path[0], true)) url.path.push(base3.path[0]);
            else url.host = base3.host;
          }
          state = PATH;
          continue;
        case FILE_HOST:
          if (char == EOF || char == "/" || char == "\\" || char == "?" || char == "#") {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer == "") {
              url.host = "";
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = parseHost2(url, buffer);
              if (failure) return failure;
              if (url.host == "localhost") url.host = "";
              if (stateOverride) return;
              buffer = "";
              state = PATH_START;
            }
            continue;
          } else buffer += char;
          break;
        case PATH_START:
          if (isSpecial(url)) {
            state = PATH;
            if (char != "/" && char != "\\") continue;
          } else if (!stateOverride && char == "?") {
            url.query = "";
            state = QUERY;
          } else if (!stateOverride && char == "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (char != EOF) {
            state = PATH;
            if (char != "/") continue;
          }
          break;
        case PATH:
          if (char == EOF || char == "/" || char == "\\" && isSpecial(url) || !stateOverride && (char == "?" || char == "#")) {
            if (isDoubleDot(buffer)) {
              shortenURLsPath(url);
              if (char != "/" && !(char == "\\" && isSpecial(url))) {
                url.path.push("");
              }
            } else if (isSingleDot(buffer)) {
              if (char != "/" && !(char == "\\" && isSpecial(url))) {
                url.path.push("");
              }
            } else {
              if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = "";
                buffer = buffer.charAt(0) + ":";
              }
              url.path.push(buffer);
            }
            buffer = "";
            if (url.scheme == "file" && (char == EOF || char == "?" || char == "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                url.path.shift();
              }
            }
            if (char == "?") {
              url.query = "";
              state = QUERY;
            } else if (char == "#") {
              url.fragment = "";
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(char, pathPercentEncodeSet);
          }
          break;
        case CANNOT_BE_A_BASE_URL_PATH:
          if (char == "?") {
            url.query = "";
            state = QUERY;
          } else if (char == "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (char != EOF) {
            url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
          }
          break;
        case QUERY:
          if (!stateOverride && char == "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (char != EOF) {
            if (char == "'" && isSpecial(url)) url.query += "%27";
            else if (char == "#") url.query += "%23";
            else url.query += percentEncode(char, C0ControlPercentEncodeSet);
          }
          break;
        case FRAGMENT:
          if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
          break;
      }
      pointer++;
    }
  };
  var URLConstructor = function URL2(url) {
    var that = anInstance4(this, URLConstructor, "URL");
    var base3 = arguments.length > 1 ? arguments[1] : void 0;
    var urlString = String(url);
    var state = setInternalState4(that, { type: "URL" });
    var baseState, failure;
    if (base3 !== void 0) {
      if (base3 instanceof URLConstructor) baseState = getInternalURLState(base3);
      else {
        failure = parseURL(baseState = {}, String(base3));
        if (failure) throw TypeError(failure);
      }
    }
    failure = parseURL(state, urlString, null, baseState);
    if (failure) throw TypeError(failure);
    var searchParams = state.searchParams = new URLSearchParams$1();
    var searchParamsState = getInternalSearchParamsState(searchParams);
    searchParamsState.updateSearchParams(state.query);
    searchParamsState.updateURL = function() {
      state.query = String(searchParams) || null;
    };
    if (!DESCRIPTORS4) {
      that.href = serializeURL.call(that);
      that.origin = getOrigin.call(that);
      that.protocol = getProtocol.call(that);
      that.username = getUsername.call(that);
      that.password = getPassword.call(that);
      that.host = getHost.call(that);
      that.hostname = getHostname.call(that);
      that.port = getPort.call(that);
      that.pathname = getPathname.call(that);
      that.search = getSearch.call(that);
      that.searchParams = getSearchParams.call(that);
      that.hash = getHash.call(that);
    }
  };
  var URLPrototype = URLConstructor.prototype;
  var serializeURL = function() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port5 = url.port;
    var path7 = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ":";
    if (host !== null) {
      output += "//";
      if (includesCredentials(url)) {
        output += username + (password ? ":" + password : "") + "@";
      }
      output += serializeHost(host);
      if (port5 !== null) output += ":" + port5;
    } else if (scheme == "file") output += "//";
    output += url.cannotBeABaseURL ? path7[0] : path7.length ? "/" + path7.join("/") : "";
    if (query !== null) output += "?" + query;
    if (fragment !== null) output += "#" + fragment;
    return output;
  };
  var getOrigin = function() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var port5 = url.port;
    if (scheme == "blob") try {
      return new URL(scheme.path[0]).origin;
    } catch (error2) {
      return "null";
    }
    if (scheme == "file" || !isSpecial(url)) return "null";
    return scheme + "://" + serializeHost(url.host) + (port5 !== null ? ":" + port5 : "");
  };
  var getProtocol = function() {
    return getInternalURLState(this).scheme + ":";
  };
  var getUsername = function() {
    return getInternalURLState(this).username;
  };
  var getPassword = function() {
    return getInternalURLState(this).password;
  };
  var getHost = function() {
    var url = getInternalURLState(this);
    var host = url.host;
    var port5 = url.port;
    return host === null ? "" : port5 === null ? serializeHost(host) : serializeHost(host) + ":" + port5;
  };
  var getHostname = function() {
    var host = getInternalURLState(this).host;
    return host === null ? "" : serializeHost(host);
  };
  var getPort = function() {
    var port5 = getInternalURLState(this).port;
    return port5 === null ? "" : String(port5);
  };
  var getPathname = function() {
    var url = getInternalURLState(this);
    var path7 = url.path;
    return url.cannotBeABaseURL ? path7[0] : path7.length ? "/" + path7.join("/") : "";
  };
  var getSearch = function() {
    var query = getInternalURLState(this).query;
    return query ? "?" + query : "";
  };
  var getSearchParams = function() {
    return getInternalURLState(this).searchParams;
  };
  var getHash = function() {
    var fragment = getInternalURLState(this).fragment;
    return fragment ? "#" + fragment : "";
  };
  var accessorDescriptor = function(getter, setter) {
    return { get: getter, set: setter, configurable: true, enumerable: true };
  };
  if (DESCRIPTORS4) {
    defineProperties8(URLPrototype, {
      // `URL.prototype.href` accessors pair
      // https://url.spec.whatwg.org/#dom-url-href
      href: accessorDescriptor(serializeURL, function(href) {
        var url = getInternalURLState(this);
        var urlString = String(href);
        var failure = parseURL(url, urlString);
        if (failure) throw TypeError(failure);
        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
      }),
      // `URL.prototype.origin` getter
      // https://url.spec.whatwg.org/#dom-url-origin
      origin: accessorDescriptor(getOrigin),
      // `URL.prototype.protocol` accessors pair
      // https://url.spec.whatwg.org/#dom-url-protocol
      protocol: accessorDescriptor(getProtocol, function(protocol) {
        var url = getInternalURLState(this);
        parseURL(url, String(protocol) + ":", SCHEME_START);
      }),
      // `URL.prototype.username` accessors pair
      // https://url.spec.whatwg.org/#dom-url-username
      username: accessorDescriptor(getUsername, function(username) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom(String(username));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.username = "";
        for (var i = 0; i < codePoints.length; i++) {
          url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      }),
      // `URL.prototype.password` accessors pair
      // https://url.spec.whatwg.org/#dom-url-password
      password: accessorDescriptor(getPassword, function(password) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom(String(password));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.password = "";
        for (var i = 0; i < codePoints.length; i++) {
          url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      }),
      // `URL.prototype.host` accessors pair
      // https://url.spec.whatwg.org/#dom-url-host
      host: accessorDescriptor(getHost, function(host) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, String(host), HOST);
      }),
      // `URL.prototype.hostname` accessors pair
      // https://url.spec.whatwg.org/#dom-url-hostname
      hostname: accessorDescriptor(getHostname, function(hostname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, String(hostname), HOSTNAME);
      }),
      // `URL.prototype.port` accessors pair
      // https://url.spec.whatwg.org/#dom-url-port
      port: accessorDescriptor(getPort, function(port5) {
        var url = getInternalURLState(this);
        if (cannotHaveUsernamePasswordPort(url)) return;
        port5 = String(port5);
        if (port5 == "") url.port = null;
        else parseURL(url, port5, PORT);
      }),
      // `URL.prototype.pathname` accessors pair
      // https://url.spec.whatwg.org/#dom-url-pathname
      pathname: accessorDescriptor(getPathname, function(pathname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        url.path = [];
        parseURL(url, pathname + "", PATH_START);
      }),
      // `URL.prototype.search` accessors pair
      // https://url.spec.whatwg.org/#dom-url-search
      search: accessorDescriptor(getSearch, function(search) {
        var url = getInternalURLState(this);
        search = String(search);
        if (search == "") {
          url.query = null;
        } else {
          if ("?" == search.charAt(0)) search = search.slice(1);
          url.query = "";
          parseURL(url, search, QUERY);
        }
        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
      }),
      // `URL.prototype.searchParams` getter
      // https://url.spec.whatwg.org/#dom-url-searchparams
      searchParams: accessorDescriptor(getSearchParams),
      // `URL.prototype.hash` accessors pair
      // https://url.spec.whatwg.org/#dom-url-hash
      hash: accessorDescriptor(getHash, function(hash) {
        var url = getInternalURLState(this);
        hash = String(hash);
        if (hash == "") {
          url.fragment = null;
          return;
        }
        if ("#" == hash.charAt(0)) hash = hash.slice(1);
        url.fragment = "";
        parseURL(url, hash, FRAGMENT);
      })
    });
  }
  redefine4(URLPrototype, "toJSON", function toJSON3() {
    return serializeURL.call(this);
  }, { enumerable: true });
  redefine4(URLPrototype, "toString", function toString13() {
    return serializeURL.call(this);
  }, { enumerable: true });
  if (NativeURL) {
    nativeCreateObjectURL = NativeURL.createObjectURL;
    nativeRevokeObjectURL = NativeURL.revokeObjectURL;
    if (nativeCreateObjectURL) redefine4(URLConstructor, "createObjectURL", function createObjectURL(blob) {
      return nativeCreateObjectURL.apply(NativeURL, arguments);
    });
    if (nativeRevokeObjectURL) redefine4(URLConstructor, "revokeObjectURL", function revokeObjectURL(url) {
      return nativeRevokeObjectURL.apply(NativeURL, arguments);
    });
  }
  var nativeCreateObjectURL;
  var nativeRevokeObjectURL;
  setToStringTag4(URLConstructor, "URL");
  $$14({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS4 }, {
    URL: URLConstructor
  });
  var $4 = _export4;
  $4({ target: "URL", proto: true, enumerable: true }, {
    toJSON: function toJSON4() {
      return URL.prototype.toString.call(this);
    }
  });
  function __awaiter3(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject5) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject5(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject5(e);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  var icon = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAD8UExURUdwTGx5rpLO8YOYx1Og0ly29X5ezR4mT0tiji4eWJ953KGn1Jxs7qB9xvfD/Us0gduu8yeh4HOq74dD647R91256eSz+j82cbvg/dSj/LuL79Wp6zCf24KN9xANGRANF59d/0W+/taa/8iN/3HL9uOn/z638Bil7l3G84TP+FHB8o5A/0i9/ZjU+47S+vq8/4Qy/S6w8O+x/5Rp/wyg7G2T/s+T/vO2/+qt/1qp/qDV/HyD/ki4+4R7/qnY/tyh/1Gx/ptU/76E/2bJ9Ld8/4t0/pxe+XvN9iOq7rB0/0i88aRk/6ps/z++/naL/mab/mGh/pVM/wub5mGd+fAEOhEAAAAgdFJOUwBEyWKA47EKJhnFluGA6l3H67Du6crdNOXs5q/I65rcQbfB9AAAIABJREFUeNrsnE9r4zoXxidOG9tNQqBvSrLKeKGF7WIz4J0WgSCuDc1s7vf/Mq/+S0d2p7Zkd7i0SsZJh3th+PGcR4+OpP748T3+4yNODofDKY2/SYxgdbhcfl4ul9M3rY9ZpZefbFwu6TeMD8dJwPp5Sb6l9eFIL5zW5TDoWrEc35wEjtOFDWPxjE2aJMkqWa3W6/WevuigPyVJ+tWngTg+HQ58PmSDQlqvt5Eax+jIBv2UY7umyL6u0JiMBK6DpETp4KqmL/ngX9hnwcEJYl8TGIV1EpzOEaNUCUBqFPwPfRX0W8GfFSPGgX255JCcTpwUByVY1WAU/FHwLxRWV3RdIYGtvhIvKqoVI0WriwoGK1CDvLi8JDouse5L8YqT08M2Op+vVFOYl54wJ+5PkppkJUkJZYlipN9RV1Ne69UXmCOT0zY6Xq+4Kip7GEYGmKZVyNF1ghj9whx//ZfltXQYTE/b8xnTUeFr1R82Lm7vwuPh6Cgz9jr+TVx8Mt+zcTgt0w6Ik310xIJVJXxdUaqgsIzH1w6tjlekxrVdpX/FSlb7zW63a+lrt3vazG8JFiqHVa2ewOQLlR70W1oX58XlhSiv7aerKz4xUvd7Rse9pWO32xxm/VfE6To64yt1KyEsgUt8ckT99GDsHUpL6oq9EaKT4+cWY5weNrvfbZtlNwqLfkpcM0o8XtFMhZlRUT7YYDLKEtmhsurQJNO6R0sEL0brk3FRWe3+ydpMDvblzpDtnvYz/SPihIYFzHRFYYE6xMazBnJWYTyrhsri4uqEfSESPX+WdcWnza7NbjemKyYpVob/Ml5Zu9vP0cmME1aBxZXDuSpdKWSGlK0qxUqteSxUphA7hLoOsednWVe8YiV4y34zTYkX9a4bhXejtbgJp8VQcVmJuDA4Gyp7d2K8TFn1oGnJWbEjqO5ywnLE5+iK8mGyEnbFlMV0dWO1GEyLmhWdA1kKrdiTG7y2duPvss3QWx1qVLVLSxZiJwRWdOQTxJXsd9qrGKvMHsznn4JocbNic6B5KWW5wlLMBmbDesjcOzN4KZLj0uKKD7tWcslcVIJgiLbi1fasSYk3p2WUJTsOdsqqHGVBw9I5q7BQcVp0XlxYXKdNa4Tlqkp8/uNNi0UrzupqawsLd8cYqqoXSkHOqu0ED5SF1AshQo1+tRyteM+F1RhGjXy0oiwZLU9txWwdKEhpTKIIjWv1pDUQHGpXW66uUGfTWi8WIk5Pd6Ao5VqNNDCGq7170WIx9IqFqq4iuXNUVyWr95RVDeYsSKqwPEvSkrgQLcXFhHW/STz8T2uqz9DKfHwrPVisMP/GSV0tZdkxvq6qgf6fzu+1hQsoC+mwRQd/Pi5kXOnmt+Jh53fH4mkG220m/gOSh0gpyuBSVVhhuNxRsbRfh+5sCH1LCqpjvNg39kHYrLiIcfEqZHwah5DzM8tbk2glbBbEVgHKqVANMxViJzvApWFd9wOWcng9FSrHQtLpaUJdgFa8euqHheExzeWptRuzMgqzgpaO8bClVVXuhoXSVT0kLCEtwUo+mG2hxwVoxetdNhYW09YkXUFQ3LIMJ1OJGPJyFoiqVVrD6K6VpSdCpS0xlqjEdD8a1hRa8fYs8DiuBUrRpSWF1e/+DbSzrCq0YpaaDjv2mJ9Wutll9w8xNWKGpLT242gl0fnDEsRDylKkqoF2Vu24FoxYcsGjypDQEa3npRVvRllWw8MXXWGPpJVE0bXvWCad2sLCfc9yZkSoqkI3suyljnQrrimOi+Q5mplWuhnp7zKqUm2lo6wQlqGqQygsteDBoAFfuWsdp1Oquu+82dBZyoKuRdhr3kqksMbSov8dja8jtZVsoyFlye6DrSwtLVxbydQA05hqW1qOZ1mrQ1GENGyxx7y0KKzbOFgNz6ajXT5xogO+2j0H4Fm2tNxeqZXgB5SF3JQFBnWtefPW2DJsVLRvR9KKk4GgpV1LSQv0HjDcwh8CpTfCQHPGWJampF1+zrw12rPElDghQXBa2PV3LFc9lrIwbCtbs2ExBMzOo9ZEqCtQUpLFmOfH59lW1emYAN+2rb1snEDrHWm56QE7uAZmQ1iInb3QkaTEgwhgiIgPNCetdNxqpzUmn4kexFhauOdbYDVtdwAr9zzb8JahyqSwCjtkS4vwwX/K82g7T38rnqgs9Rf30S5/xX9QlhO1avNyldVzeKejbKpQSosI46Jhi+Rzxa109DoajFs2ntYfpNWbEHstmrofsmQZFrD5Dk2LCJNnpkWBoXlMPh4Jq4ENG563vLTVC1qgDut+F75/5AiUIfR36er6Wy4URrp5bCsZBavpb2fcRva3+tqCMb7CTg+w6p8qfb8MkeblmpaweOZblFl5nKPRHHuW4fj+FshbeIgXPPBQgSNa8iwpnAjtIjTuToBpyaW0GvPYFlXWPYTWhDnRNJcx1rs8yrC0ZfWOO4CGA5gLkW1ZrJ2skAlBWQPl5CXctpiyfGG12ciVz0lWIjZLa6Osyj3XVtfvG5YmVViGZa11pGUREUpFepDSIjPYlqeyGtXfmpK3sNUAtGj1TmnB3p+7aWiON1jW3klJ6ToEwqKoaNp6iP8KrEa5/di8dbLnRNxrl1Z21JLLRJgd3MMzrrur7E6QeQBYpCRRMkPO8itDtbc4tmNzBgZvw3Kb8AM7PEJbmhXYMESgj0V0yDI1mHNplcdgafkbPKfF9hPHnA0cWPmArGV1acCJtt5+YQH9ynYsgvS6EDllSGnRKB/s8QEGb3Yxxs6Jg5YFtyyArApnbSjPdPcSKQLKUgbveFYe7vFB0WFKf6u3kYhB9wH2ljUrFUrroe1CI6qOGGERhFCfE/8IlVaYsqZ0bNTKB2OVIrBTifJy4cAR3HcWOhKYG0d7M+Fc0vJTlld/C86JIGrpJQ/olaqLTXVtoSqsRGpWOTC5m3DFKTFQ3LVCc7yXstp+f2vUno/JW043XsbSuhq4kDJ07hZurMJAOmBXiloZJi3fBN/CoyNsPzGdsPKxYZmzy8KvsK5F9WUok0LXIqCfbCJDrljlYpRh0krDytBaJ07RluNa8Jj3UV0if5b3pu2DpI6yYMAyjQYrMhD9CpVWHBwdVH/r9xRaIMTbTRoBar9aJWKs+H1XSqxn8JpVJ2dDiQrBKEqAsgKlFbaQhnlrdCVewTa+Vha/X89+iUMM/49EACsKc/IdwfMNBLRIkWtYufb5IGkxZbE7AtMXh9nAefnt6P1ErNfV8iYPxmd2QeKdS3txslpTXPJeU1cg5PRnUK/+BB9LVDNIi+0btu2f3Gg0vZFnbHQPomK3U0Qgra7nj26Is9s/xyOlUxRDZ9d0KLXjlealPCsnQdJK+CZrm80w2imVKLqB/HoKV9W7ooK4okJ1sxCMWUQld2QbFvArupbmrZpVgLL+xy6DZfdwUqzLNS1viWXO9Rptk1E7e1xdtAaVbSHU26oAwT03ZiWZlbQO/ZsPFNbrLbsNH7qd0gzU57fS8VmeX9SkFTj+kH+SbKNanGCTJ7E63vgjCEYsouZBRYm7OzP4kL4WhfXr9XYb3H+ePjfesmYCLd6Jv068bMPEpY/O2Cdm1E40sqrQrUTOy9/iGSxFqwlgpc9vNU9jK5HdAJ4kK3W++vkIt+w7qzmK+v0GC1Qelh44rF//3uTN6CbMuW6j89aPlHdsztH0y7rsArGqxM5q+BF3BW3lK0WLLRD9LV7Aotq6ZzJvNb7RwfS3Rs2JlBaNml7XRpLt8UiorApwykjHhtwOC4ZUKT/KR986lLAorYErdF7r63a0ttbedwOpcRHSdXCXAsYG1fIjDi/28K1DBYvTalvv4OD0t0ZpK/b/JRuMlrMJTdw8CrO7paz8JRSW0FZIx9Ta8hmprZBuCaWVy/1CGLGsuK54lcLdpbJy7zo0sLhvZd77Yg04NHJfntY2Mg1lgnrtPuDrSloS1+NzGgpLJoh7gLIm97dCGuLbI4E79o6/W7hIqVmVtAx969CG1U+nPnOizBC/F6e1itR2DhlY5pjuqO1ZUlovq3BYglbr5fONX38rpCW+juz9HOT0sGzLKqVxleLta1oQFvetW3Zv5+lBbBf+HQvUtuSBoj/VoPH4UqAqc+JnWg4sOSe2QctEfdBmwv1EP9uKOnUeC2gqH/YrSYo9/JKWC4vTus0grAnpNLAQYcJyls9lbmJDKQ2ePl7mgRWUt5yY2ixNK3k+8gPJTsCydSVQKUxSWW+PXhv5fVgib4V2A6f1t/yldRwMDU5TRvAy0aEs0cNMsGbpb8lfntE0y9JKoiM76O4IK7eDOzAshuqNKeshnQmWS6v1tq3x9xP9XYvYsKyOe8nempYsQEXMz+FF82+YVtuG2tZtcd+iyZRYW6nvKctQkuMlmUtZpr/VhvsWpbVdjla6PZZcWQ4qKCrbsdh4K70yvFbW68Cc6N+yUbm0bTit5bQVr6J8uN0ODMtW1hufDn0yPNvd+TWsLf9EqhY+7LNZ2OWTl37/2O7J6LhgAXsLgcVxvc6Yt8zvSWKLxmZJWunzsXRxldzaS9utchsVez94K+v11+uwbwVKq2kFrHY5WjRqlWYjh6jFoFw8A1BvFqvH5yBlDWnLt2Uj9qcbRqvhymr+T9vZtTaOZGG4m51O3M3AsDOEgaEDXhjsxr6JcXxh3AKLHQnFDk68/v//ZavOV51TVfKHpJRkxUl6LubhOW+dKtlO9VG0fGhFrajsxiihfqi8grPLUpphtbhV9lhH4wdN4fjA3Pr88PcPvcahXQZdgRoVserUaHEZiluGGd5P7BD0TqeyFq18xn8YrdHvf4fmXWJd1oNRg7Wj8z8P3WA9zcmsltwqO9JybQMdOD6oEu//lXRY0X6MTIEECi4dYc0F1DzfQdy8v+UJ4bnU4/FDaEGnlZglpH7sog6LaHWGRbjmuZiH/a36JqfGJbGKYDm3PuJDMSHhCdR/bRf6Q9XezuT7rpdZ8/ZK7HDHgutPToL17QNoueUhvxg5tA2zdDm4I2a7fmXIauV53XY/sQ51aMWq3OHduv8QWDOJLIXqh4703Uyfuy6LQzILec3T+TB7P7E+qxaQqmOriNcH0Bo9yEvVeB6cmbTaxcB2HVfSbBYAw2JM7bpyfwuLcImJtRwniQWX6tvQtD4/SNdOG6N6caP7djnc+PJ5gMxq706vuZ+4ZLeYVSSWgzW4W86szK6MXTdrWjt4dHk7nZg1n8/VtBhXI+xvjc/uby3JqmWmaSCxMLaGdotghbUg35UIMs0w1yned2jWfefM0p3pvGUP4qJZwoucGusCJFp+fBv0k/hGDz/0YtDs8dneKqCaDGKWZNdT4tbljrTWdbhMpkJmVT3+OiQtB2um7jnbxY0qQJ1YPcyai1y6i8j2W/t2qZYRqXEovzpYVQ3uFpo1i7YZQv3586cpQW9Wl92/XGaZ6DK5db4/LTmyIrGqcHwELc4sm+ncJESUhoL1FBqurFpP6t0F7QvCjFdwFlqsQWn5MkxWzrtMtyCgJu4yhFmm45onbpXnb1EsWxosa1WBtIaaEwFWvBZUC5uIFdLqDusYVaEqQusXvV7+TOfOk+BYNe2+XYi88mOolIeAT2/ghElwNrOoepnlWR3n84xhmQ6i9fVb3F2N064dkSmzCj8eB3Jr9CDNle7Wd7swD052P9GncBmoDMPM+DTP3/NJtmw8onKZmwi5Fw2kioqOohiGlocFbu1UtxDSPVSeOXqU4TFHLJv14FYN7xVe2i0stcixabXUNViwWJV3a4hKFLNmihdTwifCKDzpUYZHC0zahywtiK19VIDpRMiNu80rJZaj9fsAtBjWTjUMO92ua7Xw7BnwSOqYmpVu2+A6Mbzblxv3fIdly7CAMgxjiA4CYamJb5ZMfgGVXL/80sMsVqtlZmztIJZxgxUCq9LrQc0KcG38uRmgEo1ZyqbJ2aM7LMaVZpfs3cyztPCtFRmvKu5IbbqHCgRag1QiwFJTn2GlmanI6m+W+HWMaCVuHZlW3da5i1TWrFCDHtVmsxmAloMlQTWTXQWKp0kUVSHgf+kd8MfsnJj2XEfcCoTw2ktoRfvtUeMeEqsiq1wZAq1+f6uKzOJdPV2CkxSS59cPVnokXVfccdWv+HmS/iVY+2XYw4q2RTWqQoe7w7QZhhaYtTPrZQ3JcuJHH1hH/7DhdcxFl4w7/5dJa9pp2OdWg8s42yuNisXyoyctb1ayUtZJBXAmhItpdYSFlEItJlH/xIvroNcfd3/+dkevvvKvWEv3RdMaND0DmMW0Nr1oebNyLdXErnCi0RkWD7aLWJ1x64/fvn79fId/7HZZi1e1whRt91FYVRmzerpFZXi2X5jIV8bWDVZ9LAWUkMo1EtJ1Aaz7T/fOrVevVT3WVsUb7rJyjkixWQd39HILzTJNekBjrhOFqxesSK44up4ULoL16etvd/tXvPds072qkiosKqa1kcZBxPK4utNCWJNs/ck1HovesCDobXTlNm3mHhb8x86t2t7ICbcmosCy6b7hA8069KFFZsVa7VSq6yeTvmVYGrtEMNui6m1nMMv915/vKKdqulTSt5ttGdlpUGFlxDocDo933WiNHtKEujAWPc0qLau5jq9owRhgebd0uHupinQbWa8HqXUnXAcgBaxWh45uxbAmqldQeOiER68yLMsScSlk8zpdWwsyhgWViFpVyzTZk/WglKASC6rw4HF1oxVgtXQJA5tVloKq1Dmvp8fjXG1yCSxPqwpuKbVUMxol1maz4XTHqRBjyz2+dKE1ejgPCYyyhzs7wgJSZUlfkuyisrSGBVi+g6jiFWGVqEW0glgqsCCywK1OKe9gRY1CWnxcfwuB1xkWc4IncTWa3YgjNRAKFtGqlrl90ciqWCzMduAEo1NueViZOmOFBJvF1QXWCM2CzEJmx1SxOOafDCxPCzjV0GApXoXZdGepCh1X9GBYqw65hWYlrGwJmktvsxAXSEWtRGnnRtN6GVjgVpXZkpEVYdUa7oeN9srBWt2cWzmzJtqsuBi7Z9Y3gCU1SJXIlqXtRA4Wp3yyHoxQ8RZWCCsK9kDLfXcrLQ9rkYZ5kCgN+K5mMSxGFqqR7Kqj+IJLBAtzq1qmPYPdwrK9aJgHoQLJrMOtuQVmJYjgXOgiNN9MBoClHHOUyriz5+g6xrDAragOw3KwkPWNFCEtcgQVksLr6TZaZFb7KZR6Z5aDNfbv/ir5UqoqlGqsfYuq6jGBhbRyN1PNPFgYs6QAV+HwxG7LLQernU/4brHAi79O+phV+3Os1QpVidkPvKivd5cUVkRLbnpVIlZh58GDqkGsQjpXb7f18lSGhtWCSjBAmqjrortZY4+pRrESwUqFS6mVgWVpFYlaG7V8Pti8Ikj0ZXXjnAhmLfQ5YVDqqYDql1ke1jjQMry4Eo/Y53PY58yiDsJsM5gGy/buB91fHYhVGDek/Oi7AWN1khqkn6FYPc1CYgxprHDRUsi2qVlYwa1CZ9aGOyyn1SFaO4cGS+N6W51ucGv0fTGxXlnBFgttFz/vCsvfLGVa4NhYcCGyY62v3rA8rOBW6LA20jUUei3Im1hhKgyk4Pp29arawbJjop43Ot0n8rNFD1j0MVBAyrHSuPx3ZoKEamyBxbQKfTdHljgFpxUvni0qKcM3h8qN1ZX3qhWsiSq/JsKmYPpf/bsrrJI+6hftGktdcoJFRXlsNYtpFXaJYzZGD3bxvDJinUgsr9bpykqMzGqUPnSNqPkfTjrC2qcfkFyOpSxrnfiyOfFrGyykpefBTaEXz9E8uJJ+VInlI4vduoJWBGvSLK4ZA8ESZPi1DGVZcpNRtpoFtEzPYBpRnALtrowpQc4sxHX6ckUlOlgN+nQBk9arh1l7OrLAalWTXJXtZqFbUS9qbk4c1EYyLQkF1xtVIMXW++mKSiSzCFdDlwy5ZjCz8NPYWqjpyMce9gwscMvcdi4MqDiwbIPlig9JrQDW6XLKs1lGL/u0SdB1N2vvxhgeltWeQOFnO2F/AW7V58zCfqsw97z0grAt3FEsZPUORXg6gVsXaOnMaoSOMo1/1ah/1nSHxQcz4xPJ7eUznsSzs2ZRJRZF1LdT9W3OouLGwU2GDta7w3aJFpnVhPJrDJ7G/gwf/cxiu1gxOeGo4aAPfPefnHwelneL2lHdim7OspIqpHHy4/39Ii0d8E2sUfhBNAv0gIVA9qKXyMWo8M8QwMce+uMSLMotuxq02wwZrzwqYYW0PKwLtDwsB6KhSxNUEoKNqVP4TVdY2RFwuVHTQ8ZFWOBWYe7Qm3VzbpHDnTtOhG/vPNbvp3O0Rt+bhlGFcmzEpsY84cegsOzwRYiVCI8rYHm3HjniDxu7MarMsmqFxDoJqbW7nnOLYZFYGlljZsfmw8w6P66ABbSCVXb/KrCKpsFQgGTWybFar8/RElgtgkXNF3zpDOvV/c+/wtk2kl+91lfA8q+xeTQNVnTXK+MV8joRrTcQy7t1WrfT8rCm7rDEwhFCKyRZD1ivROsVTz7CU48Hjj3942vMgtx6DHtYuRoM+wzgFdegEwraBjDrtPZne245WFODa5EyW1hinc16JRpBL4WIkfkTBn7zch2sT/d/3lVKLLMzGtL9zezMYLxLuK9JrnWrW6Pv0ymgmvqvLQOLk89FH1ivTIUhAROtGP8S/+XrlbA+3VMl4vbVJocq6q5wInS03kLCr5lW9p1cDhZyimuxaTLJz5r1MUtXnsYkHMUtP16uhoW0HKeVeQVI3GCtQsC/265BxPIpn/3kCjZrinKdI7YI0HqZJVwUMEtIf3ctLKjEx41e56R3clCslXglWgGkdzrWbZUIsIDV9KJbIfS7wopNujxerof16SvQStbPqh19W0WstFlrMWvrjhwthBWAYX41TWt+NU0/WFcRen2h8+UWWOiWbbHS2xOrRKt3UYpTfutwZWgFWOQWxDxNkPkkW0y7wnrZnyUEpx9Myz/55wZYQCu8SkZe0hDFO+z5ua7hzXglgYVjkqHlYT1PY2DypSX3hzbrhVGFg8S6ySyitUn7dtW4UzNKvZUmpVk5uVJaDtYzY9K0zrLqCusl8QiBvITn8iMef90Ei93KRLtZ5mSLkONq61vTHK3R92ej1tRY1UiG6THtAYvNoZMtwrrjIlTjn9vMIlq5lbPak1G5rkgJLjdmp+02peVhAa7nJkn6WLJesO4BFvIJGW4jKgL18o87bjTLDaAVrQdDWtEsqHCZuNqiXOstDttvEayp8at5bkI3kavHHma9hHKTQE8oMSl33A4rdSvpGUJgSXvlzi2H1RaKMXWLyjCuxQSUUqyzWVJsJphSTMypo1mf7kdIK4DSeaXbqzWtCY1ZAsqPn5qWg/X8jLQI2rT5nyR+nldXs15UQOkyNJg0KT86wLK01B7y6i1e5di2fcsZvyW9ttv/83Z+PY3kWBSHpdkkZBtlHjYtQr9UlaCkliXUKGuIZClRKQ8QbQlU+f7fZe17/edel9MTXMlWMmmGHqTh1+ceHx9XB0FpASxnW7XV19uyb161TxTZBv9OEkHq2vLHFv7JejsnQ4t2ok5Ze8fKVDOfetEzjd+Ki8rL6pcR1urxMdCa/DSoGC+trC6o641RsmIbAovO3n8PiMqj0srKei8GT4tW7vuervYrlkYBlMe12uEgBm15ZcFLZ4B1b5yTw1UP8iyAlRBWwBNe6LXIfOMKoPXxYW9Y2//nY7+PhtDPn98PkhFU9lXpy7v85CfoarnUcqqJvKzfL98It8BsAKweKfvqTCpoatuYR45nMW3t9dOdOn+QLJrK7ZvVhrq7sayNMNrCBDH52SEqa/PE6Ol+0UsMX08Ea+ul5fhwVTX6uch+S5TxP6/hFhm8FQssa0+ncPUZzyCbQ60tYXBpYKq4/of53xgjLFRWR5TFokScU/NgbWOHsoMXJpCBgscAWCNDC6Koze57X7f7JOpZbbyugrLEBqdQCVGYe2xGZm+4tLyctpZ8FD2wN6+vXFhbMn3bSFRJVEOUhdr6cJEU7pQBTh9hCtnFSCnrWRqVVlZr1sTxj5+1QQW4nLaiWXzju+xBytoGUfE49Z4gBdcQWIbWB4mjENo/yAjS/TOCoroCezdjKIq2ba///e3bz87pCrVFvQscfslBwcdDYPUiQkpSICoANgjWhZtER2tF94Mstq+YtysrK41KGGKFxnV9ff2XhtWhtGqnrbAq8j2QP9sYMIY9Ub0fGsATKIvR6jUNn/EySMYQdWXsSr8abcH1WHeIy0qrphvr5VsoI2qyCcqHFRC9p43KU8KrWgx9g7Bvek2047fHzSAxrE/r7DwyWF2Z0CBUIdQv7VpFWxQaWW0Gsevq9CxaeXGvz4S15VuZ9yglbPkAGlTDYRlaRlQmv/ePU10rs+EJSxhXN7TEpoA5dNJq2zeqrc5vrP0vxMLsJObCOjx7yCpSVnUCZekEoWkZZe0/UVurz55fRbJyjmWEZUSlgRlVaZEhrSWZRKetlKgGKiusfO9pT2cj2FTVcFigLXunzH7fWwXjAssqC0htQFqgKGGYASzU1rKjq2LtaHmNLUM1mA8r7VV9XBWwak4Cy2gLItZ+7/srnq74MiiU3RQKq6y2LdzVIi3CqrZPjwsF9rY8jbKSsgJM20hWp/Asq61Pcwix/4zWwY2vGryyhN0/Y2wwBl+wy2srTlxdWBxJjljWA2AxaTV+DWxIDnWiAlwngWW0Ze/s49vBOLe7rgG2hPphrp0A14IRLITo06ptogdp9TY/g5WVSFXc1wOuxWney91M4iqxErLcDnvnYFdGWIBMGVYQTAtM823NJtE3gh1fGHE9PAmsHiSNaFv5+TulsqxvOVR7XvWtIllZUgBIuCn0w4jawry1rLl18YrLfmIgrKb/oFbVBFQng4W+FUh5Wa2ItVtZbUBROikQQu6DHX46sSZ6YFxay2GwGp4XmjgveGWdFhbSYstgcPcI6FJiAAASE0lEQVRQNIBZaWIGijP3yOJ3zuUJrM6VzXXweEttAKwmmr8tD1aoqSYM4uKEPwmG0Nq4jMWmUOAiuAFdCcQUxhA/2rXpNbGrvXeBdXVuHLNhNdtD80eiFVGWlCeEZXyLnTvTgAUrILRX2I3iI9JUAVtEKy3UVnShprrwSz0EVjKruxXQ6coP4UmVBdpiLXLQlYIO2ccrE0VVawaxcN6lGDNVJGjV4eiH9Db5sJreZpmJinECaZ0UltfWph+wbCVj94PWs4qIkGiDifV2PmRx7IysrMByYTmv2vZUZXn5LHoeWJggrFWtwrmzcr0oqqpVrfAzVxR9ajuBnU1bp/eJ/mCxyx9Db+69FFr5dEVRyZPDsrT4aWrQFZbIkBsEiiteCp2yIKQWpN86FCKWy2xYyW6hYcHKfSBPbvDBt1jZ/mjrmLAOqp6tk2URgykw1Z/6XdM1saN53hlYPqwmHkNnV02wdmlFBR/cXZ78x9AirfhAFVVlHZ0aFqyJ7Y6jcwkfsrzRFdv+kI4rX1l/RuUEFSZRympx+p9w7GgBscfQyeB2MK0sl0a9siyuVAfhZQXtc6ayFgcmkGwGvbSke9ydHtbI0lIrUrmbGVT+ZCINrGWDCKPo+61+5HLOlQVruqj6siKJoUFhyWBYAGt6clhWWyt+kANHXgJ9XbXUrLyiRG8Qd3rpJNpKKmwArMQEelQkZUmUl4F1hh9ib7QFth4OCKEYRc+yWaFVTFHCK4poS7TK561umR7GHFij74skqortcGSQlQEm5d3NGWBdXFxqWuSGBhhCJURR9MOooFGLwCpsM6hh/a5TsAYoa3T1r2jLTLbNTUDlE5a9ZuNzwLrw2jLhARq+X86wqDfxrNUzMnCuonD9Fjh6F81jFqzLBeHkHcuLSpIBNJqytMrZ5ehstADW4wZEFQ4Hv3IplyDImuiP+FFdWbB+zMLWpgp7G/2AkSNRFJFZXPOr88BC34JbioATFsi0wHJBVJiQJeKkhToT9ouifmuosi4AVt/VUVmNdJx8aLDXmUzL0wKbh+8bTijcrKVVJrCDUNGqyPstrqw8WOOblLHTnkHa5EAcS8r1mUwLaYGqrLebUewzOpRQhbctVFbc2HjHz4KFEb6i5UKvkeETKM86h4GWu5lB4bGXlY7oc1IJXm59DLT43qfOh1Vxw/Lbm/QMlrIszxNLKS17WI8nN2n9GMcSETIVBhG+OJxVW2SWWBas0XRBW74qLvuca+EQVo7WGefQ+ZaAATTDJBIxQdjaPSEx5feJqqDniR3ND3nKurzbVtGpoI+fvpIJU1jio6zm30dnpaVshSASXV+UT6nAqMUXzuxs3iJxq8tT1uWC1XxEYBVtsIhflRLm8P580gJaQrV2Z6iK/jYwlA5t6t9cA4Fx9rfb+Xh95SlLZwfaWjWVbLysnLhoHnXKktX5LN7Ran2PwDCFIot8NqjLHZbZSWT9lh/DPGXp7CCdR5HkwHVFUFla8szSsi4P37Ld8YiCHUf/IT8UeMBvx9in086ZVpc9hpPpXRXvnoOkYAL9QljapRCe5VmlBbR+qVan0h1fDnloJ5m+JTUgftIBM0YftYF5yhpdLXp6on0Mze0WF8Bay7vZOaUF+0TjW5jgRTJOaY8SCXIicHL7xIL3W5ljqB2+Cmc4TcTLSUwGwypRWmtZnnNBdLTghiIRO1PUv8M2sWDBwX+NzhgC/4bBG0mlmbAuftykMrskyyBPWGBZa7kuy7tzdQ+EljL3qhX+kEuIY7Y+9r4kP5IGF79/KxcWmJYvZWQ4wmH5ypKynoUKO7PHO1pws7vpinHLp0Xy94cXCXi+gxgwhmBatDqWdPtMAlYp0aykxEEsy/V6Pj0/LfNtKvVoJol2ovE+cRcXhIwV3lH5O/hWLqzLWWxU9JCQ0iq9sNC5jG1Nzktrgr7lTriCHSlCSdBKXvGzV8G0Ze8NzIZlkhbt2yUVVkwKJ3FtnuXaDOLsanTxf/EtkEbRMvOmdbP4w3F13G91+bDMCY+MhSXjUqaM10KYQzkfQGs0Gn3F5TFdujrB16RhZVQpz1dMWf4em1xYbA5lhAuAlfxhRLWG14chtEaX08sjaYW8hSIr4v1PwuEVKylYvzVAWaPxTcRKVgd0FeI7sCo1rTKX1uTqdn6c5QEtPIaAb3f3x9OK5G+LqA3MhgVzSJo+CwpRVSEyBFpISssLXvNojae3t0+3t8fS+qUK51voUja779KpQSSaU8heeJ44AJYO8bKJ+/aoRi5tYCDCkmvgZWh9H39Zzfe3T/o6ntaj/jYdrSMbeUFKVbelBnVpbWXD0uvhXcOPJ6SkrEpuWWYpRHWtgdZ6Ppt+7Qc4ji41q5enp5eX2+Mm0SQIE0ahaFbpLgvVJZzszG/6/yDut+p8WKMrHeJlQxJDf/ccRGWVVeIUmqt8mN9ffSFwjb/Pb180K8PreG35xKQOnYmlT1zdEPrLZPl8WBc/ZjJq26XXVhmCu9/nrO2KuMYLbP5ocenVd377+voE18vr8bR22G/tFHekHasf1CF7xzICnprWAFi4P/TZiuqqlL0toZtBMCyA9fCg4+n99yNwjUbjqZWV1hX88vQFl29dhEjeDn+wDPSoXK3fXufD0n/YMj4frDgrNolrqiszhlpb2rlmf4drNBlPjaxeYALx+fTyhUmENlCIg86+a/HgJ/xFDOHvfRC+5jJvzfJtwNt43Nw5s5L9ZZBpStplkPPS6jJGr4dxMjosqqv7+e0zyOn1+cldL1/xrfZw5dD7GwShq+f7b+N6Q2CZ6kGy4C57wd0qax1CVgRLPzUuPY3j3j5G72zGl05Uz0/P1t2f3CAeTcv0UiSR28r5byZyJ4IcbYgYAuticnMXWneuLRm1DTSUMlRw3Rle0++X4/FkMjLXZDIZj6+m9zON6vn55fnFXd6zvkgLd9M75TpRyKnh6HB3jIu1g2Bpacn+zTJS0sAQMkOIWLgYPoTnw8Prej6fGWT6mpqX2b3mdKvn75nCeqIm/3Kky0/ifmsnxIGB3P0psKpBsLRrrdlJDstYss/K03pAXERcmtfD66vOBHO87m7/197V9CaOBNGwBGEmCkJIOEKcMHK0QpbQ+GD3wVLfkfj/f2e7+rOqus0ANtFqEq82yaz2sPvy6vWrV9VG1OrPtcGqtlA9xq3efCti1SVRnn6LcFgZgjENnDrw8qNoBcUqUswCpEoQfKF/BpD0F8CKVKEVLf1DfTu3rudbUXtYRXcxBjNLqVZxOHCl8k0hyxu0d0d1iLCy3DLwCA0T/KFtMVwn83cg1l3cYvlWVbGCO/uUSx+HPqzp/N2xgcxS1MpTviF4d9cT0irUSAWsZCkMVsJ8hQJ030WoQouVF632PpVn+Rbuf7reKH5MZukDMZVgFThywNTCCi8tVE6yNECGX74EqcC3vgI9v+7QLZRv7aveCuzzYoOZpai1OjR8WcYNc5zJgkBZUktqqWXx0lhZ5QI2aVJ5yBy1Tr4K2xOqxdvRwvlWmE2fk1JvDD3ZxRnMrJc5dIimv4FqLIjAG+cOKZYsUljJcBKWZW2p5bEKAo+5RY7DO9H6VOrel2+lr9hhyl0Gg/Xy8Us2h4KOCaPD0Hc7xGVJxCwNmAh41eFAbJFsBY+FEbvHb/F8i3Gq613jGl6GEItvi0NTsAm0mxK63F2yXocB5cAKSAl7KCaYdWqxwt/rt+yQiwcQfA0Crwg6CIeDBc60cYYh2IUQY7kmOnCrRJJFkcJw+aclttSTCjGrvT2x+cT5VnrNpkfqx2AWRDUWLdoRNrglbJLdDvZYlFmWXbVxDgnNailcj+VbzKKfA6vQ6k3g2AhgvSzeVSFagMyiLUlmcPRexL5B4m4nwIUf5LSQuj+k8nG+db4i9mc8uR6FWVCIBW6g4fvBTVYbHzdwzZJMtIwjLSmzrH8P5gEz61G0XL7V4bvT1R9s1kjMgkIsDiwZtUVImRVpFrWk2DtY6yA8Wix3iAzE4/lWxUuyS1rVkZg1VydiOAllg6Y5wV/hxMEplkMMkaoMx6EXeSZaqKNmaL3d3Ccav/Vp7iCevfPq2FUxvBFRdaOABaPiLZpQSLcEQjxDiP1KKVO+oceUuk46xDRO3eNSvGNCdtH78tH+FtEwshzRVSOBNQfZKhBeZPZFAuUS5zOo16FFaMtQJJl1aoPTah9Ay+VbnX/9n4GrSvsHN3sci1latkjgwEK/okfc0VmITsOa+Cx2HBIbT587slOUL8f51vnCOFaNySzjH2B32zHLjSh46OfR4k10KYi8Y8B0qhXxqk0YiMfzra7q3ZZ3ujUeWDBzDWZUaxaqQ4nSGdwUBoUX1Gfh3tAUYU3L8JQowkH5Fr2+Eu1MjlmGGq28CdkM7gm5yXIpKZH4kjY7tBRRtOzrMMksjVZ2o251aLvvfGWSuB+dWeq3tcsLnMzwsU7BipD7d1KIdbI3JMRK2Yfb0YLOpwqJzYV2h1qviN8aOGRN7E9tnV41XNujrpCGMyU/CyOhJ3FpGwxEohJXt+9v0XyrZ4/SBPKqDKejvlsO0DJWq0li5aYU/iiUUatjoaprFjxQT4rz0rgS83s2knC+1XGnFe75jA2WQctcaYK/Ghl5Uq9WVxTLwcVki4wtyFgs5tZtl8+yK/lWdDRWY4Ol0dKGlJ6EEtt3pFgso4m8Q8JnOWaRyXQbNz43/W/xfOvaNjP4rMnLqM98sttawUo5UjoCI71OD7FSHv7PzFrduCQX51vn3rcDKrDGvkezALSkkXncQIc+Giv8NWax7rDFVovMpaMucXn7zTOSb/kbKuHlBej9LF21Gf3S0fzj11YSVkWtDmdW1BcGWmHNQvlf29sdAla7O27pxftbFdetyjFrfLBAt3JrSMNeJNOsMNyh1KJ4mWF+GzstNmltqV7t7tqCDvkW9aM8n7+MaeAjlZcS2Xgi8bKkXbRHill4wRKtOHlIlODy3ht62dTfT6zsx/LAzxcSCyr2/R5b3x1ab7kxWqV1EQVLsiQ17wnvQJvD1IEYpha2IFuzanp3rSi0rN+CzzGi40R/GVZht37SPcmP9xxEvpTR8gxay5LJmWHiLAzMYkENppVZE1lNH7jLaKav5h75J+SmlVuUtDmXNvlPqUI7el2Z7rDEK1ncOkhmSvt8ViJZpi7LbZk+eAHbvPUHADt3x+6otBzsRNiG1xH05mkXcOeLiTkUrbYXkkwqJG116lRvGKjV+jKkIk/j5Rbk6tFrW6DynXt3ML2/ad4fcpw99WUnH2+5kEVBAmW278fNQ8lNVp/Ae3lvUUiavz/+u9d+qzOvsKEpvN3jmq2ferN7nk1XW1WGDq2SRMpsN6ukDt5zq7cMww6g+bbMd4PegaDzLfPpMu4dbdU+vPPoMnvyGxbAzecNGYKVvdNV6uB9CYq0wLPFNh00ZIM/EfCoDddlb1/C5d6VpP7B+XnqjgeKK1AuvVnLh2DSrd5a8xAx69rw8GRFy9JquRuuKIvp5viphz1ddzzqt/8YAVN2dPaavTz/WUzeVtuyARfhFmeSAU3Zw6xoxBNymlNtLqm0Il8NpZX9b93M9r/trOe815+GCHVZzdbTr8DKwJWL0otWgdRd9galxGiJVAJ4EgYpEPa3yVjzvNfZWctWePa/j/+8ZvOXL3oWIPSluTTXo1oRs5KTQ8otDVXdKmEf8deeTdf6rrCWLv31c7b5KlqZX9j84321DPfAPKd6NatGTqsvATydhFDWapwKxEf4Zvbv0b5JdzbbrL+QVki6cjq5v+azBK5AMrIIkiXq8aEycE1e1xv9rF+nky+Hypw1Ci4U/PHWsExrVjzDd3CJZf4EqEwlLLJskmWJW31fVoyGXTJK30WsWXUqKiXMWj4Nqv/LA9oVtF57L5s3hHEYmRtquPQlHrvwoKklalV/Stb/ZqjMyaivptalbKRbCHGpgyDxn2hxCRrkNFLCkGrxt0NlqvFjqvGSOpZx8QxCy2+V+mtiUI3KqgOCLSA1yb4DUgSvrbYSNbpsWCYyeCCU8lOaW8Cpt+k3QsrhpW9AA2CWXLWguXJtL7IKW4MA1E5xavHdoPKGRhFspRADWkkMV+0WQ+D8g5vA6l97n35XoJCjmb7rS/Y5YMYaRGCTvpY/zb45UKQmgWQ7hRl5dj8wXaPZQr/PQeGTLfQLHn5A+Xl+np/n53nC8x/tAMljWkeBnAAAAABJRU5ErkJggg==`;
  var resolveWalletUrl = (network, walletUrl) => {
    if (walletUrl) {
      return walletUrl;
    }
    switch (network.networkId) {
      case "mainnet":
        return "https://app.mynearwallet.com";
      case "testnet":
        return "https://testnet.mynearwallet.com";
      default:
        throw new Error("Invalid wallet url");
    }
  };
  var setupWalletState = (params, network) => __awaiter3(void 0, void 0, void 0, function* () {
    const keyStore = new nearAPI3.keyStores.BrowserLocalStorageKeyStore();
    const near = yield nearAPI3.connect(Object.assign(Object.assign({
      keyStore,
      walletUrl: params.walletUrl
    }, network), {
      headers: {}
    }));
    const wallet = new nearAPI3.WalletConnection(near, "near_app");
    return {
      wallet,
      keyStore
    };
  });
  var MyNearWallet = ({
    metadata,
    options,
    store,
    params,
    logger: logger2,
    id: id7
  }) => __awaiter3(void 0, void 0, void 0, function* () {
    const _state = yield setupWalletState(params, options.network);
    const getAccounts = () => __awaiter3(void 0, void 0, void 0, function* () {
      const accountId = _state.wallet.getAccountId();
      const account = _state.wallet.account();
      if (!accountId || !account) {
        return [];
      }
      const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);
      return [{
        accountId,
        publicKey: publicKey ? publicKey.toString() : ""
      }];
    });
    const transformTransactions = (transactions4) => __awaiter3(void 0, void 0, void 0, function* () {
      const account = _state.wallet.account();
      const {
        networkId,
        signer,
        provider
      } = account.connection;
      const localKey = yield signer.getPublicKey(account.accountId, networkId);
      return Promise.all(transactions4.map((transaction, index) => __awaiter3(void 0, void 0, void 0, function* () {
        const actions = transaction.actions.map((action) => createAction(action));
        const accessKey = yield account.accessKeyForTransaction(transaction.receiverId, actions, localKey);
        if (!accessKey) {
          throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);
        }
        const block = yield provider.block({
          finality: "final"
        });
        const nonce = accessKey.access_key.nonce + BigInt(index + 1);
        return nearAPI3.transactions.createTransaction(account.accountId, nearAPI3.utils.PublicKey.from(accessKey.public_key), transaction.receiverId, nonce, actions, nearAPI3.utils.serialize.base_decode(block.header.hash));
      })));
    });
    return {
      signIn({
        contractId,
        methodNames,
        successUrl,
        failureUrl
      }) {
        return __awaiter3(this, void 0, void 0, function* () {
          const existingAccounts = yield getAccounts();
          if (existingAccounts.length) {
            return existingAccounts;
          }
          yield _state.wallet.requestSignIn({
            contractId,
            methodNames,
            successUrl,
            failureUrl
          });
          return getAccounts();
        });
      },
      signOut() {
        return __awaiter3(this, void 0, void 0, function* () {
          if (_state.wallet.isSignedIn()) {
            _state.wallet.signOut();
          }
        });
      },
      getAccounts() {
        return __awaiter3(this, void 0, void 0, function* () {
          return getAccounts();
        });
      },
      verifyOwner() {
        return __awaiter3(this, void 0, void 0, function* () {
          throw new Error(`Method not supported by ${metadata.name}`);
        });
      },
      signMessage({
        message,
        nonce,
        recipient,
        callbackUrl,
        state
      }) {
        return __awaiter3(this, void 0, void 0, function* () {
          logger2.log("sign message", {
            message
          });
          if (id7 !== "my-near-wallet") {
            throw Error(`The signMessage method is not supported by ${metadata.name}`);
          }
          const locationUrl = typeof window !== "undefined" ? window.location.href : "";
          const url = callbackUrl || locationUrl;
          if (!url) {
            throw new Error(`The callbackUrl is missing for ${metadata.name}`);
          }
          const href = new URL(params.walletUrl);
          href.pathname = "sign-message";
          href.searchParams.append("message", message);
          href.searchParams.append("nonce", nonce.toString("base64"));
          href.searchParams.append("recipient", recipient);
          href.searchParams.append("callbackUrl", url);
          if (state) {
            href.searchParams.append("state", state);
          }
          window.location.replace(href.toString());
          return;
        });
      },
      signAndSendTransaction({
        signerId,
        receiverId,
        actions,
        callbackUrl
      }) {
        return __awaiter3(this, void 0, void 0, function* () {
          logger2.log("signAndSendTransaction", {
            signerId,
            receiverId,
            actions,
            callbackUrl
          });
          const {
            contract
          } = store.getState();
          if (!_state.wallet.isSignedIn() || !contract) {
            throw new Error("Wallet not signed in");
          }
          const account = _state.wallet.account();
          return account["signAndSendTransaction"]({
            receiverId: receiverId || contract.contractId,
            actions: actions.map((action) => createAction(action)),
            walletCallbackUrl: callbackUrl
          });
        });
      },
      signAndSendTransactions({
        transactions: transactions4,
        callbackUrl
      }) {
        return __awaiter3(this, void 0, void 0, function* () {
          logger2.log("signAndSendTransactions", {
            transactions: transactions4,
            callbackUrl
          });
          if (!_state.wallet.isSignedIn()) {
            throw new Error("Wallet not signed in");
          }
          return _state.wallet.requestSignTransactions({
            transactions: yield transformTransactions(transactions4),
            callbackUrl
          });
        });
      },
      buildImportAccountsUrl() {
        return `${params.walletUrl}/batch-import`;
      }
    };
  });
  function setupMyNearWallet({
    walletUrl,
    iconUrl = icon,
    deprecated = false,
    successUrl = "",
    failureUrl = ""
  } = {}) {
    return (moduleOptions) => __awaiter3(this, void 0, void 0, function* () {
      return {
        id: "my-near-wallet",
        type: "browser",
        metadata: {
          name: "MyNearWallet",
          description: "NEAR wallet to store, buy, send and stake assets for DeFi.",
          iconUrl,
          deprecated,
          available: true,
          successUrl,
          failureUrl,
          walletUrl: resolveWalletUrl(moduleOptions.options.network, walletUrl)
        },
        init: (options) => {
          return MyNearWallet(Object.assign(Object.assign({}, options), {
            params: {
              walletUrl: resolveWalletUrl(options.options.network, walletUrl)
            }
          }));
        }
      };
    });
  }

  // node_modules/@near-wallet-selector/meteor-wallet/index.js
  init_process();
  init_buffer();
  var nearAPI4 = __toESM(require_browser_index2(), 1);
  var import_sdk = __toESM(require_src2(), 1);
  var commonjsGlobal5 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var check5 = function(it) {
    return it && it.Math == Math && it;
  };
  var global$a5 = (
    // eslint-disable-next-line no-undef
    check5(typeof globalThis == "object" && globalThis) || check5(typeof window == "object" && window) || check5(typeof self == "object" && self) || check5(typeof commonjsGlobal5 == "object" && commonjsGlobal5) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var objectGetOwnPropertyDescriptor5 = {};
  var fails$65 = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var fails$55 = fails$65;
  var descriptors5 = !fails$55(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectPropertyIsEnumerable5 = {};
  var nativePropertyIsEnumerable5 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$15 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG5 = getOwnPropertyDescriptor$15 && !nativePropertyIsEnumerable5.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable5.f = NASHORN_BUG5 ? function propertyIsEnumerable5(V) {
    var descriptor = getOwnPropertyDescriptor$15(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable5;
  var createPropertyDescriptor$25 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var toString14 = {}.toString;
  var classofRaw5 = function(it) {
    return toString14.call(it).slice(8, -1);
  };
  var fails$45 = fails$65;
  var classof5 = classofRaw5;
  var split5 = "".split;
  var indexedObject5 = fails$45(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof5(it) == "String" ? split5.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$25 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject$14 = indexedObject5;
  var requireObjectCoercible$15 = requireObjectCoercible$25;
  var toIndexedObject$35 = function(it) {
    return IndexedObject$14(requireObjectCoercible$15(it));
  };
  var isObject$45 = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var isObject$35 = isObject$45;
  var toPrimitive$25 = function(input, PREFERRED_STRING) {
    if (!isObject$35(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$35(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$35(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$35(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var hasOwnProperty7 = {}.hasOwnProperty;
  var has$55 = function(it, key) {
    return hasOwnProperty7.call(it, key);
  };
  var global$95 = global$a5;
  var isObject$25 = isObject$45;
  var document2 = global$95.document;
  var EXISTS5 = isObject$25(document2) && isObject$25(document2.createElement);
  var documentCreateElement5 = function(it) {
    return EXISTS5 ? document2.createElement(it) : {};
  };
  var DESCRIPTORS$45 = descriptors5;
  var fails$35 = fails$65;
  var createElement5 = documentCreateElement5;
  var ie8DomDefine5 = !DESCRIPTORS$45 && !fails$35(function() {
    return Object.defineProperty(createElement5("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var DESCRIPTORS$35 = descriptors5;
  var propertyIsEnumerableModule$14 = objectPropertyIsEnumerable5;
  var createPropertyDescriptor$15 = createPropertyDescriptor$25;
  var toIndexedObject$25 = toIndexedObject$35;
  var toPrimitive$15 = toPrimitive$25;
  var has$45 = has$55;
  var IE8_DOM_DEFINE$15 = ie8DomDefine5;
  var nativeGetOwnPropertyDescriptor5 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor5.f = DESCRIPTORS$35 ? nativeGetOwnPropertyDescriptor5 : function getOwnPropertyDescriptor10(O, P) {
    O = toIndexedObject$25(O);
    P = toPrimitive$15(P, true);
    if (IE8_DOM_DEFINE$15) try {
      return nativeGetOwnPropertyDescriptor5(O, P);
    } catch (error2) {
    }
    if (has$45(O, P)) return createPropertyDescriptor$15(!propertyIsEnumerableModule$14.f.call(O, P), O[P]);
  };
  var objectDefineProperty5 = {};
  var isObject$15 = isObject$45;
  var anObject$45 = function(it) {
    if (!isObject$15(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var DESCRIPTORS$25 = descriptors5;
  var IE8_DOM_DEFINE5 = ie8DomDefine5;
  var anObject$35 = anObject$45;
  var toPrimitive5 = toPrimitive$25;
  var nativeDefineProperty5 = Object.defineProperty;
  objectDefineProperty5.f = DESCRIPTORS$25 ? nativeDefineProperty5 : function defineProperty10(O, P, Attributes) {
    anObject$35(O);
    P = toPrimitive5(P, true);
    anObject$35(Attributes);
    if (IE8_DOM_DEFINE5) try {
      return nativeDefineProperty5(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$15 = descriptors5;
  var definePropertyModule$15 = objectDefineProperty5;
  var createPropertyDescriptor5 = createPropertyDescriptor$25;
  var createNonEnumerableProperty$45 = DESCRIPTORS$15 ? function(object, key, value) {
    return definePropertyModule$15.f(object, key, createPropertyDescriptor5(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var redefine$25 = { exports: {} };
  var global$85 = global$a5;
  var createNonEnumerableProperty$35 = createNonEnumerableProperty$45;
  var setGlobal$35 = function(key, value) {
    try {
      createNonEnumerableProperty$35(global$85, key, value);
    } catch (error2) {
      global$85[key] = value;
    }
    return value;
  };
  var global$75 = global$a5;
  var setGlobal$25 = setGlobal$35;
  var SHARED5 = "__core-js_shared__";
  var store$35 = global$75[SHARED5] || setGlobal$25(SHARED5, {});
  var sharedStore5 = store$35;
  var store$25 = sharedStore5;
  var functionToString5 = Function.toString;
  if (typeof store$25.inspectSource != "function") {
    store$25.inspectSource = function(it) {
      return functionToString5.call(it);
    };
  }
  var inspectSource$25 = store$25.inspectSource;
  var global$65 = global$a5;
  var inspectSource$15 = inspectSource$25;
  var WeakMap$15 = global$65.WeakMap;
  var nativeWeakMap5 = typeof WeakMap$15 === "function" && /native code/.test(inspectSource$15(WeakMap$15));
  var shared$15 = { exports: {} };
  var store$15 = sharedStore5;
  (shared$15.exports = function(key, value) {
    return store$15[key] || (store$15[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var id5 = 0;
  var postfix5 = Math.random();
  var uid$15 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id5 + postfix5).toString(36);
  };
  var shared5 = shared$15.exports;
  var uid5 = uid$15;
  var keys10 = shared5("keys");
  var sharedKey$15 = function(key) {
    return keys10[key] || (keys10[key] = uid5(key));
  };
  var hiddenKeys$35 = {};
  var NATIVE_WEAK_MAP5 = nativeWeakMap5;
  var global$55 = global$a5;
  var isObject6 = isObject$45;
  var createNonEnumerableProperty$25 = createNonEnumerableProperty$45;
  var objectHas5 = has$55;
  var sharedKey5 = sharedKey$15;
  var hiddenKeys$25 = hiddenKeys$35;
  var WeakMap6 = global$55.WeakMap;
  var set7;
  var get8;
  var has$35;
  var enforce5 = function(it) {
    return has$35(it) ? get8(it) : set7(it, {});
  };
  var getterFor5 = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject6(it) || (state = get8(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP5) {
    store = new WeakMap6();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set7 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get8 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$35 = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey5("state");
    hiddenKeys$25[STATE] = true;
    set7 = function(it, metadata) {
      createNonEnumerableProperty$25(it, STATE, metadata);
      return metadata;
    };
    get8 = function(it) {
      return objectHas5(it, STATE) ? it[STATE] : {};
    };
    has$35 = function(it) {
      return objectHas5(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState5 = {
    set: set7,
    get: get8,
    has: has$35,
    enforce: enforce5,
    getterFor: getterFor5
  };
  var global$45 = global$a5;
  var createNonEnumerableProperty$15 = createNonEnumerableProperty$45;
  var has$25 = has$55;
  var setGlobal$15 = setGlobal$35;
  var inspectSource5 = inspectSource$25;
  var InternalStateModule5 = internalState5;
  var getInternalState5 = InternalStateModule5.get;
  var enforceInternalState5 = InternalStateModule5.enforce;
  var TEMPLATE5 = String(String).split("String");
  (redefine$25.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$25(value, "name")) createNonEnumerableProperty$15(value, "name", key);
      enforceInternalState5(value).source = TEMPLATE5.join(typeof key == "string" ? key : "");
    }
    if (O === global$45) {
      if (simple) O[key] = value;
      else setGlobal$15(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$15(O, key, value);
  })(Function.prototype, "toString", function toString15() {
    return typeof this == "function" && getInternalState5(this).source || inspectSource5(this);
  });
  var global$35 = global$a5;
  var path$15 = global$35;
  var path5 = path$15;
  var global$25 = global$a5;
  var aFunction5 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$15 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction5(path5[namespace]) || aFunction5(global$25[namespace]) : path5[namespace] && path5[namespace][method2] || global$25[namespace] && global$25[namespace][method2];
  };
  var objectGetOwnPropertyNames5 = {};
  var ceil5 = Math.ceil;
  var floor6 = Math.floor;
  var toInteger$25 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor6 : ceil5)(argument);
  };
  var toInteger$15 = toInteger$25;
  var min$15 = Math.min;
  var toLength$15 = function(argument) {
    return argument > 0 ? min$15(toInteger$15(argument), 9007199254740991) : 0;
  };
  var toInteger5 = toInteger$25;
  var max5 = Math.max;
  var min5 = Math.min;
  var toAbsoluteIndex$15 = function(index, length) {
    var integer = toInteger5(index);
    return integer < 0 ? max5(integer + length, 0) : min5(integer, length);
  };
  var toIndexedObject$15 = toIndexedObject$35;
  var toLength5 = toLength$15;
  var toAbsoluteIndex5 = toAbsoluteIndex$15;
  var createMethod6 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$15($this);
      var length = toLength5(O.length);
      var index = toAbsoluteIndex5(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes5 = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod6(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod6(false)
  };
  var has$15 = has$55;
  var toIndexedObject5 = toIndexedObject$35;
  var indexOf8 = arrayIncludes5.indexOf;
  var hiddenKeys$15 = hiddenKeys$35;
  var objectKeysInternal5 = function(object, names) {
    var O = toIndexedObject5(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$15(hiddenKeys$15, key) && has$15(O, key) && result.push(key);
    while (names.length > i) if (has$15(O, key = names[i++])) {
      ~indexOf8(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$25 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$15 = objectKeysInternal5;
  var enumBugKeys$15 = enumBugKeys$25;
  var hiddenKeys5 = enumBugKeys$15.concat("length", "prototype");
  objectGetOwnPropertyNames5.f = Object.getOwnPropertyNames || function getOwnPropertyNames6(O) {
    return internalObjectKeys$15(O, hiddenKeys5);
  };
  var objectGetOwnPropertySymbols5 = {};
  objectGetOwnPropertySymbols5.f = Object.getOwnPropertySymbols;
  var getBuiltIn5 = getBuiltIn$15;
  var getOwnPropertyNamesModule5 = objectGetOwnPropertyNames5;
  var getOwnPropertySymbolsModule$14 = objectGetOwnPropertySymbols5;
  var anObject$25 = anObject$45;
  var ownKeys$15 = getBuiltIn5("Reflect", "ownKeys") || function ownKeys9(it) {
    var keys14 = getOwnPropertyNamesModule5.f(anObject$25(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$14.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has6 = has$55;
  var ownKeys10 = ownKeys$15;
  var getOwnPropertyDescriptorModule5 = objectGetOwnPropertyDescriptor5;
  var definePropertyModule5 = objectDefineProperty5;
  var copyConstructorProperties$15 = function(target, source) {
    var keys14 = ownKeys10(source);
    var defineProperty14 = definePropertyModule5.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule5.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has6(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$25 = fails$65;
  var replacement5 = /#|\.prototype\./;
  var isForced$15 = function(feature, detection) {
    var value = data5[normalize5(feature)];
    return value == POLYFILL5 ? true : value == NATIVE5 ? false : typeof detection == "function" ? fails$25(detection) : !!detection;
  };
  var normalize5 = isForced$15.normalize = function(string) {
    return String(string).replace(replacement5, ".").toLowerCase();
  };
  var data5 = isForced$15.data = {};
  var NATIVE5 = isForced$15.NATIVE = "N";
  var POLYFILL5 = isForced$15.POLYFILL = "P";
  var isForced_15 = isForced$15;
  var global$15 = global$a5;
  var getOwnPropertyDescriptor11 = objectGetOwnPropertyDescriptor5.f;
  var createNonEnumerableProperty5 = createNonEnumerableProperty$45;
  var redefine$15 = redefine$25.exports;
  var setGlobal5 = setGlobal$35;
  var copyConstructorProperties5 = copyConstructorProperties$15;
  var isForced5 = isForced_15;
  var _export5 = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$15;
    } else if (STATIC) {
      target = global$15[TARGET] || setGlobal5(TARGET, {});
    } else {
      target = (global$15[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor11(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced5(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties5(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty5(sourceProperty, "sham", true);
      }
      redefine$15(target, key, sourceProperty, options);
    }
  };
  var internalObjectKeys5 = objectKeysInternal5;
  var enumBugKeys5 = enumBugKeys$25;
  var objectKeys$15 = Object.keys || function keys11(O) {
    return internalObjectKeys5(O, enumBugKeys5);
  };
  var requireObjectCoercible5 = requireObjectCoercible$25;
  var toObject$15 = function(argument) {
    return Object(requireObjectCoercible5(argument));
  };
  var DESCRIPTORS5 = descriptors5;
  var fails$15 = fails$65;
  var objectKeys6 = objectKeys$15;
  var getOwnPropertySymbolsModule5 = objectGetOwnPropertySymbols5;
  var propertyIsEnumerableModule5 = objectPropertyIsEnumerable5;
  var toObject5 = toObject$15;
  var IndexedObject5 = indexedObject5;
  var nativeAssign4 = Object.assign;
  var defineProperty11 = Object.defineProperty;
  var objectAssign4 = !nativeAssign4 || fails$15(function() {
    if (DESCRIPTORS5 && nativeAssign4({ b: 1 }, nativeAssign4(defineProperty11({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty11(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return nativeAssign4({}, A)[symbol] != 7 || objectKeys6(nativeAssign4({}, B)).join("") != alphabet;
  }) ? function assign7(target, source) {
    var T = toObject5(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule5.f;
    var propertyIsEnumerable7 = propertyIsEnumerableModule5.f;
    while (argumentsLength > index) {
      var S = IndexedObject5(arguments[index++]);
      var keys14 = getOwnPropertySymbols ? objectKeys6(S).concat(getOwnPropertySymbols(S)) : objectKeys6(S);
      var length = keys14.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys14[j++];
        if (!DESCRIPTORS5 || propertyIsEnumerable7.call(S, key)) T[key] = S[key];
      }
    }
    return T;
  } : nativeAssign4;
  var $5 = _export5;
  var assign8 = objectAssign4;
  $5({ target: "Object", stat: true, forced: Object.assign !== assign8 }, {
    assign: assign8
  });
  var anObject$15 = anObject$45;
  var regexpFlags5 = function() {
    var that = anObject$15(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var redefine5 = redefine$25.exports;
  var anObject5 = anObject$45;
  var fails5 = fails$65;
  var flags4 = regexpFlags5;
  var TO_STRING4 = "toString";
  var RegExpPrototype4 = RegExp.prototype;
  var nativeToString4 = RegExpPrototype4[TO_STRING4];
  var NOT_GENERIC4 = fails5(function() {
    return nativeToString4.call({ source: "a", flags: "b" }) != "/a/b";
  });
  var INCORRECT_NAME4 = nativeToString4.name != TO_STRING4;
  if (NOT_GENERIC4 || INCORRECT_NAME4) {
    redefine5(RegExp.prototype, TO_STRING4, function toString18() {
      var R = anObject5(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype4) ? flags4.call(R) : rf);
      return "/" + p + "/" + f;
    }, { unsafe: true });
  }
  function __awaiter4(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject5) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject5(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject5(e);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  var icon2 = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZsAAAGbCAMAAAAlRs3KAAAC/VBMVEUAAAB1gdddWs6cq+JsadRdXalLTJhFRXtTU415iNhOTo5+pe41NXxjYM8qKmscHGuRn+MSGZl0ovJ3eL6EqPEXF19QUcFdnfNlctZZmvNvc9prbdaMsPA1NoYkJHFdXdFSg+08ReFMO9VVTdg3k/Vdk/BHSL1bXac+mPVDlvQcIqFKcupJlfQvL3lRculLS404ivJLRNw9P7dHkPIoKHQ/lPQpLapPm/RGRohmlvF0oPCBg7pFPt4UFFBOQ9AkKag0OK9Ie+04PLJYT9ZeYLtJRsc4OH9LXOE/TuIrL64kJG9dZ+EVHJxDZudFgu5AXuZHk/NHjfE9PMA2OLVQfOtLd+tQjfBrbLZ7fbFGdOs8d+1Dj/JCK9hPT49Jk/JqnvJaVc4jI3EXHptRTclVUcxOS8dUQdhNQ91SO9pZUdBLRt5WR9UgIGlLScVYU80YGFJXTNJGRcMbG1tDfO1BXOVDeexSPttJR8RVRNZDV+MUFEVTUMohIW5BaOhCcuqkoe9Eh+9DgO5CQcBCdetAX+VHT+FCbelBZedPQdxBaulITeBJS99GUeFFU+JAYeZYTtEdHWBKSd8XF04WFkseHmNCWeQTE0JEVeISEj94a+49Pr1WStRQP9xAQL5FivBCb+lFj/IfH2YZGVVBY+YaGlhGlvNEhO4VFUk5O7tGkvNFjPEPDzoRET0tMLDCv/02OLgwM7IqLa00NrZaVM8cIqAcHF4kKagyNbQhJqVCWuQODjVGmvQnK6tEQsIKCi0dHW1MR8tQSsuAcfUYGGmrqPNiXd97bfFKSN9hXNFNS9CvrPQGBiMFDJMTE2ZIRMhfWtsVG6NFRc0/QMfIxf9AlvQICFxQTtUoJ3lpZNU5OcCbmOw0NJrRzv8ZHopoYONcV9UwL4ampPAPFpgSElRRTcJEQacwMbo6Oq1WU9g8PLM+jvIVFV0dIamBfeAoKpM3cOsnKrOOi+ZJSNE7g+9GM9s4VuU7OqJ0cNo1e+83aOlyZ+q7uPkyX+gzT+RLR7VJUHVbAAAAYHRSTlMACZEcgRAaYFcjjy+3ib/zE9xhVFP2lmouhmk/Q3XcXEv+/bL+qGNK9d7Vq8yjfzb+2a2k7em8saKagj/++dCljvvGnHfp0r7s6s2b7u3z3b7u6NrO8+HPcNr59ujU+LDlSLXNAAApKklEQVR42uzYPU7EMBAF4IlQftZEASkNTdxSRdtssdK2aIvcYu4xd5vCtUvEdRACaSRgvSlINsLvu8LzjJ9NAAAAAAAAAAAAAAAAAJCzsjoNbhzd0FcVwXZUjTt7/uInVz8RbMLe+fAqLMIfhDnGw1gXBLfWtxqUv9Gg55eS4Jb2owb+VQhdQ3A79SEIX6I8YLHdjAvKCRLaHa2prO77pq6b/qnK/FSUY+Ar4rSntVS18wdVEVHVw3loMo6naCNfpX6dcIrno5coLHbdvU1uT3myaJKC39HiiuEcflx8IoG7njJUWjRpsStoYc2kKvwLERl3lJuyDTxTGGlR1VGVLxH1uTX5wqK5Lja0oJNX4QRVRzmxhTaH+pIW8/ygnCaxzej31aKZJwy0lMaiuUynbAqbNbSZ1N+RWW1qjHSZTM7n1GxicCyaK7TL4iFqDW0+nQoy6y00E3MoBIloEuKJzB9Gs5WyuAmJhZYSj2RWXGhG/SP9b+/s2rFrE1EcB/BLbFqjRcWaUBTtIOgkhVKkIARRU1G3OOgiRK635QXO5YY7EO4vyNCp4FBwTWiE6OLjkOsQAhHhCCYli4iTEezk0MXna8jvJeba9L0neSl+h66v8Mn39969O9oaHptVGGqSW/N/qgENV5zPi+OhgTiJY317Qwaa4/DhNK7/C5r/xWFpSPhsno6JBuItn9COa8hAc2jGfxhgaY7PUS0yfeHixYsX4rEIV2u4cfyVsdM892c1dXPp2t1U2sWmiTPp1KOFeQ4aXhxvVioN1+/DUfYYHVu4qiPTMNB+rBZOJy8dgeZ7zhHAcWaltobP5rmiQ23hqoWQ8SeoG8vCZnJ+dJqcCI43K5OGt7yXNQUzf9WkMAM4Fn68MDKNEI6/Io+Gu7yNFU29TKWRbUAAB5k4GRuZhsUZw8MFtIbTxl/VlEvU1EmG4ZDgpfhhNGcojVBzGnOSaHxn4F9Q5QUsVyJ3EZEJx7Ey04fTiOJ4i1JoNoGGA8dZVuwVWyRKaSiOibH5N465FNPCM00HmiCOv3pOSms2yfI5fpyzatlEooZOY2GMstVq1nRdNIDjJg9szWZOGMe/IYeGLn9cbLo0tuEav3Zqe6XS3pfdJt5AAzgLB9FsiuP4JyXQdP8PJzdEZwJnWiSq2zahMY0ftaDdDkjI35dN19T7cDLxkIFGaYRxnOWYOE1iHZbnw/GuKPTVAKUhOLi63W6XemkHOwizOOhVNOzwTGDEceqnJAw0SkPDu+XUn2nKhNKQ4GaJyDAJ2tvI7WvORnzoQPu6vi4Bxzkbl9QaseY01HmDQ2jW1oCmL+0vlmkADmpFhw60dRJxnPqKRJrhe86E3dlQGoKD9BrQAM7uRt9pLRVGI47jLcflDTRYnmPXu6WpkUjUXqPBu0ADCYKmy+LguWEDTQpOY0ZOa0Sb41zR1EiPBlVLAZCwU81EDE5rarA1XwsFKTj+rDBNBZYO23Mm6IOBHo39EWrDhoBVsQE47v2/aaTgeA8FHypmEgV2ae7TmuOr8cV6JLrWjW7XgtLQtH+0DAYnHWMHGqWRgeMkFgVbQ2hIxJvjryrxdENo8vk8tTGqpTCbHYwYnPT0QGsAh4YPxxO9gJ6pVOB3wbfnwGdYCoTSdHHQrzCbYNuwDMDJnGBpKhXAEWiOVxelSVToyjSHNWcCXt5QGrAJwmz28qYBOK0LDM0LsBFojnhrTia+04UlNKeuQm0ITTab3w/0JsQGcFrnGZoXgMPRHIk0FVhZbM+p39DGH0oDOEa4Tc224GWbtXGaoeHDkb7XkNbAyjS8zfGvKPBRZySaz2YB56CzwEsDbAyUOQc01IYbRz7N6M0JvdFT4EqAtobFse3tMJtdVzcg6WmGhrc5kml663LuOUAzo409PRrACX32DJpYBxwzBTQCOHJpCoAjdFqrK3DJCTSA86EZcmdT05EOOO4USyM01uDwHL8+lVy6eXMpOTW3yEVT4GiOou8GgIbB+bjTHmrzi9QGcNAcpXkNMiLN8RK3tNi125lO5325WCy/7XzaunMvfhSaF4RmdJz+KEgDrenD+VDdC4beChg6g5Pap3ktBccrPJlPPtjaKr7bIin+SbnTeXD70hFpOJvjTAJNtzjw+MlONMvWAQc/6tIADv9Yy+W+Vd/8fPfmzTuwKZbL79+Wb8ePMtC4m6MazW/q7i60rTIOA7jzC4coykBkIkIHE7zTCxH82Jh6oezOC28U0iaZ69YmSy/WkQwCvfKuNSkhzZaLhsIJJCH9yloObWhCEtO07KwV1i5zSVNbt+Iy7CgtdFD8vydJ/yc5zTnp+5529ZmgF2rAn89z3ryJFgdNpnO7+MefNTTP0pNAs4vT/u1bx77nfISGvTn91zfn/x0OD0NKOKjz+LsPG6PBF6VrzpGiwdbshbP47M8/pF8XsNssQIM4t19+4c2/fD5NcHqbH94bDkNEnOrqDI1PvK9OMzDQg32lfOb8H2jKs5bO/vEn8JS+BPWsaOy0Vdk8+vFNzkcywDxrvQtr8/5w2aZ21kh13lFtzUAEwtico0ODg1ZHJza1SL46CHlWKJomjTYI0tzVdbiIDHtzgMY/74eIOvJZg9z5RJUG/41gaM4RocHWwC2NzQbX0DIcg9GiTy9CdO0WI/w5UhxDa7PbZzaz4xAaD9CQgExJpTJriHNWedAilbpGmJpzxGgMeoMOANLkD2pwIDZjO/wy2gwQm0TH8GjJbYYo4kQawiGt8ZRoBsfCnslOb3gsNCTD+UClNTIcqhuCo0RjiKWL61k7JLteTMdMMhyDJGhjE+5bzT60UXjmqH2eEyE0HoIzFo4Jue2+vr7tXGvXUAhnjdjc+uhYXRrJxQTVM+do0uhtRXsmkShAEomMfctmk+GY9sIRVq2cWQzrrEWaPUADCY915uLxeIoEfi+Eh6qfOXfeqTdovg4MxawdUZpYej2TsO8mkVlP61VxII9WOaDRAqenQuMP5+Pxvt2k4n2WGpzxd/emwdZQz1rb0aPRL9oz9qpksoCjNmsGYZWzmqU21Efpjt3W+JPxVJ808XgMcbA4dQYNQ3GUPkI0lcOzcbFQosGAlU5t1oDGijQszZHS5HZLg9WZqmrOxHfH5TQ+pGF55hwVmt1BW7TjniHOusGkhCPSuBwOdpzys8br9SJNNU7KOzSGOHhUQ5ov/8LXY5q1/wMN4GzFdAqzVqZBHPpZg9bc9pIgTXXiyZC0OLc+kdPg6zHO2lGgeWGXpoA00iSyOkNdHJshWaZhb85AhcaPNLU4Fun7nIkfjslpSNhmDWle/fybs2fOnDl78l2mr/xq3xrE2cLjgGzWhFW3y+xgxyGt8ZZpPEhTayOExhBnKPReFY2jTKM6a+o4/3z2wntnz52fXV5uaWlZXp49f+6s6uX3IdKgTTFWz8aUXHW5nSIM66zBoM15uxRpwGY7PCi9IDhd3ZrSq7HPWn/P0o9nWpZnWzCzyy2f4uONMeyDhqOGV2tVOmUapzqOenN8zV6ggSjRwGnAEpJcfA6+X0ODOAyz1t/b9mAcClMTsPoUekoRptYY67cGUsimDbq9cIDGDTSIQz9rvuswaITGo0ADgfc4ks9zHp+WDJrDJ4Z11qA0zS13UKRKp+UNbQFoBw1t7GnbXja6Mg2EddYGoDVdIo0XaBRtQpKPDO6cxNaUaRhmDSK2ZgFp9qgO5amAfdDUbVBnJLfqDgILOw60pkLjTwKNig3iQG+QBl6tnP3OGuoATf8DlNlL56PXXzj4HFOmwSRw0zCkNcGgk+PAhXXWzNe7gIbEnwcaRZupkORj6rH3cdDMZsShn7VeFRrAOS+/jdCexiQbNNWzAGYkuRogNBrg+K5PTpVoPMZUSpEGzgKDYQnOaWyNrKc0OL29QKOS2bdf0UaAnQbP0NLAoAUDnBjWWYPWTFssoo03p1abbenH1KGxEyUavAOnnzWkUcU5q5EBO02hsKiX2eRWAwHOakUc6uaY2yanJi0WyyTWRsEmPyjBCf3wFqFxIg1Lc5BGFecEOwALDSaxjpOGgybSEBzGWTNfF2kIjvrTJtU3OexHnMFz2BoNcJBGJcvyj1y1p9Gn1WkKeNdZNWjWUhhnzdEGg1ZOA5MmjEm/ffP4ZTkNztp+j9I9PUijVhx8z3tgrVGiwc8I9Cb5oFVo2GYt4myzAE3FxrKdUqbp8w77EWcwdBxOaEizn+bIcZBGPctv47ucA2rNYiM0WVPtATq5yiMNy6xFHIQGbdqVbVJxI9QGcULvwLPGii9EP2tI02hx8ELigAYtq06TwM+kcdACPMpQzhrSYLztfSlFmm7SGrT5+8RrX3IOBwWObNaQpsHifMoAoE5jMGUz6q2xp2O1g7YT4F0uF5iwzpqz3zLd2dmJvencTinRtI75PR7UGZ7/mePwhVhmDWkaHrXjGpIgjWGkVJuiOk1CTpNccfNWF+JQzxrQdE5bOiH4vMmllFpDaCQ48/cDVocY5lnriCANw6ix07SKNvrFQqHhQcPk871RVymMs0aOAUQGbSa9ybhCa8JAgzjhe8M+l0MM86xFkKZhmxe1t3nxSmsrwTHp1zMUg6bLLUXdLi1wuH7L3RIN6nhaU/VphokL4njmm4MOCFNzaFsDNue0b00MaAiOLW0vqNJga3DRgrwbcehnjevtvNvejjj4wFGkQZy5J0HOqYajfvFJRwP56BWtWxPrbi3h6LcS+xg0vA9ojrohzDhcP6GR4Xjz8XqDJn41CnHmN61WfBmGZw7NoJGc1/gdzhvXusFGTKyoYpPJ4qBhbXYCAWLDOmswaEAjx4F3n/G9aUBGajO/5nA7IezNEVvz/G3eaOqGoE2jNBhhAWqDOLRHaVdPu0gjx8HbTllrpDhza76gE8KO09EBNM/f5mTTlStXKjqx9USjg4bJr7h4AsM4a1Z41hiNdXAMqbiMxi/CoM480rDNWmSA0Dx/m/e+7VawUWgNJnk/GgiCC9usuXo7HxmN9XC8xu24pDogpfd7u9BGbI054IQwNwdpnu9Z4N2PbwBNSQc3raETGr63aYsGg5Q4SBMhNAo4k0JfvLRsqVQ8lbSEvV0QxCE0+CIUzUGaAQoa7c/Qx7+6fKOCQ3RiW4kGBw0j2Dg+CGGZNZ+1hwyaEk6X1yjkwAV8tgWjx0NkEKdMQ43DSqP9e8+Xvmq6AZHY4PsbtUFDG/hoAG3omuPqWYHW1MOpXHp6J42t+XyrsQtkKtmlcQCNFjh0g6b9nc2ppsuXoTiS5sTWM/ugwceNGGocd2Tlkd5YDwd1KhRlF8QBGt7KaYHjG3jwmAJF87vOF5tuXK7BiS0mCo0OGt7XkOIwzJoLaIx6NRzMZFdVyjRWLXB8Phoa7T8jONl07bIYyaxdweKotQYvBWZkNvtqjrsHWgNRwrFUpcZm7qEzYIWw4xCa0ZZR6kn7QKsjWtO1a3KcWN6eaYgGbdqiAcChnbXSoJHQNufpGkdaw44jDtroKDXOslYn6Le+unBNhgM6U2nEQRq9rq6N0E9sqGct2EFo6HG8T9ecQKMFjtgaCNCMPteTwKkmsJE3h+BkMwU7JpFZ1wFNfZu2GZChnbUgtoZu1uawNYw4ZjPQiKGQ0fI7UKc3rl2oh2MoFjLlI0EhkbEXbUBTP8nrxIZy1gIdK4INTKib8/Qh0rDhmKE142Uaqlmb/VAbmhNNFyByHFHnylS6mC1kIAl7tqiLmXRKyS3M8CBDNWswaHmbjQHn6ZoVaZhwoDX/Ak05FDiz32j1sLl4oZQ9cbpjsdbFrWKxuLVo0ht0ykkuRcGGCicQARoxlDhzQIN/fxYch/nBxPj4+CjhoXrmLJ/RaNG+birJ1Js1wjMVg98M0Bk1m01iQzNr4qBBaJvTNedxAo0WOA7SGhKszT5ptPrPCD7YuHi1Hg5efJKM6FQj7PBgQ4ETGAAag4Ee5/YU+QYJOw6hefLvrVslnHGaWZt9+yWN3tn8dPGiCg6kjKOqkzc54BC931kjrbERGgacu0u826UBjs/hABpIVXMQh4KGOqeARhmnu8Hm4MXAvpvDw6ABDAPO9Fow4HKx4/icZZqa5hCZ0UOmeXnjopgLGs1abnOG57E4DTXHyfv0QMOE87QfFo0FB2n+nhBlKjiYQ6Y5DosGYZ81HDUuyvP7m7WAzwY0TDjTcP/tZsLB1kxMAA7RwebgiYCChnrRNq5eBRgNZy25BMUpyTR4Q8APrCRNBgoctOmEg4DbzY5DWjNUtsFZk5ykD5HmA6ABHC1nTVjhowSn0aM0x5uBxkSDgzrTm4GAmx2HcwLNEOBgc2TPnMOiOd508yqJprOWg+Jgc1RnjTfbBJMYBpy7C1AbJhykQRxsDoaChnbRblbhXNBi1gQTV8LhG5k13getEcMwa1MWM+9mxnECTQhtZM3B4hwCzYmNX28eAE5udSaKzVGetSgMGv6/b2hxpjeBhhWHIzQhxKnTHMA5BJpjH9/8tQan4RsCJZ2R0nGgkdMaDBrQMONML4ENIw6hGQyVcBSeOXgiUKRhf2vzKwRw0EbttAZpoDl5IVLBkdtI//mRQdOhjRwH0gjOdFvUzYhj5Z7cAxqSKpu9bggOnub1jV9+QRwtj9Km5IgDcFRPa1EH0FTC8syZ8kWD1DhIM1iFU/+0Br8Uadhz6otf9okDaRTHxmFz6uFEyaBh6GdtysvxQSYcq/XJveFBxFE5rbUcMM17QENwUAdxKqE9SgOOYUD5meNyR3tNhAZDPWvTay4+CKHGITT4A3QaeeaMKtOw1wZycLOWb1Y8rfHRhTzSsM3a9EM32lDglGnABiK1kTUHZUYPkObkhihzcLMmJDcDoLP3m9BA1LqZFEw6DMusTT8Mgg01jtv6ZD4s+7Fg6qe1g6J56+MvLl1CHFFH2xsCUz6nX+BBJ1A7ayDDL6zk8kDDjIM21Dgu631Co4gDkeFoToO1uURs2GdNKUJyp5mfmameNT4aDbTtJAUdhnXWxOcNBQ7S1PxYMLkNNgeCpzWk0bI2QCPH0fricySZ3FnyRWdmohCeB5aZqCuytCMk4a/TDifWxUUDlDhu6/05f5ikweagDrZG07z8xe/EpnbWtL/4HBGS+dX7S70+zh10Wc29C5sr+aQwgnOmxawZY75ogA6HtMbvV8BROa2NIo1mtfn9t0sUzaH8mDon5E2GlZ0VmwmocMy0aw7cCwRocCo0aKN0kpaf1pBGu5z8j717i42iCuMAvmu9gEUliAgCYuOFKOIFFFEeVEQF7wQvqC+u8fbQ2tCChLoQWi4Nd9gtZUNSSguhwK4BTCi4abdt9oFsmq5tI7tp+mDDA21NA00JBBIwfrPd9ut2Zs45c3pWZqbnM9EXn/jl+8/Z7xvOZO3ZAzjpjjXk+Rvqzz/hX/g/i+ycWAfYcOAESttb9gMNoXOIE4I00IxffG7PIA7GmpjBJ73E48TgtjYOHB/SHDXyzEGaZ4BGdNts2wY253Q75yeeWBNvw4zTkOMJGcbxJmig0IYaa9g5SCP6abMtgSPwmSO4jOJ0xRv9RnH8CRrEIXxhVz0hwEAT3TZbt0EJjbVvbm+sxTqDQYM4fp9CgziGT2sXnhkvnMb54tatAziYawYHn9g6Ap85/IPPhkhFox9x6IPPqgDQ4OU3HM+cCxBowmtG1lbEocfaL5aItS58R56pc/wKDdqocMiDT6QRXI9nbQIbu8VaDBqHHccfaO8r2484Rw11DhQGmsiamrVpEwmHfZ9jqljr+jcY8rPGmtI1RWVKccZaM3aNyHo/YWO/WOuCF0gYOwdo+gbvvsFij7UL6aGZvHiTUsZi7QcLxNqvXRVsOIlAK0rScMVaMwaa0Loza/t2Ag518GmOWNPCieV4Gv0MOMEETZFKB4oJp7pnHnaNyHK+u2k74AzY2CrWulYXUHGQhqVztBvn9TR9d+ix7TvARq9zfjRrrDHirPBSYy3ku9ZXWwRFaBzi4LMaaQTXW1k7EIfyzLFerHXlnCbj+ELezgSNSocVpyZtNGMX71BsNGLtnFlna0YGnzm7YvFQSBen1B+qgI8dYqljjTL4RBrxdeetHUohjqJjjcEnW+d819Ve2ggLai0cfyjQUd+HMmoc+uBTPA2eBHbs2wc26lizzT6noSsn7ged4TgB+Gnq7o5Ea2uLiDpHSac1pBFfU4EGbNSxZqN9Ts6urn87vCGINsQBmGCBqzMSwYuJSI+c/XqxNgdphNdzWWsAx7Kxxjr43NWV057tCYYGK+itaC8Dmf6q5Y211x1Qd89cfu/82bPn37v8+btFRtrH+9YATmqs2XHw+X1DLLa6s70j7q6ocMU72q8VRSL1q3WvkVSnmlas9cInOxdMn/1SuKnO7XK565rCL82e/rywHzdroIbh2HLwqbxDADyxSEN9fUMkEoshDAGHPCHofXvszHFhVxhcBsoddtWNG+MUM+a8NYCDsWbPwSfgKJX8r8bFREZj7eTF/V+8Ew67VBUOj1sgItI+XLMXaEZJrBm6HZc2vjlz4veOkiY3kgxtnqbpI7fJXLx3717eWLPYhIADhzQhOHoifjrb5QYcLZ2mcXeP+JR2td8GasDG/rGmi0OxgUKcthPx3dluKJd2hR99fqQ/PK/+sXdY51hy8Pm/x1rb0Xhedjbg6OrU1T04ski7unKlFo5d9zmiYi1JQ8EJzxyJzcO3VgIOxhppQmDXWFvBcVpra4vnVSRsSLHmfmAkz5x3oW+Gdc4Oq8bad6I6h44DNJUlFYijpxO+38kfaR/uBRp1rNl5nyMg1lrbXJUlYEPvnPP38r9pe3UjyKhizdb7HO5YQ5r98crdJVBUHEi1ydwn6FsbEadfx9KDz5/TGmvYNbn9H8ivoMda02zuOefKjVo4dt/njCTWoGtc3rzdKhzdRw7nr5yMxTvBxlisnVN1Du/FRCKL/2IitGHrnNYylwe+uQY2bLHWNJ/PZsJKsEntnFE2+DQca61Fbm8eFDNOHZyj+QY2OxEHCmzk4FM71pCm4HDys8UqHG2d81zTAeenYKPqnNG0zzGEk6SpPJzE2c2GU8d1Gpi8duNONc4aGWt6R+lobXZBZSUBR9PmUSfPyvPWoUM7d8pYY+2c1la3LxdsjHVOXZxnz/ba1UODONg5cp+jjVNW2+oqzYVixMG6h8NmVrFiQ4k1sLHti+zGJgR9HT5PLh1HbTOdx2ZncbEaxx77HOFH6bKWa74qsDHeOU1jeAadYFM8PNbkPkcTpyxaVunzeNQ4p6njm/OLjNvMWAs0KbFmj8FnWmKttiXu93oRx0CsnV/OMYS+WazCoU4ILBRrQjunpbOqwMuKk6pTx3EWePXm2kTnYKzJwacuTl/cX+VNxTlMirURngW+LAYbaqzZ/0V2lliL7vf4qgCHI9bcrjEcC4Ita9U49trnCDuttVwKwp0qup2zm3AgqHtprPEFwYdAM6gjJwREnGgJ2KhwQIc++Ky7n2NBULyFG8d+FxORcaJlXn8B4kCxHwjC8zkWBGu3bFHZyH2OJg58HixQoBTHM+f8Aj6bLTLWmHDg7k/lXhWeWAu/5+SwublFjSP3OZo4kXioFIon1sLTeRZrN4CGFmvyRfb+r1G6Qj6w4Yg19wMZHBd0frZ2M9BwxZo9LybSx1kdzQ75+HC4Xh6cXL55cyqOHHzq4UQVG8CBMoiTXHo6M2c+BTU1g9HmxmbESdrIfY4KBzPNx9M5D42BP+lFcxb+3n9PxJJ5kx68i24z7SbQqDsnFUe+yA46/TaBAAfO4emOGXPO9Jw8VXMKZOBOolM9PfMWjaUupG+Wp+Lc9sGniWMtFm8MqHCog8+S0/EvFv7Wm3KvNPicXTKJ0jtTboDNsFiz5z5HwOAzdkn5XovBWDtdcunoxZMa961VNy+cSd4Q3ChPxbH94HMEnQPf2A0CjqFYy8vubNO8kR3q7AekXahz1rry8nKzxZpZ9zk5K6pCfr+hWDtccbKVcI1k8xz9ccFds9YBzrDOkfscPZyIG2yMxFplRWcr8UMTgEPoG8AZbbHGjRNrDwXpOLjPqdzd2Ur+0ATg6I4FZt1QcDDW5OCThFMfLVAah/WZk1sCNLTbcZvf0Pt589nldQZxRvXgMwa3gCMOZfCZm+gaGk71t1MJNpRYky+yI06kqBQah+2Z48nrbKV+aALq7Dxtm4lvKjYy1hhwsHGCTLEGNC1s3zJoXqRjU76BgiNfZB+KUx/NRRxSrHkTNEw41Us0z2oT3ly3AXBSYk3uc0g4sU7lU7G0WKusqgQa1u/nnJ2ha8PQObZ8kZ2vc+CjICFqrFXlJmmYOqdnoa5NKo7c55BxcmDiGSTFGuAUAI2BG9lreibr2hiNtdF9MVF9xNVIjrVSD9Aw38gO1fyIpg3ApHaO3OdQcWJxQqx5vAHoGmMfmqiZ49Q6p21YNQTHjINPE8Zafazd3wg2mjil/uzuFqYb2RGnZt5d2jbDcOQ+h+WZ03061KgRayDj6aiNst3IjjZnl2Xq2CDOaBx88p3WIrF2TyMkW2Aojs8fLIh399WWGf3QRM3JRzRsPlJszB5rJtznrKiP1bfn+RsbgwPBFgiGArkgE9W+Nor4zDl1cpHGPE2xMdo58mKiRIFOd0e2xx9MlL+qJN5e1tKif98a4WuHBJvbH2sWPEpD5URikSL4toFS17pX9PWtqCXfv6qDAzaPaNi8+RXAII4cfBrCgaqPJKs+Sru6WD/WapY8qLbJ+PRy/lAcEww+LbXPGdGN7IhTszBDbeOcuwpsUnDkPiftN7KrP0Wp9fvGOSs/P3+VjLXb8qEJ7Jzq+xyaNlBmizXrTAgoOKxf2G2eqmUzF220Yk2+yC7g6mJq5/y2bLzme51fIQ5b58iLicidw3FaOzVJ+33o6yCTEmtyn5PmWFPj1CzQtHntcorNaB183oZYQ5veOTrXCyg2xFgz0eDToqc12uCzd4G2TaaSaagjB5+icehf2O3Ve7FzcmFhfr45Ys3iL7IjjLEv7J5ZlqFncyQFxxSDT4s+czhjbclU3auGluarcKDkhEB0rOmlWu9TDr1yfn69ECq/kPGZIy8mEnuU7r2P9JcKEzagUmimWLPohMBwrPVOIt5nU5iofhk5+PwfYw2KTOOYciRpo/xjxsGnjfc5F8k0jgmFgKMba/JF9jTuc6BryDXtypEBHJPFmg0nBIM6SEMq55dHAGcg1+TgM/04ycJAIxyiwWZIrMl9TpoHn0hDr2evII7qtCZfZBfdOUjDUK9dXw82ZjmtWf9FdmqsIQ21HruyfhDHPINPC7/IzhBrF+9wMNW0A0dScArNNSGw4ovslM7BrqGV81lonCE4cp+TbhzsGmrNhb4Z3jlmiDW77nOQhl5PKn2DOHKfk97TGgQae028DjKqzpH7HNGxhl3DXpmJvmF75siLiUYw+EQa5sqAw4Be58gX2QXGGtKw1xSwGcAx6+DTHrGGNMw2Bw4kbcw0IbDhi+xtSMMcah9p4kDJfY7IWMOuYS/n0gOIQ37myIuJOHCQhqNevTKAY64Jga32ORBoPPUw2PTjmHNCYPFYQxqOmrZ0vQ6O3OcIeuYADWd9otCY8rRmk31O230O3npy/fEhOHKfI3rwydM1OFIDG8SR+xxhncNPg2+sHzhO7xxrxJrp9jk5GGh8ofaCYmOK05rtLiZCGr6acOX4EByT73OsdZTGQOOs8S8cPA5F6Bw5+OSINaQZaaglcEw7IbDmPgcDjb8efuHgQYw1uc8RE2tCaByZTys2AzpynyMm1oqARkC98k8Sx6wTAgvucwTROCZAqPWfB0wxIbBDrLUKonGMXQqNQ+0ceTERO07RHQ5RNVexOWj205p1Bp/QNcJqIoRaAsc0EwKTz9bInVMkkMbhfBoah9Y58mIixs6pBRqBNSXROCY/rVlk8CmYxjHta0XGVKc1q77ILo4Gf+IcG8SR+xzOZw7SCK3H/jmWxNEffMqLieixBjTCK+NpwGF75siLifRxxNLgwPMYdo52rMmLiWixFkUakTX+5YNJHDn45OscpBFeUyDUCDimusHDnPscpBFdmS8rNqTTmryYSAMnzTR4jKZ1jjnvWzPHhCCdNI6JTxxLlAUmBCYcfKaVxuH85K+EjekmBFaItXTR4DT6v/bOoLWJKIjjs6wKYRHKGojRBZMYpSEhWEIIhuAlhxZKbQUVRNCbeBRE6EWoWBXRjyClICnYq8dc9CRePO2n2IuHNNBAC07WrjGmJumyu5l5O79D6P3HzJvM//WldZLKkYvsg8pBNSFTcv7IIZ/nkLrI/uUUhA0WTuvIjeQ50xGRGmTNbo1WDpMbn7NbfH4JvaF5hdNiM60RyXPCrxpvVEM5NKc1qnkOqomGZL7lyZE8ZyqwoUVF7Y8cyXNIVQ2SqLY8OQTzHHKLz6+oJjqu256cKfOcOF9kx6qJEr3a8uRInkNLDUA678lhnudM2hAwa2h95gr2kRzJc2hVDWLlWyesHPQSv4eJUM0MqLmFw2lD4DfPYacGu5prhuGG4KRtjZ0agJTX1STPoaYGtJLX1STPIaYGwPAKR/Icamq8LzmjlcPoBY9p5XBTA4BdbUxbo/PGZxB5DjM1YM23W8SntcAeJmKmBruaPSRnYIdRnjPtKM1MDc5qrhxZfNJTA2DMt1EOww2BrzyHlZr+N9DfciTPIacGoGK3pa3RVAN66bccyXPIqXGPHFcOxTwn+IvsrNQA1G1Xjo88R72HiYipcY8cptOar8UnJzWgF1AO+Q1BYLs1TmoAjGrbb+Wo9DARRTUAmXlXjup5zp/FJyM1/bigjbDNc056kZ2TGnceQGKc5/wgqwa02kDOuIvsqv7CLt2qQfRa2/eZw/9hIsJV0ydRaiPxzHOIq+mnoKgmlotP8moAkiiH64bAV57D4azxMFEO3cVn8G2NTdW4chRpa9NuCBipAUj15TDNc3wtPnk0tDFytqm0teDzHDZV48pBM2TynJAvsn/mpQblcJ3WfFxkZ6bmt5x45Dns1ExROUw2BJPk4Gsb/EA5MchznjSBIyhH+Tzne/M0sMS0Vc9zck0NmGJV20rnOTmOZ42HscYiz/G5+Mzxm9D+JlGzZ57nhHSRfX3hEvBGu5JXYvE5Iie3cBHYU6/y3BCMv8i+fuM8KECmao/KobIh8NnWHjV1UALLvY7L47+ppxulmU8Bf2PUbJYbguPznPVHuQugDlra5rwhGJKznruhwBTwN2bB9lM59PKcx3uXE6AYRinPcVr7t3Ier18F9dCv5G32ec7eZcX62aCvHclh+yL7XvMMKIpes21fZw6Rh4nYb2nGoaUKNvVp7T8PE6GapnJDwDBGZbRyXKjnOWoXzRFYOn6mtRkvPveaSuzPJmHgwMZsQ7B3Q6VNwKTS4ZTnfMgtKzuejaKn5202eY6y32n+h4XjNIsNQWMhNu1sgFnK2/TynHfDchoLZxUfnI9Hr1fzn3xUTnQPEzUay7E049pJVx2601qjEbeDZhgD7XwiuSH41rh8DmJO344d0rTmf0PwLbsYgzXAZBLpap7WtJbNXs6wvUwbeO0UHIdKnvMKzVwUMwP0esHZJpHnZJfiPQEch2auOc7Mf2E3u1CO7dQ8Di1Z23acGf7CbnZp8cIcCMdjpQvXnN3JeU4Ybe390rI0swmtrfLg2m7ki8/s+0VpZlNgpGo4tkX1gge6Oeyuls/LZDb1UF26tu1E0da63e5S8ZIiF8+jwkpX7ne2tsL9hd3u4cqyKce/r+ZWubXb2QhpWusebi4Wk1IxvjEy6dLNrQ4WUIAbgo+b3c3u6u0LspcJoHzSdzc6G52dnQDynM3Nj4eHK8VyUrwExFzCrKztbnX20Y3PPAfNPD84eP56sVg3ZFoOGiOTeli6vbOxs7//4oS7tTcHb96+WV0tXsgYIISFZqXK6dLdmy/2nz7dwY8xZ87rt73eW/w4WFm5d6VcTso8FglzifNmvVKsoCMsnWc/h+j1egc99PPyzp3bxeJy3UqcFy3RoxtGBqlfR6544N/1DHLR0OXAnykaYljJZNI0zVQqhZ/4tzWnaeJFEARBEARBEARBEARBEARBEARBEASBMr8ADJvUZ0bGgJQAAAAASUVORK5CYII=`;
  var setupWalletState2 = (params, network) => __awaiter4(void 0, void 0, void 0, function* () {
    const keyStore = new nearAPI4.keyStores.BrowserLocalStorageKeyStore(window.localStorage, "_meteor_wallet");
    const near = yield nearAPI4.connect(Object.assign(Object.assign({
      keyStore
    }, network), {
      headers: {}
    }));
    const wallet = new import_sdk.MeteorWallet({
      near,
      appKeyPrefix: "near_app"
    });
    return {
      wallet,
      keyStore
    };
  });
  var createMeteorWalletInjected = ({
    options,
    logger: logger2,
    store,
    params
  }) => __awaiter4(void 0, void 0, void 0, function* () {
    const _state = yield setupWalletState2(params, options.network);
    const getAccounts = () => __awaiter4(void 0, void 0, void 0, function* () {
      const accountId = _state.wallet.getAccountId();
      const account = _state.wallet.account();
      if (!accountId || !account) {
        return [];
      }
      const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);
      return [{
        accountId,
        publicKey: publicKey ? publicKey.toString() : ""
      }];
    });
    return {
      signIn({
        contractId,
        methodNames = []
      }) {
        return __awaiter4(this, void 0, void 0, function* () {
          logger2.log("MeteorWallet:signIn", {
            contractId,
            methodNames
          });
          if (methodNames.length) {
            yield _state.wallet.requestSignIn({
              methods: methodNames,
              type: import_sdk.EMeteorWalletSignInType.SELECTED_METHODS,
              contract_id: contractId
            });
          } else {
            yield _state.wallet.requestSignIn({
              type: import_sdk.EMeteorWalletSignInType.ALL_METHODS,
              contract_id: contractId
            });
          }
          const accounts = yield getAccounts();
          logger2.log("MeteorWallet:signIn", {
            contractId,
            methodNames,
            account: accounts[0]
          });
          return accounts;
        });
      },
      signOut() {
        return __awaiter4(this, void 0, void 0, function* () {
          if (_state.wallet.isSignedIn()) {
            yield _state.wallet.signOut();
          }
        });
      },
      isSignedIn() {
        return __awaiter4(this, void 0, void 0, function* () {
          if (!_state.wallet) {
            return false;
          }
          return _state.wallet.isSignedIn();
        });
      },
      getAccounts() {
        return __awaiter4(this, void 0, void 0, function* () {
          return getAccounts();
        });
      },
      verifyOwner({
        message
      }) {
        return __awaiter4(this, void 0, void 0, function* () {
          logger2.log("MeteorWallet:verifyOwner", {
            message
          });
          const response = yield _state.wallet.verifyOwner({
            message
          });
          if (response.success) {
            return response.payload;
          } else {
            throw new Error(`Couldn't verify owner: ${response.message}`);
          }
        });
      },
      signMessage({
        message,
        nonce,
        recipient,
        state
      }) {
        return __awaiter4(this, void 0, void 0, function* () {
          logger2.log("MeteorWallet:signMessage", {
            message,
            nonce,
            recipient,
            state
          });
          const accountId = _state.wallet.getAccountId();
          const response = yield _state.wallet.signMessage({
            message,
            nonce,
            recipient,
            accountId,
            state
          });
          if (response.success) {
            return response.payload;
          } else {
            throw new Error(`Couldn't sign message owner: ${response.message}`);
          }
        });
      },
      signAndSendTransaction({
        signerId,
        receiverId,
        actions
      }) {
        return __awaiter4(this, void 0, void 0, function* () {
          logger2.log("MeteorWallet:signAndSendTransaction", {
            signerId,
            receiverId,
            actions
          });
          const {
            contract
          } = store.getState();
          if (!_state.wallet.isSignedIn()) {
            throw new Error("Wallet not signed in");
          }
          if (!receiverId && !contract) {
            throw new Error("No receiver found to send the transaction to");
          }
          const account = _state.wallet.account();
          return account["signAndSendTransaction_direct"]({
            receiverId: receiverId !== null && receiverId !== void 0 ? receiverId : contract.contractId,
            actions
          });
        });
      },
      signAndSendTransactions({
        transactions: transactions4
      }) {
        return __awaiter4(this, void 0, void 0, function* () {
          logger2.log("MeteorWallet:signAndSendTransactions", {
            transactions: transactions4
          });
          if (!_state.wallet.isSignedIn()) {
            throw new Error("Wallet not signed in");
          }
          return _state.wallet.requestSignTransactions({
            transactions: transactions4
          });
        });
      },
      buildImportAccountsUrl() {
        return `https://wallet.meteorwallet.app/batch-import?network=${_state.wallet._networkId}`;
      }
    };
  });
  function setupMeteorWallet({
    iconUrl = icon2,
    deprecated = false
  } = {}) {
    return () => __awaiter4(this, void 0, void 0, function* () {
      return {
        id: "meteor-wallet",
        type: "injected",
        metadata: {
          available: true,
          name: "Meteor Wallet",
          description: "Securely store and stake your NEAR tokens and compatible assets with Meteor.",
          iconUrl,
          deprecated,
          downloadUrl: "https://wallet.meteorwallet.app",
          useUrlAccountImport: true
        },
        init: (options) => {
          return createMeteorWalletInjected(Object.assign(Object.assign({}, options), {
            params: {
              iconUrl
            }
          }));
        }
      };
    });
  }

  // node_modules/@near-wallet-selector/here-wallet/index.js
  init_process();
  init_buffer();
  var import_core2 = __toESM(require_build(), 1);
  var commonjsGlobal6 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
  var check6 = function(it) {
    return it && it.Math == Math && it;
  };
  var global$a6 = (
    // eslint-disable-next-line no-undef
    check6(typeof globalThis == "object" && globalThis) || check6(typeof window == "object" && window) || check6(typeof self == "object" && self) || check6(typeof commonjsGlobal6 == "object" && commonjsGlobal6) || // eslint-disable-next-line no-new-func
    Function("return this")()
  );
  var objectGetOwnPropertyDescriptor6 = {};
  var fails$66 = function(exec3) {
    try {
      return !!exec3();
    } catch (error2) {
      return true;
    }
  };
  var fails$56 = fails$66;
  var descriptors6 = !fails$56(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
  var objectPropertyIsEnumerable6 = {};
  var nativePropertyIsEnumerable6 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$16 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG6 = getOwnPropertyDescriptor$16 && !nativePropertyIsEnumerable6.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable6.f = NASHORN_BUG6 ? function propertyIsEnumerable6(V) {
    var descriptor = getOwnPropertyDescriptor$16(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable6;
  var createPropertyDescriptor$26 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var toString16 = {}.toString;
  var classofRaw6 = function(it) {
    return toString16.call(it).slice(8, -1);
  };
  var fails$46 = fails$66;
  var classof6 = classofRaw6;
  var split6 = "".split;
  var indexedObject6 = fails$46(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof6(it) == "String" ? split6.call(it, "") : Object(it);
  } : Object;
  var requireObjectCoercible$26 = function(it) {
    if (it == void 0) throw TypeError("Can't call method on " + it);
    return it;
  };
  var IndexedObject$15 = indexedObject6;
  var requireObjectCoercible$16 = requireObjectCoercible$26;
  var toIndexedObject$36 = function(it) {
    return IndexedObject$15(requireObjectCoercible$16(it));
  };
  var isObject$46 = function(it) {
    return typeof it === "object" ? it !== null : typeof it === "function";
  };
  var isObject$36 = isObject$46;
  var toPrimitive$26 = function(input, PREFERRED_STRING) {
    if (!isObject$36(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$36(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == "function" && !isObject$36(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject$36(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var hasOwnProperty8 = {}.hasOwnProperty;
  var has$56 = function(it, key) {
    return hasOwnProperty8.call(it, key);
  };
  var global$96 = global$a6;
  var isObject$26 = isObject$46;
  var document3 = global$96.document;
  var EXISTS6 = isObject$26(document3) && isObject$26(document3.createElement);
  var documentCreateElement6 = function(it) {
    return EXISTS6 ? document3.createElement(it) : {};
  };
  var DESCRIPTORS$46 = descriptors6;
  var fails$36 = fails$66;
  var createElement6 = documentCreateElement6;
  var ie8DomDefine6 = !DESCRIPTORS$46 && !fails$36(function() {
    return Object.defineProperty(createElement6("div"), "a", {
      get: function() {
        return 7;
      }
    }).a != 7;
  });
  var DESCRIPTORS$36 = descriptors6;
  var propertyIsEnumerableModule$15 = objectPropertyIsEnumerable6;
  var createPropertyDescriptor$16 = createPropertyDescriptor$26;
  var toIndexedObject$26 = toIndexedObject$36;
  var toPrimitive$16 = toPrimitive$26;
  var has$46 = has$56;
  var IE8_DOM_DEFINE$16 = ie8DomDefine6;
  var nativeGetOwnPropertyDescriptor6 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor6.f = DESCRIPTORS$36 ? nativeGetOwnPropertyDescriptor6 : function getOwnPropertyDescriptor12(O, P) {
    O = toIndexedObject$26(O);
    P = toPrimitive$16(P, true);
    if (IE8_DOM_DEFINE$16) try {
      return nativeGetOwnPropertyDescriptor6(O, P);
    } catch (error2) {
    }
    if (has$46(O, P)) return createPropertyDescriptor$16(!propertyIsEnumerableModule$15.f.call(O, P), O[P]);
  };
  var objectDefineProperty6 = {};
  var isObject$16 = isObject$46;
  var anObject$46 = function(it) {
    if (!isObject$16(it)) {
      throw TypeError(String(it) + " is not an object");
    }
    return it;
  };
  var DESCRIPTORS$26 = descriptors6;
  var IE8_DOM_DEFINE6 = ie8DomDefine6;
  var anObject$36 = anObject$46;
  var toPrimitive6 = toPrimitive$26;
  var nativeDefineProperty6 = Object.defineProperty;
  objectDefineProperty6.f = DESCRIPTORS$26 ? nativeDefineProperty6 : function defineProperty12(O, P, Attributes) {
    anObject$36(O);
    P = toPrimitive6(P, true);
    anObject$36(Attributes);
    if (IE8_DOM_DEFINE6) try {
      return nativeDefineProperty6(O, P, Attributes);
    } catch (error2) {
    }
    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$16 = descriptors6;
  var definePropertyModule$16 = objectDefineProperty6;
  var createPropertyDescriptor6 = createPropertyDescriptor$26;
  var createNonEnumerableProperty$46 = DESCRIPTORS$16 ? function(object, key, value) {
    return definePropertyModule$16.f(object, key, createPropertyDescriptor6(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var redefine$26 = { exports: {} };
  var global$86 = global$a6;
  var createNonEnumerableProperty$36 = createNonEnumerableProperty$46;
  var setGlobal$36 = function(key, value) {
    try {
      createNonEnumerableProperty$36(global$86, key, value);
    } catch (error2) {
      global$86[key] = value;
    }
    return value;
  };
  var global$76 = global$a6;
  var setGlobal$26 = setGlobal$36;
  var SHARED6 = "__core-js_shared__";
  var store$36 = global$76[SHARED6] || setGlobal$26(SHARED6, {});
  var sharedStore6 = store$36;
  var store$26 = sharedStore6;
  var functionToString6 = Function.toString;
  if (typeof store$26.inspectSource != "function") {
    store$26.inspectSource = function(it) {
      return functionToString6.call(it);
    };
  }
  var inspectSource$26 = store$26.inspectSource;
  var global$66 = global$a6;
  var inspectSource$16 = inspectSource$26;
  var WeakMap$16 = global$66.WeakMap;
  var nativeWeakMap6 = typeof WeakMap$16 === "function" && /native code/.test(inspectSource$16(WeakMap$16));
  var shared$16 = { exports: {} };
  var store$16 = sharedStore6;
  (shared$16.exports = function(key, value) {
    return store$16[key] || (store$16[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.6.5",
    mode: "global",
    copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
  });
  var id6 = 0;
  var postfix6 = Math.random();
  var uid$16 = function(key) {
    return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id6 + postfix6).toString(36);
  };
  var shared6 = shared$16.exports;
  var uid6 = uid$16;
  var keys12 = shared6("keys");
  var sharedKey$16 = function(key) {
    return keys12[key] || (keys12[key] = uid6(key));
  };
  var hiddenKeys$36 = {};
  var NATIVE_WEAK_MAP6 = nativeWeakMap6;
  var global$56 = global$a6;
  var isObject7 = isObject$46;
  var createNonEnumerableProperty$26 = createNonEnumerableProperty$46;
  var objectHas6 = has$56;
  var sharedKey6 = sharedKey$16;
  var hiddenKeys$26 = hiddenKeys$36;
  var WeakMap7 = global$56.WeakMap;
  var set8;
  var get9;
  var has$36;
  var enforce6 = function(it) {
    return has$36(it) ? get9(it) : set8(it, {});
  };
  var getterFor6 = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject7(it) || (state = get9(it)).type !== TYPE) {
        throw TypeError("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP6) {
    store = new WeakMap7();
    wmget = store.get;
    wmhas = store.has;
    wmset = store.set;
    set8 = function(it, metadata) {
      wmset.call(store, it, metadata);
      return metadata;
    };
    get9 = function(it) {
      return wmget.call(store, it) || {};
    };
    has$36 = function(it) {
      return wmhas.call(store, it);
    };
  } else {
    STATE = sharedKey6("state");
    hiddenKeys$26[STATE] = true;
    set8 = function(it, metadata) {
      createNonEnumerableProperty$26(it, STATE, metadata);
      return metadata;
    };
    get9 = function(it) {
      return objectHas6(it, STATE) ? it[STATE] : {};
    };
    has$36 = function(it) {
      return objectHas6(it, STATE);
    };
  }
  var store;
  var wmget;
  var wmhas;
  var wmset;
  var STATE;
  var internalState6 = {
    set: set8,
    get: get9,
    has: has$36,
    enforce: enforce6,
    getterFor: getterFor6
  };
  var global$46 = global$a6;
  var createNonEnumerableProperty$16 = createNonEnumerableProperty$46;
  var has$26 = has$56;
  var setGlobal$16 = setGlobal$36;
  var inspectSource6 = inspectSource$26;
  var InternalStateModule6 = internalState6;
  var getInternalState6 = InternalStateModule6.get;
  var enforceInternalState6 = InternalStateModule6.enforce;
  var TEMPLATE6 = String(String).split("String");
  (redefine$26.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == "function") {
      if (typeof key == "string" && !has$26(value, "name")) createNonEnumerableProperty$16(value, "name", key);
      enforceInternalState6(value).source = TEMPLATE6.join(typeof key == "string" ? key : "");
    }
    if (O === global$46) {
      if (simple) O[key] = value;
      else setGlobal$16(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$16(O, key, value);
  })(Function.prototype, "toString", function toString17() {
    return typeof this == "function" && getInternalState6(this).source || inspectSource6(this);
  });
  var global$36 = global$a6;
  var path$16 = global$36;
  var path6 = path$16;
  var global$26 = global$a6;
  var aFunction6 = function(variable) {
    return typeof variable == "function" ? variable : void 0;
  };
  var getBuiltIn$16 = function(namespace, method2) {
    return arguments.length < 2 ? aFunction6(path6[namespace]) || aFunction6(global$26[namespace]) : path6[namespace] && path6[namespace][method2] || global$26[namespace] && global$26[namespace][method2];
  };
  var objectGetOwnPropertyNames6 = {};
  var ceil6 = Math.ceil;
  var floor7 = Math.floor;
  var toInteger$26 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor7 : ceil6)(argument);
  };
  var toInteger$16 = toInteger$26;
  var min$16 = Math.min;
  var toLength$16 = function(argument) {
    return argument > 0 ? min$16(toInteger$16(argument), 9007199254740991) : 0;
  };
  var toInteger6 = toInteger$26;
  var max6 = Math.max;
  var min6 = Math.min;
  var toAbsoluteIndex$16 = function(index, length) {
    var integer = toInteger6(index);
    return integer < 0 ? max6(integer + length, 0) : min6(integer, length);
  };
  var toIndexedObject$16 = toIndexedObject$36;
  var toLength6 = toLength$16;
  var toAbsoluteIndex6 = toAbsoluteIndex$16;
  var createMethod7 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$16($this);
      var length = toLength6(O.length);
      var index = toAbsoluteIndex6(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes6 = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod7(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod7(false)
  };
  var has$16 = has$56;
  var toIndexedObject6 = toIndexedObject$36;
  var indexOf9 = arrayIncludes6.indexOf;
  var hiddenKeys$16 = hiddenKeys$36;
  var objectKeysInternal6 = function(object, names) {
    var O = toIndexedObject6(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$16(hiddenKeys$16, key) && has$16(O, key) && result.push(key);
    while (names.length > i) if (has$16(O, key = names[i++])) {
      ~indexOf9(result, key) || result.push(key);
    }
    return result;
  };
  var enumBugKeys$26 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$16 = objectKeysInternal6;
  var enumBugKeys$16 = enumBugKeys$26;
  var hiddenKeys6 = enumBugKeys$16.concat("length", "prototype");
  objectGetOwnPropertyNames6.f = Object.getOwnPropertyNames || function getOwnPropertyNames7(O) {
    return internalObjectKeys$16(O, hiddenKeys6);
  };
  var objectGetOwnPropertySymbols6 = {};
  objectGetOwnPropertySymbols6.f = Object.getOwnPropertySymbols;
  var getBuiltIn6 = getBuiltIn$16;
  var getOwnPropertyNamesModule6 = objectGetOwnPropertyNames6;
  var getOwnPropertySymbolsModule$15 = objectGetOwnPropertySymbols6;
  var anObject$26 = anObject$46;
  var ownKeys$16 = getBuiltIn6("Reflect", "ownKeys") || function ownKeys11(it) {
    var keys14 = getOwnPropertyNamesModule6.f(anObject$26(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$15.f;
    return getOwnPropertySymbols ? keys14.concat(getOwnPropertySymbols(it)) : keys14;
  };
  var has7 = has$56;
  var ownKeys12 = ownKeys$16;
  var getOwnPropertyDescriptorModule6 = objectGetOwnPropertyDescriptor6;
  var definePropertyModule6 = objectDefineProperty6;
  var copyConstructorProperties$16 = function(target, source) {
    var keys14 = ownKeys12(source);
    var defineProperty14 = definePropertyModule6.f;
    var getOwnPropertyDescriptor14 = getOwnPropertyDescriptorModule6.f;
    for (var i = 0; i < keys14.length; i++) {
      var key = keys14[i];
      if (!has7(target, key)) defineProperty14(target, key, getOwnPropertyDescriptor14(source, key));
    }
  };
  var fails$26 = fails$66;
  var replacement6 = /#|\.prototype\./;
  var isForced$16 = function(feature, detection) {
    var value = data6[normalize6(feature)];
    return value == POLYFILL6 ? true : value == NATIVE6 ? false : typeof detection == "function" ? fails$26(detection) : !!detection;
  };
  var normalize6 = isForced$16.normalize = function(string) {
    return String(string).replace(replacement6, ".").toLowerCase();
  };
  var data6 = isForced$16.data = {};
  var NATIVE6 = isForced$16.NATIVE = "N";
  var POLYFILL6 = isForced$16.POLYFILL = "P";
  var isForced_16 = isForced$16;
  var global$16 = global$a6;
  var getOwnPropertyDescriptor13 = objectGetOwnPropertyDescriptor6.f;
  var createNonEnumerableProperty6 = createNonEnumerableProperty$46;
  var redefine$16 = redefine$26.exports;
  var setGlobal6 = setGlobal$36;
  var copyConstructorProperties6 = copyConstructorProperties$16;
  var isForced6 = isForced_16;
  var _export6 = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED5, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$16;
    } else if (STATIC) {
      target = global$16[TARGET] || setGlobal6(TARGET, {});
    } else {
      target = (global$16[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor13(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED5 = isForced6(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED5 && targetProperty !== void 0) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties6(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty6(sourceProperty, "sham", true);
      }
      redefine$16(target, key, sourceProperty, options);
    }
  };
  var internalObjectKeys6 = objectKeysInternal6;
  var enumBugKeys6 = enumBugKeys$26;
  var objectKeys$16 = Object.keys || function keys13(O) {
    return internalObjectKeys6(O, enumBugKeys6);
  };
  var requireObjectCoercible6 = requireObjectCoercible$26;
  var toObject$16 = function(argument) {
    return Object(requireObjectCoercible6(argument));
  };
  var DESCRIPTORS6 = descriptors6;
  var fails$16 = fails$66;
  var objectKeys7 = objectKeys$16;
  var getOwnPropertySymbolsModule6 = objectGetOwnPropertySymbols6;
  var propertyIsEnumerableModule6 = objectPropertyIsEnumerable6;
  var toObject6 = toObject$16;
  var IndexedObject6 = indexedObject6;
  var nativeAssign5 = Object.assign;
  var defineProperty13 = Object.defineProperty;
  var objectAssign5 = !nativeAssign5 || fails$16(function() {
    if (DESCRIPTORS6 && nativeAssign5({ b: 1 }, nativeAssign5(defineProperty13({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty13(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return nativeAssign5({}, A)[symbol] != 7 || objectKeys7(nativeAssign5({}, B)).join("") != alphabet;
  }) ? function assign9(target, source) {
    var T = toObject6(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule6.f;
    var propertyIsEnumerable7 = propertyIsEnumerableModule6.f;
    while (argumentsLength > index) {
      var S = IndexedObject6(arguments[index++]);
      var keys14 = getOwnPropertySymbols ? objectKeys7(S).concat(getOwnPropertySymbols(S)) : objectKeys7(S);
      var length = keys14.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys14[j++];
        if (!DESCRIPTORS6 || propertyIsEnumerable7.call(S, key)) T[key] = S[key];
      }
    }
    return T;
  } : nativeAssign5;
  var $6 = _export6;
  var assign10 = objectAssign5;
  $6({ target: "Object", stat: true, forced: Object.assign !== assign10 }, {
    assign: assign10
  });
  function __awaiter5(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject5) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject5(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject5(e);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  var anObject$16 = anObject$46;
  var regexpFlags6 = function() {
    var that = anObject$16(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  var redefine6 = redefine$26.exports;
  var anObject6 = anObject$46;
  var fails6 = fails$66;
  var flags5 = regexpFlags6;
  var TO_STRING5 = "toString";
  var RegExpPrototype5 = RegExp.prototype;
  var nativeToString5 = RegExpPrototype5[TO_STRING5];
  var NOT_GENERIC5 = fails6(function() {
    return nativeToString5.call({ source: "a", flags: "b" }) != "/a/b";
  });
  var INCORRECT_NAME5 = nativeToString5.name != TO_STRING5;
  if (NOT_GENERIC5 || INCORRECT_NAME5) {
    redefine6(RegExp.prototype, TO_STRING5, function toString18() {
      var R = anObject6(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype5) ? flags5.call(R) : rf);
      return "/" + p + "/" + f;
    }, { unsafe: true });
  }
  var initHereWallet = (config4) => __awaiter5(void 0, void 0, void 0, function* () {
    const {
      store,
      logger: logger2,
      emitter,
      options,
      walletOptions
    } = config4;
    const here = yield import_core2.HereWallet.connect(walletOptions);
    function getAccounts() {
      return __awaiter5(this, void 0, void 0, function* () {
        logger2.log("HereWallet:getAccounts");
        const accountIds = yield here.getAccounts();
        const accounts = [];
        for (let i = 0; i < accountIds.length; i++) {
          const pub = yield here.signer.getPublicKey(accountIds[i], options.network.networkId);
          accounts.push({
            accountId: accountIds[i],
            publicKey: pub.toString()
          });
        }
        return accounts;
      });
    }
    return {
      get networkId() {
        return here.networkId;
      },
      buildImportAccountsUrl() {
        return `https://my.herewallet.app/import?network=${options.network.networkId}`;
      },
      account(id7) {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:account");
          return yield here.account(id7);
        });
      },
      switchAccount(id7) {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:switchAccount");
          yield here.switchAccount(id7);
        });
      },
      getAccountId() {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:getAccountId");
          return yield here.getAccountId();
        });
      },
      isSignedIn() {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:isSignedIn");
          return yield here.isSignedIn();
        });
      },
      signIn(data7) {
        var _a;
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:signIn");
          const isInjected = yield import_core2.waitInjectedHereWallet;
          if (!isInjected) {
            const contractId = data7.contractId !== "" ? data7.contractId : void 0;
            yield here.signIn(Object.assign(Object.assign({}, data7), {
              contractId
            }));
          }
          emitter.emit("signedIn", {
            contractId: data7.contractId,
            methodNames: (_a = data7.methodNames) !== null && _a !== void 0 ? _a : [],
            accounts: yield getAccounts()
          });
          return yield getAccounts();
        });
      },
      signOut() {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:signOut");
          yield here.signOut();
        });
      },
      getAccounts() {
        return __awaiter5(this, void 0, void 0, function* () {
          return getAccounts();
        });
      },
      signAndSendTransaction(data7) {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:signAndSendTransaction", data7);
          const {
            contract
          } = store.getState();
          return yield here.signAndSendTransaction(Object.assign({
            receiverId: contract === null || contract === void 0 ? void 0 : contract.contractId
          }, data7));
        });
      },
      verifyOwner() {
        return __awaiter5(this, void 0, void 0, function* () {
          throw Error("HereWallet:verifyOwner is deprecated, use signMessage method with implementation NEP0413 Standard");
        });
      },
      signMessage(data7) {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:signMessage", data7);
          return yield here.signMessage(data7);
        });
      },
      signAndSendTransactions(data7) {
        return __awaiter5(this, void 0, void 0, function* () {
          logger2.log("HereWallet:signAndSendTransactions", data7);
          return yield here.signAndSendTransactions(data7);
        });
      }
    };
  });
  var icon3 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xOS43MzM1IDExLjY4MzFMMjEuNzA4OSA4TDI0LjI5ODMgMTYuNjc2NkwyMC40MTYgMTQuOTIxNUwxOS43MzM1IDExLjY4MzFaTTUuNzYzODggMTUuNTQwOUwzLjc1NTYyIDE5LjE2MjFMOS44OTYwNSAyMi4xNjYxTDE4LjM0NzMgMjEuNTgyOEw1Ljc2Mzg4IDE1LjU0MDlaTTQuNjQ0NjQgMjIuMzY5NEwyLjY0ODY1IDI1Ljk3MTNMMTQuOTA4MyAzMi4wNTc1TDM1LjMzODggMzAuODE3NEwzNy4zMzQ4IDI3LjIxNTRMMTYuOTA0MyAyOC40NTU3TDQuNjQ0NjQgMjIuMzY5NFoiIGZpbGw9IiMyQzMwMzQiLz4KPHBhdGggZD0iTTM3LjMzNTkgMjcuMjE1N0wxNi45MTEyIDI4LjQ1NjFMNC41NDYzMyAyMi4zNTU0TDE3LjkzNTggMjEuNTQ1M0w1Ljc2Mzg3IDE1LjU0MDlMMTEuNzQxIDEwLjQ3ODZMMjQuMTQwMSAxNi41NzYzTDIxLjcwOSA4TDMzLjU1NyAxMy44MUwzNy4zMzU5IDI3LjIxNTdaIiBmaWxsPSIjRkRCRjFDIi8+Cjwvc3ZnPgo=";
  function setupHereWallet({
    deprecated = false,
    iconUrl = icon3,
    walletOptions
  } = {}) {
    return () => __awaiter5(this, void 0, void 0, function* () {
      const isInjected = yield import_core2.waitInjectedHereWallet;
      return {
        id: "here-wallet",
        type: "injected",
        metadata: {
          name: "Here Wallet",
          description: "Mobile wallet for NEAR Protocol",
          useUrlAccountImport: true,
          downloadUrl: "https://herewallet.app",
          topLevelInjected: isInjected != null,
          iconUrl,
          deprecated,
          available: true
        },
        init: (config4) => initHereWallet(Object.assign(Object.assign({}, config4), {
          walletOptions
        }))
      };
    });
  }

  // wallet-selector.source.js
  console.log("[NEAR Wallet Selector] \uBC88\uB4E4 \uCD08\uAE30\uD654 \uC911...");
  window.NearWalletSelectorBundle = {
    setupWalletSelector,
    setupModal,
    setupMyNearWallet,
    setupMeteorWallet,
    setupHereWallet
  };
  console.log("\u2705 NEAR Wallet Selector \uBC88\uB4E4 \uC900\uBE44 \uC644\uB8CC");
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

depd/lib/browser/index.js:
depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.1
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2025
   * @license MIT
   *)
*/
